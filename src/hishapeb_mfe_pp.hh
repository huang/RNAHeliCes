
// A dynamic programming evaluator generated by GAP-C.
// 
//   GAP-C version:
//     bellmansgapc-2012.05.07
// 
//   GAP-C call:
//     /home/jhuang/gapc/bin/gapc hishapes_lm_nolp.gap.cc -i hishapeb_mfe_pp -o hishapeb_mfe_pp.cc --kbacktrack --kbest --no-coopt-class --class-name hbmfepp 
// 
// 


#ifndef hbmfepp_hh
#define hbmfepp_hh

#include "rtlib/adp.hh"

typedef Basic_Subsequence<char, unsigned> TUSubsequence;

#include <rtlib/subopt.hh>
#include "rna.hh"
#include "filter_add.hh"
//#include "mfe_filter.hh"
#include "mfe_answer.hh"
#include "mfe_answer_v4.hh"
#include "pf_answer.hh"
#include "hishape_filter.hh"

#include <rtlib/generic_opts.hh>

class hbmfepp_insp_hash_h {
public:
typedef std::pair<Rope, mfeanswer>  type;
private:
static uint32_t k_;
public:
uint32_t hash(const type &x) const
{
return hashable_value(left_most(x));
}
type init(const type &src) const
{
type dst(src);
{
  return src;
}
}
void update(type &dst, const type &src) 
{
  if ((src.second < dst.second))
    {
      dst.second = src.second;
    }

}
bool equal(const type &a, const type &b) const
{
return left_most(a) == left_most(b);
}
bool filter() const { return false; }
bool filter(const type &x) const
{
assert(0); return false;
}
void finalize(type &src) const
{
}
static void set_k(uint32_t a) { k_ = a; }
uint32_t k() const
{
  return k_;
}
bool cutoff() const
{
  return true;
}
bool equal_score(const type &src, const type &dst) const
{
  return (src.second == dst.second);
}
struct compare {
bool operator()(const type &src, const type &dst) const
{
  return (src.second < dst.second);
}
};
};

typedef Hash::Ref<std::pair<Rope, mfeanswer> , hbmfepp_insp_hash_h > hbmfepp_hash_h;


class hbmfepp {

  public:
Basic_Sequence<char> t_0_seq;
unsigned int t_0_left_most;
unsigned int t_0_right_most;

hbmfepp_hash_h LBRope_firstG_mfeanswer_secondG_EMhdecl0x127e6d0_zero;
std::pair<Rope, mfeanswer>  BRope_firstG_mfeanswer_secondG_E_zero;

class closed_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<hbmfepp_hash_h > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
hbmfepp_hash_h zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

closed_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 7))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
hbmfepp_hash_h &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 7))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j,  const hbmfepp_hash_h &  e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 7))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
closed_table_t closed_table;


class dangle_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<hbmfepp_hash_h > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
hbmfepp_hash_h zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

dangle_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 7))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
hbmfepp_hash_h &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 7))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j,  const hbmfepp_hash_h &  e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 7))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
dangle_table_t dangle_table;


class ml_comps_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<hbmfepp_hash_h > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
hbmfepp_hash_h zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

ml_comps_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 14))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
hbmfepp_hash_h &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 14))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j,  const hbmfepp_hash_h &  e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 14))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
ml_comps_table_t ml_comps_table;


class ml_comps1_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<hbmfepp_hash_h > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
hbmfepp_hash_h zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

ml_comps1_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 7))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
hbmfepp_hash_h &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 7))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j,  const hbmfepp_hash_h &  e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 7))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
ml_comps1_table_t ml_comps1_table;


class struct_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<hbmfepp_hash_h > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
hbmfepp_hash_h zero;
unsigned int size()
{
  return (1 * ((t_0_n + 1) * 1));
}


public:

struct_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i)
{
  unsigned int t_0_j = t_0_n;
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if ((t_0_j < (t_0_n - 0)))
    {
      return true;
    }

  unsigned int t_0_real_j = (t_0_n - t_0_j);
  return tabulated[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))];
}


void clear() { tabulated.clear(); }
hbmfepp_hash_h &  get(unsigned int t_0_i)
{
  unsigned int t_0_j = t_0_n;
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if ((t_0_j < (t_0_n - 0)))
    {
      return zero;
    }

  unsigned int t_0_real_j = (t_0_n - t_0_j);
  assert( tabulated[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))]);
  assert( ((0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1))))) < size()));
  return array[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))];
}


void set(unsigned int t_0_i,  const hbmfepp_hash_h &  e)
{
  unsigned int t_0_j = t_0_n;
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if ((t_0_j < (t_0_n - 0)))
    {
      return;
    }

  unsigned int t_0_real_j = (t_0_n - t_0_j);
  assert( !is_tabulated(t_0_i));
  assert( ((0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1))))) < size()));
  array[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))] = e;
  tabulated[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))] = true;
}


};
struct_table_t struct_table;



//void init(const gapc::Opts &opts)
void init(const std::vector<std::pair<const char *, unsigned> > &inp, uint32_t kbest, const std::string &matchStr, const bool exact, const int thresh=1000000000, const bool locallymin=false, const float theta=0.0f)
{
//const std::vector<std::pair<const char *, unsigned> > &inp = opts.inputs;
if(inp.size() != 1)
  throw gapc::OptException("Number of input sequences does not match.");

  t_0_seq.copy(inp[0].first, inp[0].second);
char_to_rna(t_0_seq);
  closed_table.init( t_0_seq.size(), "closed_table");
  dangle_table.init( t_0_seq.size(), "dangle_table");
  ml_comps_table.init( t_0_seq.size(), "ml_comps_table");
  ml_comps1_table.init( t_0_seq.size(), "ml_comps1_table");
  struct_table.init( t_0_seq.size(), "struct_table");
empty(LBRope_firstG_mfeanswer_secondG_EMhdecl0x127e6d0_zero);
empty(BRope_firstG_mfeanswer_secondG_E_zero);

t_0_left_most = 0;
t_0_right_most = t_0_seq.size();
hbmfepp_insp_hash_h::set_k(kbest);
    std::vector<std::string> tokens;      
    const std::string delimiters = ",";   
    // Skip delimiters at beginning.
    std::string::size_type lastPos = matchStr.find_first_not_of(delimiters, 0);
    // Find first "non-delimiter".
    std::string::size_type pos     = matchStr.find_first_of(delimiters, lastPos);
    while (std::string::npos != pos || std::string::npos != lastPos)
    {
        // Found a token, add it to the vector.
        tokens.push_back(matchStr.substr(lastPos, pos - lastPos));
        // Skip delimiters.  Note the "not_of"
        lastPos = matchStr.find_first_not_of(delimiters, pos);
        // Find next "non-delimiter"
        pos = matchStr.find_first_of(delimiters, lastPos);
    }

    
    std::vector<std::string>::iterator it;
    for ( it=tokens.begin() ; it < tokens.end(); it++ ) {
      std::string tmp = *it;
      if (tmp[tmp.length()-1] == 'm') {
        tmp.erase(tmp.length()-1);
        _match_tokens_m.push_back(tmp);
      } else if (tmp[tmp.length()-1] == 'i') {
        tmp.erase(tmp.length()-1);
        _match_tokens_i.push_back(tmp);
      } else if (tmp[tmp.length()-1] == 'b') {
        tmp.erase(tmp.length()-1);
        _match_tokens_b.push_back(tmp);
      } else {
        _match_tokens_h.push_back(tmp);
      }
    }
    _exact = exact;
    _thresh = thresh;
    _locallymin = locallymin;
    _theta = theta;
}

  private:
    std::vector<std::string> _match_tokens_h, _match_tokens_m, _match_tokens_i, _match_tokens_b;
    bool _exact;
    int _thresh;
    bool _locallymin;
    float _theta;
    
    
    hbmfepp_hash_h &  nt_closed(unsigned int t_0_i, unsigned int t_0_j);
    hbmfepp_hash_h &  nt_dangle(unsigned int t_0_i, unsigned int t_0_j);
    std::pair<Rope, mfeanswer>  nt_hairpin(unsigned int t_0_i, unsigned int t_0_j);
    hbmfepp_hash_h nt_iloop(unsigned int t_0_i, unsigned int t_0_j);
    hbmfepp_hash_h nt_initstem(unsigned int t_0_i, unsigned int t_0_j);
    hbmfepp_hash_h nt_leftB(unsigned int t_0_i, unsigned int t_0_j);
    hbmfepp_hash_h &  nt_ml_comps(unsigned int t_0_i, unsigned int t_0_j);
    hbmfepp_hash_h &  nt_ml_comps1(unsigned int t_0_i, unsigned int t_0_j);
    hbmfepp_hash_h nt_multiloop(unsigned int t_0_i, unsigned int t_0_j);
    hbmfepp_hash_h nt_rightB(unsigned int t_0_i, unsigned int t_0_j);
    hbmfepp_hash_h nt_stack(unsigned int t_0_i, unsigned int t_0_j);
    hbmfepp_hash_h &  nt_struct(unsigned int t_0_i);

    std::pair<Rope, mfeanswer>  addss(const std::pair<Rope, mfeanswer> & p_e, const TUSubsequence & p_rb);
    std::pair<Rope, mfeanswer>  bl(const TUSubsequence & p_lregion, const std::pair<Rope, mfeanswer> & p_e);
    std::pair<Rope, mfeanswer>  br(const std::pair<Rope, mfeanswer> & p_e, const TUSubsequence & p_rregion);
    std::pair<Rope, mfeanswer>  cadd(const std::pair<Rope, mfeanswer> & p_le, const std::pair<Rope, mfeanswer> & p_re);
    std::pair<Rope, mfeanswer>  drem(const std::pair<Rope, mfeanswer> & p_e);
    std::pair<Rope, mfeanswer>  edl(const TUSubsequence & p_lb, const std::pair<Rope, mfeanswer> & p_e);
    std::pair<Rope, mfeanswer>  edlr(const TUSubsequence & p_lb, const std::pair<Rope, mfeanswer> & p_e, const TUSubsequence & p_rb);
    std::pair<Rope, mfeanswer>  edr(const std::pair<Rope, mfeanswer> & p_e, const TUSubsequence & p_rb);
template <typename Iterator>
    hbmfepp_hash_h h(std::pair<Iterator, Iterator> i)
;
    std::pair<Rope, mfeanswer>  hl(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const TUSubsequence & p_region, const TUSubsequence & p_rb, const TUSubsequence & p_rrb);
    std::pair<Rope, mfeanswer>  il(const TUSubsequence & p_lregion, const std::pair<Rope, mfeanswer> & p_e, const TUSubsequence & p_rregion);
    std::pair<Rope, mfeanswer>  incl(const std::pair<Rope, mfeanswer> & p_e);
    std::pair<Rope, mfeanswer>  is(const std::pair<Rope, mfeanswer> & p_e);
    std::pair<Rope, mfeanswer>  ml(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const std::pair<Rope, mfeanswer> & p_e, const TUSubsequence & p_rb, const TUSubsequence & p_rrb);
    std::pair<Rope, mfeanswer>  mldl(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<Rope, mfeanswer> & p_e, const TUSubsequence & p_rb, const TUSubsequence & p_rrb);
    std::pair<Rope, mfeanswer>  mldlr(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<Rope, mfeanswer> & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb, const TUSubsequence & p_rrb);
    std::pair<Rope, mfeanswer>  mldr(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const std::pair<Rope, mfeanswer> & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb, const TUSubsequence & p_rrb);
    std::pair<Rope, mfeanswer>  nil(const TUSubsequence & p_loc);
    std::pair<Rope, mfeanswer>  sadd(const TUSubsequence & p_b, const std::pair<Rope, mfeanswer> & p_e);
    std::pair<Rope, mfeanswer>  sp(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const std::pair<Rope, mfeanswer> & p_e, const TUSubsequence & p_rb, const TUSubsequence & p_rrb);
    std::pair<Rope, mfeanswer>  sr(const TUSubsequence & p_lb, const std::pair<Rope, mfeanswer> & p_e, const TUSubsequence & p_rb);


    Rope addss_l(const Rope & e, const TUSubsequence & rb);
    Rope bl_l(const TUSubsequence & lregion, const Rope & e);
    Rope br_l(const Rope & e, const TUSubsequence & rregion);
    Rope cadd_l(const Rope & le, const Rope & re);
    Rope drem_l(const Rope & e);
    Rope edl_l(const TUSubsequence & lb, const Rope & e);
    Rope edlr_l(const TUSubsequence & lb, const Rope & e, const TUSubsequence & rb);
    Rope edr_l(const Rope & e, const TUSubsequence & rb);
    Rope hl_l(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & region, const TUSubsequence & rb, const TUSubsequence & rrb);
    Rope il_l(const TUSubsequence & lregion, const Rope & e, const TUSubsequence & rregion);
    Rope incl_l(const Rope & e);
    Rope is_l(const Rope & e);
    Rope ml_l(const TUSubsequence & llb, const TUSubsequence & lb, const Rope & e, const TUSubsequence & rb, const TUSubsequence & rrb);
    Rope mldl_l(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const Rope & e, const TUSubsequence & rb, const TUSubsequence & rrb);
    Rope mldlr_l(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const Rope & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb);
    Rope mldr_l(const TUSubsequence & llb, const TUSubsequence & lb, const Rope & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb);
    Rope nil_l(const TUSubsequence & loc);
    Rope sadd_l(const TUSubsequence & b, const Rope & e);
    Rope sp_l(const TUSubsequence & llb, const TUSubsequence & lb, const Rope & e, const TUSubsequence & rb, const TUSubsequence & rrb);
    Rope sr_l(const TUSubsequence & lb, const Rope & e, const TUSubsequence & rb);


    mfeanswer addss_r(const mfeanswer & e, const TUSubsequence & rb);
    mfeanswer bl_r(const TUSubsequence & lregion, const mfeanswer & e);
    mfeanswer br_r(const mfeanswer & e, const TUSubsequence & rregion);
    mfeanswer cadd_r(const mfeanswer & le, const mfeanswer & re);
    mfeanswer drem_r(const mfeanswer & e);
    mfeanswer edl_r(const TUSubsequence & lb, const mfeanswer & e);
    mfeanswer edlr_r(const TUSubsequence & lb, const mfeanswer & e, const TUSubsequence & rb);
    mfeanswer edr_r(const mfeanswer & e, const TUSubsequence & rb);
    mfeanswer hl_r(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & region, const TUSubsequence & rb, const TUSubsequence & rrb);
    mfeanswer il_r(const TUSubsequence & lregion, const mfeanswer & e, const TUSubsequence & rregion);
    mfeanswer incl_r(const mfeanswer & e);
    mfeanswer is_r(const mfeanswer & e);
    mfeanswer ml_r(const TUSubsequence & llb, const TUSubsequence & lb, const mfeanswer & e, const TUSubsequence & rb, const TUSubsequence & rrb);
    mfeanswer mldl_r(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const mfeanswer & e, const TUSubsequence & rb, const TUSubsequence & rrb);
    mfeanswer mldlr_r(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const mfeanswer & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb);
    mfeanswer mldr_r(const TUSubsequence & llb, const TUSubsequence & lb, const mfeanswer & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb);
    mfeanswer nil_r(const TUSubsequence & loc);
    mfeanswer sadd_r(const TUSubsequence & lb, const mfeanswer & e);
    mfeanswer sp_r(const TUSubsequence & llb, const TUSubsequence & lb, const mfeanswer & e, const TUSubsequence & rb, const TUSubsequence & rrb);
    mfeanswer sr_r(const TUSubsequence & lb, const mfeanswer & e, const TUSubsequence & rb);


 public:
   void cyk();

 public:
   hbmfepp_hash_h &  run()
{
  return nt_struct(t_0_left_most);
}
void print_stats(std::ostream &o)
{
#ifdef STATS
      o << "\n\nN = " << seq.size() << '\n';
      closed_table.print_stats(o, "closed_table");
      dangle_table.print_stats(o, "dangle_table");
      ml_comps_table.print_stats(o, "ml_comps_table");
      ml_comps1_table.print_stats(o, "ml_comps1_table");
      struct_table.print_stats(o, "struct_table");
#endif
}

template <typename Value, typename pos_int>
struct Backtrace_addss : Backtrace_Score<std::pair<Rope, mfeanswer> , Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;
      TUSubsequence arg_rb;

Backtrace_addss(intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_, TUSubsequence arg_rb_)
 : arg_e(arg_e_), arg_rb(arg_rb_)
{}

~Backtrace_addss()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String addss(const String & e, const TUSubsequence & rb)
      {
#line 2614 ""
        String res;
        append( res, e);
        append( res, '.', size(rb));
        return res;
#line 466 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = addss(arg_e_elem, arg_rb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = addss(arg_e_elem, arg_rb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_bl : Backtrace_Score<std::pair<Rope, mfeanswer> , Value, pos_int> {
      TUSubsequence arg_lregion;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;

Backtrace_bl(TUSubsequence arg_lregion_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_)
 : arg_lregion(arg_lregion_), arg_e(arg_e_)
{}

~Backtrace_bl()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String bl(const TUSubsequence & lregion, const String & e)
      {
#line 2508 ""
        String res;
        append( res, '.', size(lregion));
        append( res, e);
        return res;
#line 524 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = bl(arg_lregion, arg_e_elem);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = bl(arg_lregion, arg_e_elem);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_br : Backtrace_Score<std::pair<Rope, mfeanswer> , Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;
      TUSubsequence arg_rregion;

Backtrace_br(intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_, TUSubsequence arg_rregion_)
 : arg_e(arg_e_), arg_rregion(arg_rregion_)
{}

~Backtrace_br()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String br(const String & e, const TUSubsequence & rregion)
      {
#line 2515 ""
        String res;
        append( res, e);
        append( res, '.', size(rregion));
        return res;
#line 582 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = br(arg_e_elem, arg_rregion);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = br(arg_e_elem, arg_rregion);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_cadd : Backtrace_Score<std::pair<Rope, mfeanswer> , Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_le;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_re;

Backtrace_cadd(intrusive_ptr<Backtrace<Value, pos_int> >  arg_le_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_)
 : arg_le(arg_le_), arg_re(arg_re_)
{}

~Backtrace_cadd()
{
erase(arg_le);
erase(arg_re);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String cadd(const String & le, const String & re)
      {
#line 2400 ""
        String res;
        append( res, le);
        append( res, re);
        return res;
#line 641 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_le_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_le);
        if (!arg_le_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_le_bt = arg_le;
          intrusive_ptr<Backtrace_List<Value, pos_int> > arg_re_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_re);
          if (!arg_re_t) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_bt = arg_re;
            intrusive_ptr<Eval_List<Value> > arg_le_elist = evaluate(arg_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_re_elist = evaluate(arg_re_bt);
            for (typename Eval_List<Value>::iterator arg_le_elem_itr = arg_le_elist->begin(); arg_le_elem_itr != arg_le_elist->end(); ++ arg_le_elem_itr) {
              String arg_le_elem = *arg_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_re_elem_itr = arg_re_elist->begin(); arg_re_elem_itr != arg_re_elist->end(); ++ arg_re_elem_itr) {
                String arg_re_elem = *arg_re_elem_itr;
                String ret = cadd(arg_le_elem, arg_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_le_elist);
            erase( arg_re_elist);
          } else 
          for (typename Backtrace_List<Value, pos_int>::iterator arg_re_bt_itr = arg_re_t->begin(); arg_re_bt_itr != arg_re_t->end(); ++ arg_re_bt_itr) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_bt = *arg_re_bt_itr;
            intrusive_ptr<Eval_List<Value> > arg_le_elist = evaluate(arg_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_re_elist = evaluate(arg_re_bt);
            for (typename Eval_List<Value>::iterator arg_le_elem_itr = arg_le_elist->begin(); arg_le_elem_itr != arg_le_elist->end(); ++ arg_le_elem_itr) {
              String arg_le_elem = *arg_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_re_elem_itr = arg_re_elist->begin(); arg_re_elem_itr != arg_re_elist->end(); ++ arg_re_elem_itr) {
                String arg_re_elem = *arg_re_elem_itr;
                String ret = cadd(arg_le_elem, arg_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_le_elist);
            erase( arg_re_elist);
          }
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_le_bt_itr = arg_le_t->begin(); arg_le_bt_itr != arg_le_t->end(); ++ arg_le_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_le_bt = *arg_le_bt_itr;
          intrusive_ptr<Backtrace_List<Value, pos_int> > arg_re_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_re);
          if (!arg_re_t) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_bt = arg_re;
            intrusive_ptr<Eval_List<Value> > arg_le_elist = evaluate(arg_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_re_elist = evaluate(arg_re_bt);
            for (typename Eval_List<Value>::iterator arg_le_elem_itr = arg_le_elist->begin(); arg_le_elem_itr != arg_le_elist->end(); ++ arg_le_elem_itr) {
              String arg_le_elem = *arg_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_re_elem_itr = arg_re_elist->begin(); arg_re_elem_itr != arg_re_elist->end(); ++ arg_re_elem_itr) {
                String arg_re_elem = *arg_re_elem_itr;
                String ret = cadd(arg_le_elem, arg_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_le_elist);
            erase( arg_re_elist);
          } else 
          for (typename Backtrace_List<Value, pos_int>::iterator arg_re_bt_itr = arg_re_t->begin(); arg_re_bt_itr != arg_re_t->end(); ++ arg_re_bt_itr) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_bt = *arg_re_bt_itr;
            intrusive_ptr<Eval_List<Value> > arg_le_elist = evaluate(arg_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_re_elist = evaluate(arg_re_bt);
            for (typename Eval_List<Value>::iterator arg_le_elem_itr = arg_le_elist->begin(); arg_le_elem_itr != arg_le_elist->end(); ++ arg_le_elem_itr) {
              String arg_le_elem = *arg_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_re_elem_itr = arg_re_elist->begin(); arg_re_elem_itr != arg_re_elist->end(); ++ arg_re_elem_itr) {
                String arg_re_elem = *arg_re_elem_itr;
                String ret = cadd(arg_le_elem, arg_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_le_elist);
            erase( arg_re_elist);
          }
        }
        erase( arg_le);
        erase( arg_re);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_drem : Backtrace_Score<std::pair<Rope, mfeanswer> , Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;

Backtrace_drem(intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_)
 : arg_e(arg_e_)
{}

~Backtrace_drem()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String drem(const String & e)
      {
#line 2476 ""
        return e;
#line 744 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = drem(arg_e_elem);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = drem(arg_e_elem);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_edl : Backtrace_Score<std::pair<Rope, mfeanswer> , Value, pos_int> {
      TUSubsequence arg_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;

Backtrace_edl(TUSubsequence arg_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_)
 : arg_lb(arg_lb_), arg_e(arg_e_)
{}

~Backtrace_edl()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String edl(const TUSubsequence & lb, const String & e)
      {
#line 2454 ""
        String res;
        append( res, '.');
        append( res, e);
        return res;
#line 802 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = edl(arg_lb, arg_e_elem);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = edl(arg_lb, arg_e_elem);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_edlr : Backtrace_Score<std::pair<Rope, mfeanswer> , Value, pos_int> {
      TUSubsequence arg_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;
      TUSubsequence arg_rb;

Backtrace_edlr(TUSubsequence arg_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_, TUSubsequence arg_rb_)
 : arg_lb(arg_lb_), arg_e(arg_e_), arg_rb(arg_rb_)
{}

~Backtrace_edlr()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String edlr(const TUSubsequence & lb, const String & e, const TUSubsequence & rb)
      {
#line 2468 ""
        String res;
        append( res, '.');
        append( res, e);
        append( res, '.');
        return res;
#line 862 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = edlr(arg_lb, arg_e_elem, arg_rb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = edlr(arg_lb, arg_e_elem, arg_rb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_edr : Backtrace_Score<std::pair<Rope, mfeanswer> , Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;
      TUSubsequence arg_rb;

Backtrace_edr(intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_, TUSubsequence arg_rb_)
 : arg_e(arg_e_), arg_rb(arg_rb_)
{}

~Backtrace_edr()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String edr(const String & e, const TUSubsequence & rb)
      {
#line 2461 ""
        String res;
        append( res, e);
        append( res, '.');
        return res;
#line 920 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = edr(arg_e_elem, arg_rb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = edr(arg_e_elem, arg_rb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_hl : Backtrace_Score<std::pair<Rope, mfeanswer> , Value, pos_int> {
      TUSubsequence arg_llb;
      TUSubsequence arg_lb;
      TUSubsequence arg_region;
      TUSubsequence arg_rb;
      TUSubsequence arg_rrb;

Backtrace_hl(TUSubsequence arg_llb_, TUSubsequence arg_lb_, TUSubsequence arg_region_, TUSubsequence arg_rb_, TUSubsequence arg_rrb_)
 : arg_llb(arg_llb_), arg_lb(arg_lb_), arg_region(arg_region_), arg_rb(arg_rb_), arg_rrb(arg_rrb_)
{}

~Backtrace_hl()
{
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String hl(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & region, const TUSubsequence & rb, const TUSubsequence & rrb)
      {
#line 2492 ""
        String res;
        append( res, "((", 2);
        append( res, '.', size(region));
        append( res, "))", 2);
        return res;
#line 981 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        String ret = hl(arg_llb, arg_lb, arg_region, arg_rb, arg_rrb);
        push_back( answer, ret);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_il : Backtrace_Score<std::pair<Rope, mfeanswer> , Value, pos_int> {
      TUSubsequence arg_lregion;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;
      TUSubsequence arg_rregion;

Backtrace_il(TUSubsequence arg_lregion_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_, TUSubsequence arg_rregion_)
 : arg_lregion(arg_lregion_), arg_e(arg_e_), arg_rregion(arg_rregion_)
{}

~Backtrace_il()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String il(const TUSubsequence & lregion, const String & e, const TUSubsequence & rregion)
      {
#line 2522 ""
        String res;
        append( res, '.', size(lregion));
        append( res, e);
        append( res, '.', size(rregion));
        return res;
#line 1021 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = il(arg_lregion, arg_e_elem, arg_rregion);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = il(arg_lregion, arg_e_elem, arg_rregion);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_incl : Backtrace_Score<std::pair<Rope, mfeanswer> , Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;

Backtrace_incl(intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_)
 : arg_e(arg_e_)
{}

~Backtrace_incl()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String incl(const String & e)
      {
#line 2632 ""
        return e;
#line 1075 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = incl(arg_e_elem);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = incl(arg_e_elem);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_is : Backtrace_Score<std::pair<Rope, mfeanswer> , Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;

Backtrace_is(intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_)
 : arg_e(arg_e_)
{}

~Backtrace_is()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String is(const String & e)
      {
#line 2480 ""
        return e;
#line 1129 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = is(arg_e_elem);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = is(arg_e_elem);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_ml : Backtrace_Score<std::pair<Rope, mfeanswer> , Value, pos_int> {
      TUSubsequence arg_llb;
      TUSubsequence arg_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;
      TUSubsequence arg_rb;
      TUSubsequence arg_rrb;

Backtrace_ml(TUSubsequence arg_llb_, TUSubsequence arg_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_, TUSubsequence arg_rb_, TUSubsequence arg_rrb_)
 : arg_llb(arg_llb_), arg_lb(arg_lb_), arg_e(arg_e_), arg_rb(arg_rb_), arg_rrb(arg_rrb_)
{}

~Backtrace_ml()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String ml(const TUSubsequence & llb, const TUSubsequence & lb, const String & e, const TUSubsequence & rb, const TUSubsequence & rrb)
      {
#line 2530 ""
        String res;
        append( res, "((", 2);
        append( res, e);
        append( res, "))", 2);
        return res;
#line 1191 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = ml(arg_llb, arg_lb, arg_e_elem, arg_rb, arg_rrb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = ml(arg_llb, arg_lb, arg_e_elem, arg_rb, arg_rrb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_mldl : Backtrace_Score<std::pair<Rope, mfeanswer> , Value, pos_int> {
      TUSubsequence arg_llb;
      TUSubsequence arg_lb;
      TUSubsequence arg_dl;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;
      TUSubsequence arg_rb;
      TUSubsequence arg_rrb;

Backtrace_mldl(TUSubsequence arg_llb_, TUSubsequence arg_lb_, TUSubsequence arg_dl_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_, TUSubsequence arg_rb_, TUSubsequence arg_rrb_)
 : arg_llb(arg_llb_), arg_lb(arg_lb_), arg_dl(arg_dl_), arg_e(arg_e_), arg_rb(arg_rb_), arg_rrb(arg_rrb_)
{}

~Backtrace_mldl()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String mldl(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const String & e, const TUSubsequence & rb, const TUSubsequence & rrb)
      {
#line 2596 ""
        String res;
        append( res, "((", 2);
        append( res, '.');
        append( res, e);
        append( res, "))", 2);
        return res;
#line 1255 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = mldl(arg_llb, arg_lb, arg_dl, arg_e_elem, arg_rb, arg_rrb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = mldl(arg_llb, arg_lb, arg_dl, arg_e_elem, arg_rb, arg_rrb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_mldlr : Backtrace_Score<std::pair<Rope, mfeanswer> , Value, pos_int> {
      TUSubsequence arg_llb;
      TUSubsequence arg_lb;
      TUSubsequence arg_dl;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;
      TUSubsequence arg_dr;
      TUSubsequence arg_rb;
      TUSubsequence arg_rrb;

Backtrace_mldlr(TUSubsequence arg_llb_, TUSubsequence arg_lb_, TUSubsequence arg_dl_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_, TUSubsequence arg_dr_, TUSubsequence arg_rb_, TUSubsequence arg_rrb_)
 : arg_llb(arg_llb_), arg_lb(arg_lb_), arg_dl(arg_dl_), arg_e(arg_e_), arg_dr(arg_dr_), arg_rb(arg_rb_), arg_rrb(arg_rrb_)
{}

~Backtrace_mldlr()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String mldlr(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const String & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb)
      {
#line 2556 ""
        String res;
        append( res, "((", 2);
        append( res, '.');
        append( res, e);
        append( res, '.');
        append( res, "))", 2);
        return res;
#line 1321 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = mldlr(arg_llb, arg_lb, arg_dl, arg_e_elem, arg_dr, arg_rb, arg_rrb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = mldlr(arg_llb, arg_lb, arg_dl, arg_e_elem, arg_dr, arg_rb, arg_rrb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_mldr : Backtrace_Score<std::pair<Rope, mfeanswer> , Value, pos_int> {
      TUSubsequence arg_llb;
      TUSubsequence arg_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;
      TUSubsequence arg_dr;
      TUSubsequence arg_rb;
      TUSubsequence arg_rrb;

Backtrace_mldr(TUSubsequence arg_llb_, TUSubsequence arg_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_, TUSubsequence arg_dr_, TUSubsequence arg_rb_, TUSubsequence arg_rrb_)
 : arg_llb(arg_llb_), arg_lb(arg_lb_), arg_e(arg_e_), arg_dr(arg_dr_), arg_rb(arg_rb_), arg_rrb(arg_rrb_)
{}

~Backtrace_mldr()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String mldr(const TUSubsequence & llb, const TUSubsequence & lb, const String & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb)
      {
#line 2538 ""
        String res;
        append( res, "((", 2);
        append( res, e);
        append( res, '.');
        append( res, "))", 2);
        return res;
#line 1385 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = mldr(arg_llb, arg_lb, arg_e_elem, arg_dr, arg_rb, arg_rrb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = mldr(arg_llb, arg_lb, arg_e_elem, arg_dr, arg_rb, arg_rrb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_nil : Backtrace_Score<std::pair<Rope, mfeanswer> , Value, pos_int> {
      TUSubsequence arg_loc;

Backtrace_nil(TUSubsequence arg_loc_)
 : arg_loc(arg_loc_)
{}

~Backtrace_nil()
{
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String nil(const TUSubsequence & loc)
      {
#line 2444 ""
        String r;
        return r;
#line 1439 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        String ret = nil(arg_loc);
        push_back( answer, ret);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_sadd : Backtrace_Score<std::pair<Rope, mfeanswer> , Value, pos_int> {
      TUSubsequence arg_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;

Backtrace_sadd(TUSubsequence arg_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_)
 : arg_lb(arg_lb_), arg_e(arg_e_)
{}

~Backtrace_sadd()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String sadd(const TUSubsequence & lb, const String & e)
      {
#line 2393 ""
        String res;
        append( res, '.');
        append( res, e);
        return res;
#line 1477 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = sadd(arg_lb, arg_e_elem);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = sadd(arg_lb, arg_e_elem);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_sp : Backtrace_Score<std::pair<Rope, mfeanswer> , Value, pos_int> {
      TUSubsequence arg_llb;
      TUSubsequence arg_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;
      TUSubsequence arg_rb;
      TUSubsequence arg_rrb;

Backtrace_sp(TUSubsequence arg_llb_, TUSubsequence arg_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_, TUSubsequence arg_rb_, TUSubsequence arg_rrb_)
 : arg_llb(arg_llb_), arg_lb(arg_lb_), arg_e(arg_e_), arg_rb(arg_rb_), arg_rrb(arg_rrb_)
{}

~Backtrace_sp()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String sp(const TUSubsequence & llb, const TUSubsequence & lb, const String & e, const TUSubsequence & rb, const TUSubsequence & rrb)
      {
#line 2500 ""
        String res;
        append( res, "((", 2);
        append( res, e);
        append( res, "))", 2);
        return res;
#line 1539 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = sp(arg_llb, arg_lb, arg_e_elem, arg_rb, arg_rrb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = sp(arg_llb, arg_lb, arg_e_elem, arg_rb, arg_rrb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_sr : Backtrace_Score<std::pair<Rope, mfeanswer> , Value, pos_int> {
      TUSubsequence arg_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;
      TUSubsequence arg_rb;

Backtrace_sr(TUSubsequence arg_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_, TUSubsequence arg_rb_)
 : arg_lb(arg_lb_), arg_e(arg_e_), arg_rb(arg_rb_)
{}

~Backtrace_sr()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String sr(const TUSubsequence & lb, const String & e, const TUSubsequence & rb)
      {
#line 2484 ""
        String res;
        append( res, '(');
        append( res, e);
        append( res, ')');
        return res;
#line 1599 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = sr(arg_lb, arg_e_elem, arg_rb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = sr(arg_lb, arg_e_elem, arg_rb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_struct_Back : public Backtrace_NT_Back_Base<std::pair<Rope, mfeanswer> , Klass, Value, pos_int>
{
pos_int t_0_i;
Backtrace_nt_struct_Back(Klass *klass_, pos_int t_0_i_)
  : Backtrace_NT_Back_Base<std::pair<Rope, mfeanswer> , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_struct(t_0_i));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_struct_Front : public Backtrace_Score<std::pair<Rope, mfeanswer>  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_struct_Back<hbmfepp, Value, pos_int> > back;

Backtrace_nt_struct_Front(intrusive_ptr<Backtrace_nt_struct_Back<hbmfepp, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, mfeanswer> , hbmfepp, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_dangle_Back : public Backtrace_NT_Back_Base<std::pair<Rope, mfeanswer> , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_dangle_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, mfeanswer> , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_dangle(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_dangle_Front : public Backtrace_Score<std::pair<Rope, mfeanswer>  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_dangle_Back<hbmfepp, Value, pos_int> > back;

Backtrace_nt_dangle_Front(intrusive_ptr<Backtrace_nt_dangle_Back<hbmfepp, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, mfeanswer> , hbmfepp, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_initstem_Back : public Backtrace_NT_Back_Base<std::pair<Rope, mfeanswer> , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_initstem_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, mfeanswer> , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_initstem(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_initstem_Front : public Backtrace_Score<std::pair<Rope, mfeanswer>  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_initstem_Back<hbmfepp, Value, pos_int> > back;

Backtrace_nt_initstem_Front(intrusive_ptr<Backtrace_nt_initstem_Back<hbmfepp, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, mfeanswer> , hbmfepp, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_closed_Back : public Backtrace_NT_Back_Base<std::pair<Rope, mfeanswer> , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_closed_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, mfeanswer> , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_closed(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_closed_Front : public Backtrace_Score<std::pair<Rope, mfeanswer>  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_closed_Back<hbmfepp, Value, pos_int> > back;

Backtrace_nt_closed_Front(intrusive_ptr<Backtrace_nt_closed_Back<hbmfepp, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, mfeanswer> , hbmfepp, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_stack_Back : public Backtrace_NT_Back_Base<std::pair<Rope, mfeanswer> , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_stack_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, mfeanswer> , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_stack(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_stack_Front : public Backtrace_Score<std::pair<Rope, mfeanswer>  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_stack_Back<hbmfepp, Value, pos_int> > back;

Backtrace_nt_stack_Front(intrusive_ptr<Backtrace_nt_stack_Back<hbmfepp, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, mfeanswer> , hbmfepp, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_hairpin_Back : public Backtrace_NT_Back_Base<std::pair<Rope, mfeanswer> , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_hairpin_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, mfeanswer> , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_hairpin(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_hairpin_Front : public Backtrace_Score<std::pair<Rope, mfeanswer>  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_hairpin_Back<hbmfepp, Value, pos_int> > back;

Backtrace_nt_hairpin_Front(intrusive_ptr<Backtrace_nt_hairpin_Back<hbmfepp, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, mfeanswer> , hbmfepp, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_leftB_Back : public Backtrace_NT_Back_Base<std::pair<Rope, mfeanswer> , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_leftB_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, mfeanswer> , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_leftB(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_leftB_Front : public Backtrace_Score<std::pair<Rope, mfeanswer>  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_leftB_Back<hbmfepp, Value, pos_int> > back;

Backtrace_nt_leftB_Front(intrusive_ptr<Backtrace_nt_leftB_Back<hbmfepp, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, mfeanswer> , hbmfepp, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_rightB_Back : public Backtrace_NT_Back_Base<std::pair<Rope, mfeanswer> , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_rightB_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, mfeanswer> , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_rightB(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_rightB_Front : public Backtrace_Score<std::pair<Rope, mfeanswer>  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_rightB_Back<hbmfepp, Value, pos_int> > back;

Backtrace_nt_rightB_Front(intrusive_ptr<Backtrace_nt_rightB_Back<hbmfepp, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, mfeanswer> , hbmfepp, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_iloop_Back : public Backtrace_NT_Back_Base<std::pair<Rope, mfeanswer> , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_iloop_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, mfeanswer> , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_iloop(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_iloop_Front : public Backtrace_Score<std::pair<Rope, mfeanswer>  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_iloop_Back<hbmfepp, Value, pos_int> > back;

Backtrace_nt_iloop_Front(intrusive_ptr<Backtrace_nt_iloop_Back<hbmfepp, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, mfeanswer> , hbmfepp, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_multiloop_Back : public Backtrace_NT_Back_Base<std::pair<Rope, mfeanswer> , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_multiloop_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, mfeanswer> , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_multiloop(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_multiloop_Front : public Backtrace_Score<std::pair<Rope, mfeanswer>  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_multiloop_Back<hbmfepp, Value, pos_int> > back;

Backtrace_nt_multiloop_Front(intrusive_ptr<Backtrace_nt_multiloop_Back<hbmfepp, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, mfeanswer> , hbmfepp, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_ml_comps_Back : public Backtrace_NT_Back_Base<std::pair<Rope, mfeanswer> , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_ml_comps_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, mfeanswer> , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_ml_comps(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_ml_comps_Front : public Backtrace_Score<std::pair<Rope, mfeanswer>  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_ml_comps_Back<hbmfepp, Value, pos_int> > back;

Backtrace_nt_ml_comps_Front(intrusive_ptr<Backtrace_nt_ml_comps_Back<hbmfepp, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, mfeanswer> , hbmfepp, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_ml_comps1_Back : public Backtrace_NT_Back_Base<std::pair<Rope, mfeanswer> , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_ml_comps1_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, mfeanswer> , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_ml_comps1(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_ml_comps1_Front : public Backtrace_Score<std::pair<Rope, mfeanswer>  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_ml_comps1_Back<hbmfepp, Value, pos_int> > back;

Backtrace_nt_ml_comps1_Front(intrusive_ptr<Backtrace_nt_ml_comps1_Back<hbmfepp, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, mfeanswer> , hbmfepp, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

    List_Ref<std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_struct(unsigned int t_0_i);
    List_Ref<std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_dangle(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_initstem(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_closed(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_stack(unsigned int t_0_i, unsigned int t_0_j);
    std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > >  bt_proxy_nt_hairpin(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_leftB(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_rightB(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_iloop(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_multiloop(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_ml_comps(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_ml_comps1(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_closed(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_dangle(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_hairpin(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_iloop(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_initstem(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_leftB(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_ml_comps(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_ml_comps1(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_multiloop(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_rightB(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_stack(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_struct(unsigned int t_0_i);

    intrusive_ptr<Backtrace<String, unsigned int> >  addss_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0, const TUSubsequence & param_1);
    intrusive_ptr<Backtrace<String, unsigned int> >  bl_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1);
    intrusive_ptr<Backtrace<String, unsigned int> >  br_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0, const TUSubsequence & param_1);
    intrusive_ptr<Backtrace<String, unsigned int> >  cadd_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1);
    intrusive_ptr<Backtrace<String, unsigned int> >  drem_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0);
    intrusive_ptr<Backtrace<String, unsigned int> >  edl_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1);
    intrusive_ptr<Backtrace<String, unsigned int> >  edlr_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1, const TUSubsequence & param_2);
    intrusive_ptr<Backtrace<String, unsigned int> >  edr_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0, const TUSubsequence & param_1);
    List_Ref<intrusive_ptr<Backtrace<String, unsigned int> > > h_bt_r(List_Ref<intrusive_ptr<Backtrace<String, unsigned int> > > param_0);
    intrusive_ptr<Backtrace<String, unsigned int> >  hl_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, const TUSubsequence & param_2, const TUSubsequence & param_3, const TUSubsequence & param_4);
    intrusive_ptr<Backtrace<String, unsigned int> >  il_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1, const TUSubsequence & param_2);
    intrusive_ptr<Backtrace<String, unsigned int> >  incl_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0);
    intrusive_ptr<Backtrace<String, unsigned int> >  is_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0);
    intrusive_ptr<Backtrace<String, unsigned int> >  ml_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<String, unsigned int> >  param_2, const TUSubsequence & param_3, const TUSubsequence & param_4);
    intrusive_ptr<Backtrace<String, unsigned int> >  mldl_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, const TUSubsequence & param_2, intrusive_ptr<Backtrace<String, unsigned int> >  param_3, const TUSubsequence & param_4, const TUSubsequence & param_5);
    intrusive_ptr<Backtrace<String, unsigned int> >  mldlr_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, const TUSubsequence & param_2, intrusive_ptr<Backtrace<String, unsigned int> >  param_3, const TUSubsequence & param_4, const TUSubsequence & param_5, const TUSubsequence & param_6);
    intrusive_ptr<Backtrace<String, unsigned int> >  mldr_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<String, unsigned int> >  param_2, const TUSubsequence & param_3, const TUSubsequence & param_4, const TUSubsequence & param_5);
    intrusive_ptr<Backtrace<String, unsigned int> >  nil_bt_r(const TUSubsequence & param_0);
    intrusive_ptr<Backtrace<String, unsigned int> >  sadd_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1);
    intrusive_ptr<Backtrace<String, unsigned int> >  sp_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<String, unsigned int> >  param_2, const TUSubsequence & param_3, const TUSubsequence & param_4);
    intrusive_ptr<Backtrace<String, unsigned int> >  sr_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1, const TUSubsequence & param_2);


    std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > >  addss_bt(const std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb);
    std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > >  bl_bt(const TUSubsequence & p_p_lregion, const std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e);
    std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > >  br_bt(const std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rregion);
    std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > >  cadd_bt(const std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_le, const std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_re);
    std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > >  drem_bt(const std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e);
    std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > >  edl_bt(const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e);
    std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > >  edlr_bt(const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb);
    std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > >  edr_bt(const std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb);
    List_Ref<std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > > > h_bt(List_Ref<std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > > > i, hbmfepp_hash_h &  left_answers);
template <typename Iterator>
    List_Ref<std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > > > h_bt(std::pair<Iterator, Iterator> i, hbmfepp_hash_h &  left_answers)
;
    List_Ref<std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > > > h_bt(List_Ref<std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > > > i);
template <typename Iterator>
    List_Ref<std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > > > h_bt(std::pair<Iterator, Iterator> i)
;
    std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > >  hl_bt(const TUSubsequence & p_p_llb, const TUSubsequence & p_p_lb, const TUSubsequence & p_p_region, const TUSubsequence & p_p_rb, const TUSubsequence & p_p_rrb);
    std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > >  il_bt(const TUSubsequence & p_p_lregion, const std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rregion);
    std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > >  incl_bt(const std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e);
    std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > >  is_bt(const std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e);
    std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > >  ml_bt(const TUSubsequence & p_p_llb, const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb, const TUSubsequence & p_p_rrb);
    std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > >  mldl_bt(const TUSubsequence & p_p_llb, const TUSubsequence & p_p_lb, const TUSubsequence & p_p_dl, const std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb, const TUSubsequence & p_p_rrb);
    std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > >  mldlr_bt(const TUSubsequence & p_p_llb, const TUSubsequence & p_p_lb, const TUSubsequence & p_p_dl, const std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_dr, const TUSubsequence & p_p_rb, const TUSubsequence & p_p_rrb);
    std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > >  mldr_bt(const TUSubsequence & p_p_llb, const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_dr, const TUSubsequence & p_p_rb, const TUSubsequence & p_p_rrb);
    std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > >  nil_bt(const TUSubsequence & p_p_loc);
    std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > >  sadd_bt(const TUSubsequence & p_p_b, const std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e);
    std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > >  sp_bt(const TUSubsequence & p_p_llb, const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb, const TUSubsequence & p_p_rrb);
    std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > >  sr_bt(const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb);

template <typename Value>   void  print_result(std::ostream &out, Value& res)

{
}
   intrusive_ptr<Backtrace<String, unsigned int> >  backtrack(unsigned int t_0_i)
{
List_Ref<std::pair<std::pair<Rope, mfeanswer> , intrusive_ptr<Backtrace<String, unsigned int> > > > bt  = bt_proxy_nt_struct(t_0_i);
return execute_backtrack_k(bt);
}
template <typename Value>   void  print_backtrack(std::ostream &out, Value& value)

{
intrusive_ptr<Backtrace<String, unsigned int> >  bt   = backtrack(t_0_left_most);
intrusive_ptr<Backtrace_List<String, unsigned int> > l =
  boost::dynamic_pointer_cast<Backtrace_List<String, unsigned int> >(bt);
assert(!bt || (bt && l));
if (l) {
for (Backtrace_List<String, unsigned int>::iterator i = l->begin();
     i != l->end(); ++i)
  (*i)->print(out);
}
}
   void  print_subopt(std::ostream &out, int  delta = 0) {}

};

#ifndef NO_GAPC_TYPEDEFS
namespace gapc {
  typedef hbmfepp hishapeb_pp_cls;
  typedef hbmfepp_hash_h &  hishapeb_pp_ret;
}
#endif

#endif

