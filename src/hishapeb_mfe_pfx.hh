
// A dynamic programming evaluator generated by GAP-C.
// 
//   GAP-C version:
//     bellmansgapc-2012.05.07
// 
//   GAP-C call:
//     /home/jhuang/gapc/bin/gapc hishapes.gap -i hishapeb_mfe_pfx -o hishapeb_mfe_pfx.cc -t --kbacktrack --kbest --no-coopt-class 
// 
// 


#ifndef hishapeb_mfe_pfx_hh
#define hishapeb_mfe_pfx_hh

#include "rtlib/adp.hh"

typedef Basic_Subsequence<char, unsigned> TUSubsequence;

#include <rtlib/subopt.hh>
#include "rna.hh"
#include "filter_add.hh"
#include "mfe_answer.hh"
#include "pf_answer.hh"
#include "pf_filter.hh"

#include <rtlib/generic_opts.hh>

class hishapeb_mfe_pfx_insp_hash_h_b_pfx {
public:
typedef std::pair<Rope, std::pair<mfeanswer, pfanswer> >  type;
private:
static uint32_t k_;
public:
uint32_t hash(const type &x) const
{
return hashable_value(left_most(x));
}
type init(const type &src) const
{
type dst(src);
{
  return src;
}
}
void update(type &dst, const type &src) 
{
  if ((src.second.first < dst.second.first))
    {
      dst.second.first = src.second.first;
    }

  dst.second.second += src.second.second;
}
bool equal(const type &a, const type &b) const
{
return left_most(a) == left_most(b);
}
bool filter() const { return false; }
bool filter(const type &x) const
{
assert(0); return false;
}
void finalize(type &src) const
{
}
static void set_k(uint32_t a) { k_ = a; }
uint32_t k() const
{
  return k_;
}
bool cutoff() const
{
  return true;
}
bool equal_score(const type &src, const type &dst) const
{
  return (src.second.first == dst.second.first);
}
struct compare {
bool operator()(const type &src, const type &dst) const
{
  return (src.second.first < dst.second.first);
}
};
};

typedef Hash::Ref<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , hishapeb_mfe_pfx_insp_hash_h_b_pfx > hishapeb_mfe_pfx_hash_h_b_pfx;


class hishapeb_mfe_pfx {

  public:
Basic_Sequence<char> t_0_seq;
unsigned int t_0_left_most;
unsigned int t_0_right_most;

hishapeb_mfe_pfx_hash_h_b_pfx LBRope_firstG_Bmfeanswer_firstG_pfanswer_secondG_E_secondG_EMhdecl0x1ed3270_zero;

class block_dl_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<hishapeb_mfe_pfx_hash_h_b_pfx > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
hishapeb_mfe_pfx_hash_h_b_pfx zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

block_dl_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 8))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
hishapeb_mfe_pfx_hash_h_b_pfx &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 8))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j,  const hishapeb_mfe_pfx_hash_h_b_pfx &  e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 8))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
block_dl_table_t block_dl_table;


class block_dlr_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<hishapeb_mfe_pfx_hash_h_b_pfx > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
hishapeb_mfe_pfx_hash_h_b_pfx zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

block_dlr_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 9))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
hishapeb_mfe_pfx_hash_h_b_pfx &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 9))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j,  const hishapeb_mfe_pfx_hash_h_b_pfx &  e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 9))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
block_dlr_table_t block_dlr_table;


class closed_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<hishapeb_mfe_pfx_hash_h_b_pfx > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
hishapeb_mfe_pfx_hash_h_b_pfx zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

closed_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 7))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
hishapeb_mfe_pfx_hash_h_b_pfx &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 7))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j,  const hishapeb_mfe_pfx_hash_h_b_pfx &  e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 7))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
closed_table_t closed_table;


class dl_or_ss_left_ss_end_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<hishapeb_mfe_pfx_hash_h_b_pfx > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
hishapeb_mfe_pfx_hash_h_b_pfx zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

dl_or_ss_left_ss_end_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 9))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
hishapeb_mfe_pfx_hash_h_b_pfx &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 9))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j,  const hishapeb_mfe_pfx_hash_h_b_pfx &  e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 9))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
dl_or_ss_left_ss_end_table_t dl_or_ss_left_ss_end_table;


class edangler_ml_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<hishapeb_mfe_pfx_hash_h_b_pfx > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
hishapeb_mfe_pfx_hash_h_b_pfx zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

edangler_ml_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 8))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
hishapeb_mfe_pfx_hash_h_b_pfx &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 8))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j,  const hishapeb_mfe_pfx_hash_h_b_pfx &  e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 8))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
edangler_ml_table_t edangler_ml_table;


class left_dangle_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<hishapeb_mfe_pfx_hash_h_b_pfx > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
hishapeb_mfe_pfx_hash_h_b_pfx zero;
unsigned int size()
{
  return (1 * ((t_0_n + 1) * 1));
}


public:

left_dangle_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i)
{
  unsigned int t_0_j = t_0_n;
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if ((t_0_j < (t_0_n - 0)))
    {
      return true;
    }

  unsigned int t_0_real_j = (t_0_n - t_0_j);
  return tabulated[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))];
}


void clear() { tabulated.clear(); }
hishapeb_mfe_pfx_hash_h_b_pfx &  get(unsigned int t_0_i)
{
  unsigned int t_0_j = t_0_n;
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if ((t_0_j < (t_0_n - 0)))
    {
      return zero;
    }

  unsigned int t_0_real_j = (t_0_n - t_0_j);
  assert( tabulated[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))]);
  assert( ((0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1))))) < size()));
  return array[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))];
}


void set(unsigned int t_0_i,  const hishapeb_mfe_pfx_hash_h_b_pfx &  e)
{
  unsigned int t_0_j = t_0_n;
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if ((t_0_j < (t_0_n - 0)))
    {
      return;
    }

  unsigned int t_0_real_j = (t_0_n - t_0_j);
  assert( !is_tabulated(t_0_i));
  assert( ((0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1))))) < size()));
  array[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))] = e;
  tabulated[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))] = true;
}


};
left_dangle_table_t left_dangle_table;


class left_unpaired_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<hishapeb_mfe_pfx_hash_h_b_pfx > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
hishapeb_mfe_pfx_hash_h_b_pfx zero;
unsigned int size()
{
  return (1 * ((t_0_n + 1) * 1));
}


public:

left_unpaired_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i)
{
  if (((t_0_right_most - t_0_i) < 1))
    {
      return true;
    }

  unsigned int t_0_j = t_0_n;
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if ((t_0_j < (t_0_n - 0)))
    {
      return true;
    }

  unsigned int t_0_real_j = (t_0_n - t_0_j);
  return tabulated[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))];
}


void clear() { tabulated.clear(); }
hishapeb_mfe_pfx_hash_h_b_pfx &  get(unsigned int t_0_i)
{
  unsigned int t_0_j = t_0_n;
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if ((t_0_j < (t_0_n - 0)))
    {
      return zero;
    }

  unsigned int t_0_real_j = (t_0_n - t_0_j);
  if (((t_0_right_most - t_0_i) < 1))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))]);
  assert( ((0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1))))) < size()));
  return array[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))];
}


void set(unsigned int t_0_i,  const hishapeb_mfe_pfx_hash_h_b_pfx &  e)
{
  unsigned int t_0_j = t_0_n;
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if ((t_0_j < (t_0_n - 0)))
    {
      return;
    }

  unsigned int t_0_real_j = (t_0_n - t_0_j);
  if (((t_0_right_most - t_0_i) < 1))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i));
  assert( ((0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1))))) < size()));
  array[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))] = e;
  tabulated[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))] = true;
}


};
left_unpaired_table_t left_unpaired_table;


class ml_comps1_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<hishapeb_mfe_pfx_hash_h_b_pfx > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
hishapeb_mfe_pfx_hash_h_b_pfx zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

ml_comps1_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 15))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
hishapeb_mfe_pfx_hash_h_b_pfx &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 15))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j,  const hishapeb_mfe_pfx_hash_h_b_pfx &  e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 15))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
ml_comps1_table_t ml_comps1_table;


class ml_comps2_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<hishapeb_mfe_pfx_hash_h_b_pfx > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
hishapeb_mfe_pfx_hash_h_b_pfx zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

ml_comps2_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 14))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
hishapeb_mfe_pfx_hash_h_b_pfx &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 14))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j,  const hishapeb_mfe_pfx_hash_h_b_pfx &  e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 14))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
ml_comps2_table_t ml_comps2_table;


class ml_comps3_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<hishapeb_mfe_pfx_hash_h_b_pfx > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
hishapeb_mfe_pfx_hash_h_b_pfx zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

ml_comps3_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 15))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
hishapeb_mfe_pfx_hash_h_b_pfx &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 15))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j,  const hishapeb_mfe_pfx_hash_h_b_pfx &  e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 15))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
ml_comps3_table_t ml_comps3_table;


class ml_comps4_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<hishapeb_mfe_pfx_hash_h_b_pfx > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
hishapeb_mfe_pfx_hash_h_b_pfx zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

ml_comps4_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 16))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
hishapeb_mfe_pfx_hash_h_b_pfx &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 16))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j,  const hishapeb_mfe_pfx_hash_h_b_pfx &  e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 16))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
ml_comps4_table_t ml_comps4_table;


class no_dl_no_ss_end_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<hishapeb_mfe_pfx_hash_h_b_pfx > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
hishapeb_mfe_pfx_hash_h_b_pfx zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

no_dl_no_ss_end_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 7))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
hishapeb_mfe_pfx_hash_h_b_pfx &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 7))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j,  const hishapeb_mfe_pfx_hash_h_b_pfx &  e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 7))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
no_dl_no_ss_end_table_t no_dl_no_ss_end_table;


class no_dl_ss_end_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<hishapeb_mfe_pfx_hash_h_b_pfx > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
hishapeb_mfe_pfx_hash_h_b_pfx zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

no_dl_ss_end_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 8))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
hishapeb_mfe_pfx_hash_h_b_pfx &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 8))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j,  const hishapeb_mfe_pfx_hash_h_b_pfx &  e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 8))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
no_dl_ss_end_table_t no_dl_ss_end_table;


class nodangle_ml_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<hishapeb_mfe_pfx_hash_h_b_pfx > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
hishapeb_mfe_pfx_hash_h_b_pfx zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

nodangle_ml_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 7))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
hishapeb_mfe_pfx_hash_h_b_pfx &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 7))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j,  const hishapeb_mfe_pfx_hash_h_b_pfx &  e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 7))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
nodangle_ml_table_t nodangle_ml_table;


class noleft_dangle_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<hishapeb_mfe_pfx_hash_h_b_pfx > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
hishapeb_mfe_pfx_hash_h_b_pfx zero;
unsigned int size()
{
  return (1 * ((t_0_n + 1) * 1));
}


public:

noleft_dangle_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i)
{
  if (((t_0_right_most - t_0_i) < 7))
    {
      return true;
    }

  unsigned int t_0_j = t_0_n;
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if ((t_0_j < (t_0_n - 0)))
    {
      return true;
    }

  unsigned int t_0_real_j = (t_0_n - t_0_j);
  return tabulated[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))];
}


void clear() { tabulated.clear(); }
hishapeb_mfe_pfx_hash_h_b_pfx &  get(unsigned int t_0_i)
{
  unsigned int t_0_j = t_0_n;
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if ((t_0_j < (t_0_n - 0)))
    {
      return zero;
    }

  unsigned int t_0_real_j = (t_0_n - t_0_j);
  if (((t_0_right_most - t_0_i) < 7))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))]);
  assert( ((0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1))))) < size()));
  return array[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))];
}


void set(unsigned int t_0_i,  const hishapeb_mfe_pfx_hash_h_b_pfx &  e)
{
  unsigned int t_0_j = t_0_n;
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if ((t_0_j < (t_0_n - 0)))
    {
      return;
    }

  unsigned int t_0_real_j = (t_0_n - t_0_j);
  if (((t_0_right_most - t_0_i) < 7))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i));
  assert( ((0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1))))) < size()));
  array[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))] = e;
  tabulated[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))] = true;
}


};
noleft_dangle_table_t noleft_dangle_table;



//void init(const gapc::Opts &opts)
void init(const std::vector<std::pair<const char *, unsigned> > &inp, uint32_t kbest, const std::string &matchStr, const bool exact, const float theta=0.0f)
{
//const std::vector<std::pair<const char *, unsigned> > &inp = opts.inputs;
if(inp.size() != 1)
  throw gapc::OptException("Number of input sequences does not match.");

  t_0_seq.copy(inp[0].first, inp[0].second);
char_to_rna(t_0_seq);
  block_dl_table.init( t_0_seq.size(), "block_dl_table");
  block_dlr_table.init( t_0_seq.size(), "block_dlr_table");
  closed_table.init( t_0_seq.size(), "closed_table");
  dl_or_ss_left_ss_end_table.init( t_0_seq.size(), "dl_or_ss_left_ss_end_table");
  edangler_ml_table.init( t_0_seq.size(), "edangler_ml_table");
  left_dangle_table.init( t_0_seq.size(), "left_dangle_table");
  left_unpaired_table.init( t_0_seq.size(), "left_unpaired_table");
  ml_comps1_table.init( t_0_seq.size(), "ml_comps1_table");
  ml_comps2_table.init( t_0_seq.size(), "ml_comps2_table");
  ml_comps3_table.init( t_0_seq.size(), "ml_comps3_table");
  ml_comps4_table.init( t_0_seq.size(), "ml_comps4_table");
  no_dl_no_ss_end_table.init( t_0_seq.size(), "no_dl_no_ss_end_table");
  no_dl_ss_end_table.init( t_0_seq.size(), "no_dl_ss_end_table");
  nodangle_ml_table.init( t_0_seq.size(), "nodangle_ml_table");
  noleft_dangle_table.init( t_0_seq.size(), "noleft_dangle_table");
empty(LBRope_firstG_Bmfeanswer_firstG_pfanswer_secondG_E_secondG_EMhdecl0x1ed3270_zero);

t_0_left_most = 0;
t_0_right_most = t_0_seq.size();
hishapeb_mfe_pfx_insp_hash_h_b_pfx::set_k(kbest);
    std::vector<std::string> tokens;      
    const std::string delimiters = ",";   
    // Skip delimiters at beginning.
    std::string::size_type lastPos = matchStr.find_first_not_of(delimiters, 0);
    // Find first "non-delimiter".
    std::string::size_type pos     = matchStr.find_first_of(delimiters, lastPos);
    while (std::string::npos != pos || std::string::npos != lastPos)
    {
        // Found a token, add it to the vector.
        tokens.push_back(matchStr.substr(lastPos, pos - lastPos));
        // Skip delimiters.  Note the "not_of"
        lastPos = matchStr.find_first_not_of(delimiters, pos);
        // Find next "non-delimiter"
        pos = matchStr.find_first_of(delimiters, lastPos);
    }


    std::vector<std::string>::iterator it;
    for ( it=tokens.begin() ; it < tokens.end(); it++ ) {
      std::string tmp = *it;
      if (tmp[tmp.length()-1] == 'm') {
        tmp.erase(tmp.length()-1);
        _match_tokens_m.push_back(tmp);
      } else if (tmp[tmp.length()-1] == 'i') {
        tmp.erase(tmp.length()-1);
        _match_tokens_i.push_back(tmp);
      } else if (tmp[tmp.length()-1] == 'b') {
        tmp.erase(tmp.length()-1);
        _match_tokens_b.push_back(tmp);
      } else {
        _match_tokens_h.push_back(tmp);
      }
    }
    _exact = exact;
    _theta = theta;
}

  private:
    std::vector<std::string> _match_tokens_h, _match_tokens_m, _match_tokens_i, _match_tokens_b;
    bool _exact; 
    float _theta;
    
    
    hishapeb_mfe_pfx_hash_h_b_pfx &  nt_block_dl(unsigned int t_0_i, unsigned int t_0_j);
    hishapeb_mfe_pfx_hash_h_b_pfx &  nt_block_dlr(unsigned int t_0_i, unsigned int t_0_j);
    hishapeb_mfe_pfx_hash_h_b_pfx &  nt_closed(unsigned int t_0_i, unsigned int t_0_j);
    hishapeb_mfe_pfx_hash_h_b_pfx nt_dl_or_ss_left_no_ss_end(unsigned int t_0_i, unsigned int t_0_j);
    hishapeb_mfe_pfx_hash_h_b_pfx &  nt_dl_or_ss_left_ss_end(unsigned int t_0_i, unsigned int t_0_j);
    hishapeb_mfe_pfx_hash_h_b_pfx nt_edanglel_ml(unsigned int t_0_i, unsigned int t_0_j);
    hishapeb_mfe_pfx_hash_h_b_pfx nt_edanglel_struct(unsigned int t_0_i, unsigned int t_0_j);
    hishapeb_mfe_pfx_hash_h_b_pfx nt_edanglelr_ml(unsigned int t_0_i, unsigned int t_0_j);
    hishapeb_mfe_pfx_hash_h_b_pfx nt_edanglelr_struct(unsigned int t_0_i, unsigned int t_0_j);
    hishapeb_mfe_pfx_hash_h_b_pfx &  nt_edangler_ml(unsigned int t_0_i, unsigned int t_0_j);
    hishapeb_mfe_pfx_hash_h_b_pfx nt_edangler_struct(unsigned int t_0_i, unsigned int t_0_j);
    hishapeb_mfe_pfx_hash_h_b_pfx nt_hairpin(unsigned int t_0_i, unsigned int t_0_j);
    hishapeb_mfe_pfx_hash_h_b_pfx nt_iloop(unsigned int t_0_i, unsigned int t_0_j);
    hishapeb_mfe_pfx_hash_h_b_pfx nt_initstem(unsigned int t_0_i, unsigned int t_0_j);
    hishapeb_mfe_pfx_hash_h_b_pfx nt_leftB(unsigned int t_0_i, unsigned int t_0_j);
    hishapeb_mfe_pfx_hash_h_b_pfx &  nt_left_dangle(unsigned int t_0_i);
    hishapeb_mfe_pfx_hash_h_b_pfx &  nt_left_unpaired(unsigned int t_0_i);
    hishapeb_mfe_pfx_hash_h_b_pfx &  nt_ml_comps1(unsigned int t_0_i, unsigned int t_0_j);
    hishapeb_mfe_pfx_hash_h_b_pfx &  nt_ml_comps2(unsigned int t_0_i, unsigned int t_0_j);
    hishapeb_mfe_pfx_hash_h_b_pfx &  nt_ml_comps3(unsigned int t_0_i, unsigned int t_0_j);
    hishapeb_mfe_pfx_hash_h_b_pfx &  nt_ml_comps4(unsigned int t_0_i, unsigned int t_0_j);
    hishapeb_mfe_pfx_hash_h_b_pfx nt_multiloop(unsigned int t_0_i, unsigned int t_0_j);
    hishapeb_mfe_pfx_hash_h_b_pfx &  nt_no_dl_no_ss_end(unsigned int t_0_i, unsigned int t_0_j);
    hishapeb_mfe_pfx_hash_h_b_pfx &  nt_no_dl_ss_end(unsigned int t_0_i, unsigned int t_0_j);
    hishapeb_mfe_pfx_hash_h_b_pfx &  nt_nodangle_ml(unsigned int t_0_i, unsigned int t_0_j);
    hishapeb_mfe_pfx_hash_h_b_pfx nt_nodangle_struct(unsigned int t_0_i, unsigned int t_0_j);
    hishapeb_mfe_pfx_hash_h_b_pfx &  nt_noleft_dangle(unsigned int t_0_i);
    hishapeb_mfe_pfx_hash_h_b_pfx nt_rightB(unsigned int t_0_i, unsigned int t_0_j);
    hishapeb_mfe_pfx_hash_h_b_pfx nt_stack(unsigned int t_0_i, unsigned int t_0_j);
    hishapeb_mfe_pfx_hash_h_b_pfx nt_struct();

    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  acomb(const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_le, const TUSubsequence & p_b, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_re);
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  addss(const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e, const TUSubsequence & p_rb);
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ambd(const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_le, const TUSubsequence & p_b, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_re);
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ambd_Pr(const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_le, const TUSubsequence & p_b, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_re);
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  bl(const TUSubsequence & p_lregion, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e);
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  br(const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e, const TUSubsequence & p_rregion);
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  cadd(const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_le, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_re);
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  cadd_Pr(const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_le, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_re);
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  cadd_Pr_Pr(const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_le, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_re);
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  cadd_Pr_Pr_Pr(const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_le, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_re);
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  combine(const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_le, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_re);
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  drem(const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e);
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  edl(const TUSubsequence & p_lb, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e);
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  edlr(const TUSubsequence & p_lb, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e, const TUSubsequence & p_rb);
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  edr(const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e, const TUSubsequence & p_rb);
template <typename Iterator>
    hishapeb_mfe_pfx_hash_h_b_pfx h(std::pair<Iterator, Iterator> i)
;
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  hl(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const TUSubsequence & p_region, const TUSubsequence & p_rb, const TUSubsequence & p_rrb);
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  il(const TUSubsequence & p_lregion, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e, const TUSubsequence & p_rregion);
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  incl(const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e);
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  is(const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e);
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ml(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e, const TUSubsequence & p_rb, const TUSubsequence & p_rrb);
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  mladl(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e, const TUSubsequence & p_rb, const TUSubsequence & p_rrb);
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  mladldr(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb, const TUSubsequence & p_rrb);
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  mladlr(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb, const TUSubsequence & p_rrb);
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  mladr(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb, const TUSubsequence & p_rrb);
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  mldl(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e, const TUSubsequence & p_rb, const TUSubsequence & p_rrb);
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  mldladr(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb, const TUSubsequence & p_rrb);
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  mldlr(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb, const TUSubsequence & p_rrb);
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  mldr(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb, const TUSubsequence & p_rrb);
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  nil(const TUSubsequence & p_loc);
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  nil_Pr(const TUSubsequence & p_loc);
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  sadd(const TUSubsequence & p_b, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e);
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  sp(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e, const TUSubsequence & p_rb, const TUSubsequence & p_rrb);
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  sr(const TUSubsequence & p_lb, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e, const TUSubsequence & p_rb);
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ssadd(const TUSubsequence & p_lb, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e);
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  trafo(const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e);


    Rope acomb_l(const Rope & le, const TUSubsequence & b, const Rope & re);
    Rope addss_l(const Rope & e, const TUSubsequence & rb);
    Rope ambd_l(const Rope & le, const TUSubsequence & b, const Rope & re);
    Rope ambd_Pr_l(const Rope & le, const TUSubsequence & b, const Rope & re);
    Rope bl_l(const TUSubsequence & lregion, const Rope & e);
    Rope br_l(const Rope & e, const TUSubsequence & rregion);
    Rope cadd_l(const Rope & le, const Rope & re);
    Rope cadd_Pr_l(const Rope & le, const Rope & re);
    Rope cadd_Pr_Pr_l(const Rope & le, const Rope & re);
    Rope cadd_Pr_Pr_Pr_l(const Rope & le, const Rope & re);
    Rope combine_l(const Rope & le, const Rope & re);
    Rope drem_l(const Rope & e);
    Rope edl_l(const TUSubsequence & lb, const Rope & e);
    Rope edlr_l(const TUSubsequence & lb, const Rope & e, const TUSubsequence & rb);
    Rope edr_l(const Rope & e, const TUSubsequence & rb);
    Rope hl_l(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & region, const TUSubsequence & rb, const TUSubsequence & rrb);
    Rope il_l(const TUSubsequence & lregion, const Rope & e, const TUSubsequence & rregion);
    Rope incl_l(const Rope & e);
    Rope is_l(const Rope & e);
    Rope ml_l(const TUSubsequence & llb, const TUSubsequence & lb, const Rope & e, const TUSubsequence & rb, const TUSubsequence & rrb);
    Rope mladl_l(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const Rope & e, const TUSubsequence & rb, const TUSubsequence & rrb);
    Rope mladldr_l(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const Rope & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb);
    Rope mladlr_l(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const Rope & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb);
    Rope mladr_l(const TUSubsequence & llb, const TUSubsequence & lb, const Rope & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb);
    Rope mldl_l(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const Rope & e, const TUSubsequence & rb, const TUSubsequence & rrb);
    Rope mldladr_l(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const Rope & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb);
    Rope mldlr_l(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const Rope & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb);
    Rope mldr_l(const TUSubsequence & llb, const TUSubsequence & lb, const Rope & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb);
    Rope nil_l(const TUSubsequence & loc);
    Rope nil_Pr_l(const TUSubsequence & loc);
    Rope sadd_l(const TUSubsequence & b, const Rope & e);
    Rope sp_l(const TUSubsequence & llb, const TUSubsequence & lb, const Rope & e, const TUSubsequence & rb, const TUSubsequence & rrb);
    Rope sr_l(const TUSubsequence & lb, const Rope & e, const TUSubsequence & rb);
    Rope ssadd_l(const TUSubsequence & lb, const Rope & e);
    Rope trafo_l(const Rope & e);


    std::pair<mfeanswer, pfanswer>  acomb_r(const std::pair<mfeanswer, pfanswer> & p_le, const TUSubsequence & p_b, const std::pair<mfeanswer, pfanswer> & p_re);
    std::pair<mfeanswer, pfanswer>  addss_r(const std::pair<mfeanswer, pfanswer> & p_e, const TUSubsequence & p_rb);
    std::pair<mfeanswer, pfanswer>  ambd_r(const std::pair<mfeanswer, pfanswer> & p_le, const TUSubsequence & p_b, const std::pair<mfeanswer, pfanswer> & p_re);
    std::pair<mfeanswer, pfanswer>  ambd_Pr_r(const std::pair<mfeanswer, pfanswer> & p_le, const TUSubsequence & p_b, const std::pair<mfeanswer, pfanswer> & p_re);
    std::pair<mfeanswer, pfanswer>  bl_r(const TUSubsequence & p_lregion, const std::pair<mfeanswer, pfanswer> & p_e);
    std::pair<mfeanswer, pfanswer>  br_r(const std::pair<mfeanswer, pfanswer> & p_e, const TUSubsequence & p_rregion);
    std::pair<mfeanswer, pfanswer>  cadd_r(const std::pair<mfeanswer, pfanswer> & p_le, const std::pair<mfeanswer, pfanswer> & p_re);
    std::pair<mfeanswer, pfanswer>  cadd_Pr_r(const std::pair<mfeanswer, pfanswer> & p_le, const std::pair<mfeanswer, pfanswer> & p_re);
    std::pair<mfeanswer, pfanswer>  cadd_Pr_Pr_r(const std::pair<mfeanswer, pfanswer> & p_le, const std::pair<mfeanswer, pfanswer> & p_re);
    std::pair<mfeanswer, pfanswer>  cadd_Pr_Pr_Pr_r(const std::pair<mfeanswer, pfanswer> & p_le, const std::pair<mfeanswer, pfanswer> & p_re);
    std::pair<mfeanswer, pfanswer>  combine_r(const std::pair<mfeanswer, pfanswer> & p_le, const std::pair<mfeanswer, pfanswer> & p_re);
    std::pair<mfeanswer, pfanswer>  drem_r(const std::pair<mfeanswer, pfanswer> & p_e);
    std::pair<mfeanswer, pfanswer>  edl_r(const TUSubsequence & p_lb, const std::pair<mfeanswer, pfanswer> & p_e);
    std::pair<mfeanswer, pfanswer>  edlr_r(const TUSubsequence & p_lb, const std::pair<mfeanswer, pfanswer> & p_e, const TUSubsequence & p_rb);
    std::pair<mfeanswer, pfanswer>  edr_r(const std::pair<mfeanswer, pfanswer> & p_e, const TUSubsequence & p_rb);
    std::pair<mfeanswer, pfanswer>  hl_r(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const TUSubsequence & p_region, const TUSubsequence & p_rb, const TUSubsequence & p_rrb);
    std::pair<mfeanswer, pfanswer>  il_r(const TUSubsequence & p_lregion, const std::pair<mfeanswer, pfanswer> & p_e, const TUSubsequence & p_rregion);
    std::pair<mfeanswer, pfanswer>  incl_r(const std::pair<mfeanswer, pfanswer> & p_e);
    std::pair<mfeanswer, pfanswer>  is_r(const std::pair<mfeanswer, pfanswer> & p_e);
    std::pair<mfeanswer, pfanswer>  ml_r(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const std::pair<mfeanswer, pfanswer> & p_e, const TUSubsequence & p_rb, const TUSubsequence & p_rrb);
    std::pair<mfeanswer, pfanswer>  mladl_r(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<mfeanswer, pfanswer> & p_e, const TUSubsequence & p_rb, const TUSubsequence & p_rrb);
    std::pair<mfeanswer, pfanswer>  mladldr_r(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<mfeanswer, pfanswer> & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb, const TUSubsequence & p_rrb);
    std::pair<mfeanswer, pfanswer>  mladlr_r(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<mfeanswer, pfanswer> & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb, const TUSubsequence & p_rrb);
    std::pair<mfeanswer, pfanswer>  mladr_r(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const std::pair<mfeanswer, pfanswer> & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb, const TUSubsequence & p_rrb);
    std::pair<mfeanswer, pfanswer>  mldl_r(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<mfeanswer, pfanswer> & p_e, const TUSubsequence & p_rb, const TUSubsequence & p_rrb);
    std::pair<mfeanswer, pfanswer>  mldladr_r(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<mfeanswer, pfanswer> & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb, const TUSubsequence & p_rrb);
    std::pair<mfeanswer, pfanswer>  mldlr_r(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<mfeanswer, pfanswer> & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb, const TUSubsequence & p_rrb);
    std::pair<mfeanswer, pfanswer>  mldr_r(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const std::pair<mfeanswer, pfanswer> & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb, const TUSubsequence & p_rrb);
    std::pair<mfeanswer, pfanswer>  nil_r(const TUSubsequence & p_loc);
    std::pair<mfeanswer, pfanswer>  nil_Pr_r(const TUSubsequence & p_loc);
    std::pair<mfeanswer, pfanswer>  sadd_r(const TUSubsequence & p_lb, const std::pair<mfeanswer, pfanswer> & p_e);
    std::pair<mfeanswer, pfanswer>  sp_r(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const std::pair<mfeanswer, pfanswer> & p_e, const TUSubsequence & p_rb, const TUSubsequence & p_rrb);
    std::pair<mfeanswer, pfanswer>  sr_r(const TUSubsequence & p_lb, const std::pair<mfeanswer, pfanswer> & p_e, const TUSubsequence & p_rb);
    std::pair<mfeanswer, pfanswer>  ssadd_r(const TUSubsequence & p_lb, const std::pair<mfeanswer, pfanswer> & p_e);
    std::pair<mfeanswer, pfanswer>  trafo_r(const std::pair<mfeanswer, pfanswer> & p_e);


    mfeanswer acomb_r_l(const mfeanswer & le, const TUSubsequence & b, const mfeanswer & re);
    mfeanswer addss_r_l(const mfeanswer & e, const TUSubsequence & rb);
    mfeanswer ambd_r_l(const mfeanswer & le, const TUSubsequence & b, const mfeanswer & re);
    mfeanswer ambd_Pr_r_l(const mfeanswer & le, const TUSubsequence & b, const mfeanswer & re);
    mfeanswer bl_r_l(const TUSubsequence & lregion, const mfeanswer & e);
    mfeanswer br_r_l(const mfeanswer & e, const TUSubsequence & rregion);
    mfeanswer cadd_r_l(const mfeanswer & le, const mfeanswer & re);
    mfeanswer cadd_Pr_r_l(const mfeanswer & le, const mfeanswer & re);
    mfeanswer cadd_Pr_Pr_r_l(const mfeanswer & le, const mfeanswer & re);
    mfeanswer cadd_Pr_Pr_Pr_r_l(const mfeanswer & le, const mfeanswer & re);
    mfeanswer combine_r_l(const mfeanswer & le, const mfeanswer & re);
    mfeanswer drem_r_l(const mfeanswer & e);
    mfeanswer edl_r_l(const TUSubsequence & lb, const mfeanswer & e);
    mfeanswer edlr_r_l(const TUSubsequence & lb, const mfeanswer & e, const TUSubsequence & rb);
    mfeanswer edr_r_l(const mfeanswer & e, const TUSubsequence & rb);
    mfeanswer hl_r_l(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & region, const TUSubsequence & rb, const TUSubsequence & rrb);
    mfeanswer il_r_l(const TUSubsequence & lregion, const mfeanswer & e, const TUSubsequence & rregion);
    mfeanswer incl_r_l(const mfeanswer & e);
    mfeanswer is_r_l(const mfeanswer & e);
    mfeanswer ml_r_l(const TUSubsequence & llb, const TUSubsequence & lb, const mfeanswer & e, const TUSubsequence & rb, const TUSubsequence & rrb);
    mfeanswer mladl_r_l(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const mfeanswer & e, const TUSubsequence & rb, const TUSubsequence & rrb);
    mfeanswer mladldr_r_l(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const mfeanswer & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb);
    mfeanswer mladlr_r_l(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const mfeanswer & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb);
    mfeanswer mladr_r_l(const TUSubsequence & llb, const TUSubsequence & lb, const mfeanswer & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb);
    mfeanswer mldl_r_l(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const mfeanswer & e, const TUSubsequence & rb, const TUSubsequence & rrb);
    mfeanswer mldladr_r_l(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const mfeanswer & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb);
    mfeanswer mldlr_r_l(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const mfeanswer & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb);
    mfeanswer mldr_r_l(const TUSubsequence & llb, const TUSubsequence & lb, const mfeanswer & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb);
    mfeanswer nil_r_l(const TUSubsequence & loc);
    mfeanswer nil_Pr_r_l(const TUSubsequence & loc);
    mfeanswer sadd_r_l(const TUSubsequence & lb, const mfeanswer & e);
    mfeanswer sp_r_l(const TUSubsequence & llb, const TUSubsequence & lb, const mfeanswer & e, const TUSubsequence & rb, const TUSubsequence & rrb);
    mfeanswer sr_r_l(const TUSubsequence & lb, const mfeanswer & e, const TUSubsequence & rb);
    mfeanswer ssadd_r_l(const TUSubsequence & lb, const mfeanswer & e);
    mfeanswer trafo_r_l(const mfeanswer & e);


    pfanswer acomb_r_r(const pfanswer & le, const TUSubsequence & b, const pfanswer & re);
    pfanswer addss_r_r(const pfanswer & e, const TUSubsequence & rregion);
    pfanswer ambd_r_r(const pfanswer & le, const TUSubsequence & b, const pfanswer & re);
    pfanswer ambd_Pr_r_r(const pfanswer & le, const TUSubsequence & b, const pfanswer & re);
    pfanswer bl_r_r(const TUSubsequence & lregion, const pfanswer & e);
    pfanswer br_r_r(const pfanswer & e, const TUSubsequence & rregion);
    pfanswer cadd_r_r(const pfanswer & le, const pfanswer & re);
    pfanswer cadd_Pr_r_r(const pfanswer & le, const pfanswer & re);
    pfanswer cadd_Pr_Pr_r_r(const pfanswer & le, const pfanswer & re);
    pfanswer cadd_Pr_Pr_Pr_r_r(const pfanswer & le, const pfanswer & re);
    pfanswer combine_r_r(const pfanswer & le, const pfanswer & re);
    pfanswer drem_r_r(const pfanswer & e);
    pfanswer edl_r_r(const TUSubsequence & lb, const pfanswer & e);
    pfanswer edlr_r_r(const TUSubsequence & lb, const pfanswer & e, const TUSubsequence & rb);
    pfanswer edr_r_r(const pfanswer & e, const TUSubsequence & rb);
    pfanswer hl_r_r(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & region, const TUSubsequence & rb, const TUSubsequence & rrb);
    pfanswer il_r_r(const TUSubsequence & lregion, const pfanswer & e, const TUSubsequence & rregion);
    pfanswer incl_r_r(const pfanswer & e);
    pfanswer is_r_r(const pfanswer & e);
    pfanswer ml_r_r(const TUSubsequence & llb, const TUSubsequence & lb, const pfanswer & e, const TUSubsequence & rb, const TUSubsequence & rrb);
    pfanswer mladl_r_r(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const pfanswer & e, const TUSubsequence & rb, const TUSubsequence & rrb);
    pfanswer mladldr_r_r(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const pfanswer & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb);
    pfanswer mladlr_r_r(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const pfanswer & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb);
    pfanswer mladr_r_r(const TUSubsequence & llb, const TUSubsequence & lb, const pfanswer & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb);
    pfanswer mldl_r_r(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const pfanswer & e, const TUSubsequence & rb, const TUSubsequence & rrb);
    pfanswer mldladr_r_r(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const pfanswer & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb);
    pfanswer mldlr_r_r(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const pfanswer & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb);
    pfanswer mldr_r_r(const TUSubsequence & llb, const TUSubsequence & lb, const pfanswer & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb);
    pfanswer nil_r_r(const TUSubsequence & loc);
    pfanswer nil_Pr_r_r(const TUSubsequence & loc);
    pfanswer sadd_r_r(const TUSubsequence & lb, const pfanswer & e);
    pfanswer sp_r_r(const TUSubsequence & llb, const TUSubsequence & lb, const pfanswer & e, const TUSubsequence & rb, const TUSubsequence & rrb);
    pfanswer sr_r_r(const TUSubsequence & lb, const pfanswer & e, const TUSubsequence & rb);
    pfanswer ssadd_r_r(const TUSubsequence & lregion, const pfanswer & e);
    pfanswer trafo_r_r(const pfanswer & e);


 public:
   void cyk();

 public:
   hishapeb_mfe_pfx_hash_h_b_pfx run()
{
  return nt_struct();
}
void print_stats(std::ostream &o)
{
#ifdef STATS
      o << "\n\nN = " << seq.size() << '\n';
      block_dl_table.print_stats(o, "block_dl_table");
      block_dlr_table.print_stats(o, "block_dlr_table");
      closed_table.print_stats(o, "closed_table");
      dl_or_ss_left_ss_end_table.print_stats(o, "dl_or_ss_left_ss_end_table");
      edangler_ml_table.print_stats(o, "edangler_ml_table");
      left_dangle_table.print_stats(o, "left_dangle_table");
      left_unpaired_table.print_stats(o, "left_unpaired_table");
      ml_comps1_table.print_stats(o, "ml_comps1_table");
      ml_comps2_table.print_stats(o, "ml_comps2_table");
      ml_comps3_table.print_stats(o, "ml_comps3_table");
      ml_comps4_table.print_stats(o, "ml_comps4_table");
      no_dl_no_ss_end_table.print_stats(o, "no_dl_no_ss_end_table");
      no_dl_ss_end_table.print_stats(o, "no_dl_ss_end_table");
      nodangle_ml_table.print_stats(o, "nodangle_ml_table");
      noleft_dangle_table.print_stats(o, "noleft_dangle_table");
#endif
}

template <typename Value, typename pos_int>
struct Backtrace_acomb : Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_le;
      TUSubsequence arg_b;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_re;

Backtrace_acomb(intrusive_ptr<Backtrace<Value, pos_int> >  arg_le_, TUSubsequence arg_b_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_)
 : arg_le(arg_le_), arg_b(arg_b_), arg_re(arg_re_)
{}

~Backtrace_acomb()
{
erase(arg_le);
erase(arg_re);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String acomb(const String & le, const TUSubsequence & b, const String & re)
      {
#line 2664 ""
        String res;
        append( res, le);
        append( res, '.');
        append( res, re);
        return res;
#line 1134 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_le_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_le);
        if (!arg_le_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_le_bt = arg_le;
          intrusive_ptr<Backtrace_List<Value, pos_int> > arg_re_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_re);
          if (!arg_re_t) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_bt = arg_re;
            intrusive_ptr<Eval_List<Value> > arg_le_elist = evaluate(arg_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_re_elist = evaluate(arg_re_bt);
            for (typename Eval_List<Value>::iterator arg_le_elem_itr = arg_le_elist->begin(); arg_le_elem_itr != arg_le_elist->end(); ++ arg_le_elem_itr) {
              String arg_le_elem = *arg_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_re_elem_itr = arg_re_elist->begin(); arg_re_elem_itr != arg_re_elist->end(); ++ arg_re_elem_itr) {
                String arg_re_elem = *arg_re_elem_itr;
                String ret = acomb(arg_le_elem, arg_b, arg_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_le_elist);
            erase( arg_re_elist);
          } else 
          for (typename Backtrace_List<Value, pos_int>::iterator arg_re_bt_itr = arg_re_t->begin(); arg_re_bt_itr != arg_re_t->end(); ++ arg_re_bt_itr) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_bt = *arg_re_bt_itr;
            intrusive_ptr<Eval_List<Value> > arg_le_elist = evaluate(arg_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_re_elist = evaluate(arg_re_bt);
            for (typename Eval_List<Value>::iterator arg_le_elem_itr = arg_le_elist->begin(); arg_le_elem_itr != arg_le_elist->end(); ++ arg_le_elem_itr) {
              String arg_le_elem = *arg_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_re_elem_itr = arg_re_elist->begin(); arg_re_elem_itr != arg_re_elist->end(); ++ arg_re_elem_itr) {
                String arg_re_elem = *arg_re_elem_itr;
                String ret = acomb(arg_le_elem, arg_b, arg_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_le_elist);
            erase( arg_re_elist);
          }
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_le_bt_itr = arg_le_t->begin(); arg_le_bt_itr != arg_le_t->end(); ++ arg_le_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_le_bt = *arg_le_bt_itr;
          intrusive_ptr<Backtrace_List<Value, pos_int> > arg_re_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_re);
          if (!arg_re_t) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_bt = arg_re;
            intrusive_ptr<Eval_List<Value> > arg_le_elist = evaluate(arg_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_re_elist = evaluate(arg_re_bt);
            for (typename Eval_List<Value>::iterator arg_le_elem_itr = arg_le_elist->begin(); arg_le_elem_itr != arg_le_elist->end(); ++ arg_le_elem_itr) {
              String arg_le_elem = *arg_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_re_elem_itr = arg_re_elist->begin(); arg_re_elem_itr != arg_re_elist->end(); ++ arg_re_elem_itr) {
                String arg_re_elem = *arg_re_elem_itr;
                String ret = acomb(arg_le_elem, arg_b, arg_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_le_elist);
            erase( arg_re_elist);
          } else 
          for (typename Backtrace_List<Value, pos_int>::iterator arg_re_bt_itr = arg_re_t->begin(); arg_re_bt_itr != arg_re_t->end(); ++ arg_re_bt_itr) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_bt = *arg_re_bt_itr;
            intrusive_ptr<Eval_List<Value> > arg_le_elist = evaluate(arg_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_re_elist = evaluate(arg_re_bt);
            for (typename Eval_List<Value>::iterator arg_le_elem_itr = arg_le_elist->begin(); arg_le_elem_itr != arg_le_elist->end(); ++ arg_le_elem_itr) {
              String arg_le_elem = *arg_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_re_elem_itr = arg_re_elist->begin(); arg_re_elem_itr != arg_re_elist->end(); ++ arg_re_elem_itr) {
                String arg_re_elem = *arg_re_elem_itr;
                String ret = acomb(arg_le_elem, arg_b, arg_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_le_elist);
            erase( arg_re_elist);
          }
        }
        erase( arg_le);
        erase( arg_re);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_addss : Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;
      TUSubsequence arg_rb;

Backtrace_addss(intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_, TUSubsequence arg_rb_)
 : arg_e(arg_e_), arg_rb(arg_rb_)
{}

~Backtrace_addss()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String addss(const String & e, const TUSubsequence & rb)
      {
#line 2635 ""
        String res;
        append( res, e);
        append( res, '.', size(rb));
        return res;
#line 1241 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = addss(arg_e_elem, arg_rb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = addss(arg_e_elem, arg_rb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_ambd : Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_le;
      TUSubsequence arg_b;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_re;

Backtrace_ambd(intrusive_ptr<Backtrace<Value, pos_int> >  arg_le_, TUSubsequence arg_b_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_)
 : arg_le(arg_le_), arg_b(arg_b_), arg_re(arg_re_)
{}

~Backtrace_ambd()
{
erase(arg_le);
erase(arg_re);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String ambd(const String & le, const TUSubsequence & b, const String & re)
      {
#line 2449 ""
        String res;
        append( res, le);
        append( res, '.');
        append( res, re);
        return res;
#line 1302 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_le_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_le);
        if (!arg_le_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_le_bt = arg_le;
          intrusive_ptr<Backtrace_List<Value, pos_int> > arg_re_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_re);
          if (!arg_re_t) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_bt = arg_re;
            intrusive_ptr<Eval_List<Value> > arg_le_elist = evaluate(arg_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_re_elist = evaluate(arg_re_bt);
            for (typename Eval_List<Value>::iterator arg_le_elem_itr = arg_le_elist->begin(); arg_le_elem_itr != arg_le_elist->end(); ++ arg_le_elem_itr) {
              String arg_le_elem = *arg_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_re_elem_itr = arg_re_elist->begin(); arg_re_elem_itr != arg_re_elist->end(); ++ arg_re_elem_itr) {
                String arg_re_elem = *arg_re_elem_itr;
                String ret = ambd(arg_le_elem, arg_b, arg_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_le_elist);
            erase( arg_re_elist);
          } else 
          for (typename Backtrace_List<Value, pos_int>::iterator arg_re_bt_itr = arg_re_t->begin(); arg_re_bt_itr != arg_re_t->end(); ++ arg_re_bt_itr) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_bt = *arg_re_bt_itr;
            intrusive_ptr<Eval_List<Value> > arg_le_elist = evaluate(arg_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_re_elist = evaluate(arg_re_bt);
            for (typename Eval_List<Value>::iterator arg_le_elem_itr = arg_le_elist->begin(); arg_le_elem_itr != arg_le_elist->end(); ++ arg_le_elem_itr) {
              String arg_le_elem = *arg_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_re_elem_itr = arg_re_elist->begin(); arg_re_elem_itr != arg_re_elist->end(); ++ arg_re_elem_itr) {
                String arg_re_elem = *arg_re_elem_itr;
                String ret = ambd(arg_le_elem, arg_b, arg_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_le_elist);
            erase( arg_re_elist);
          }
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_le_bt_itr = arg_le_t->begin(); arg_le_bt_itr != arg_le_t->end(); ++ arg_le_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_le_bt = *arg_le_bt_itr;
          intrusive_ptr<Backtrace_List<Value, pos_int> > arg_re_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_re);
          if (!arg_re_t) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_bt = arg_re;
            intrusive_ptr<Eval_List<Value> > arg_le_elist = evaluate(arg_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_re_elist = evaluate(arg_re_bt);
            for (typename Eval_List<Value>::iterator arg_le_elem_itr = arg_le_elist->begin(); arg_le_elem_itr != arg_le_elist->end(); ++ arg_le_elem_itr) {
              String arg_le_elem = *arg_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_re_elem_itr = arg_re_elist->begin(); arg_re_elem_itr != arg_re_elist->end(); ++ arg_re_elem_itr) {
                String arg_re_elem = *arg_re_elem_itr;
                String ret = ambd(arg_le_elem, arg_b, arg_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_le_elist);
            erase( arg_re_elist);
          } else 
          for (typename Backtrace_List<Value, pos_int>::iterator arg_re_bt_itr = arg_re_t->begin(); arg_re_bt_itr != arg_re_t->end(); ++ arg_re_bt_itr) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_bt = *arg_re_bt_itr;
            intrusive_ptr<Eval_List<Value> > arg_le_elist = evaluate(arg_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_re_elist = evaluate(arg_re_bt);
            for (typename Eval_List<Value>::iterator arg_le_elem_itr = arg_le_elist->begin(); arg_le_elem_itr != arg_le_elist->end(); ++ arg_le_elem_itr) {
              String arg_le_elem = *arg_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_re_elem_itr = arg_re_elist->begin(); arg_re_elem_itr != arg_re_elist->end(); ++ arg_re_elem_itr) {
                String arg_re_elem = *arg_re_elem_itr;
                String ret = ambd(arg_le_elem, arg_b, arg_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_le_elist);
            erase( arg_re_elist);
          }
        }
        erase( arg_le);
        erase( arg_re);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_ambd_Pr : Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_le;
      TUSubsequence arg_b;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_re;

Backtrace_ambd_Pr(intrusive_ptr<Backtrace<Value, pos_int> >  arg_le_, TUSubsequence arg_b_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_)
 : arg_le(arg_le_), arg_b(arg_b_), arg_re(arg_re_)
{}

~Backtrace_ambd_Pr()
{
erase(arg_le);
erase(arg_re);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String ambd_Pr(const String & le, const TUSubsequence & b, const String & re)
      {
#line 2457 ""
        String res;
        append( res, le);
        append( res, '.');
        append( res, re);
        return res;
#line 1412 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_le_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_le);
        if (!arg_le_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_le_bt = arg_le;
          intrusive_ptr<Backtrace_List<Value, pos_int> > arg_re_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_re);
          if (!arg_re_t) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_bt = arg_re;
            intrusive_ptr<Eval_List<Value> > arg_le_elist = evaluate(arg_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_re_elist = evaluate(arg_re_bt);
            for (typename Eval_List<Value>::iterator arg_le_elem_itr = arg_le_elist->begin(); arg_le_elem_itr != arg_le_elist->end(); ++ arg_le_elem_itr) {
              String arg_le_elem = *arg_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_re_elem_itr = arg_re_elist->begin(); arg_re_elem_itr != arg_re_elist->end(); ++ arg_re_elem_itr) {
                String arg_re_elem = *arg_re_elem_itr;
                String ret = ambd_Pr(arg_le_elem, arg_b, arg_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_le_elist);
            erase( arg_re_elist);
          } else 
          for (typename Backtrace_List<Value, pos_int>::iterator arg_re_bt_itr = arg_re_t->begin(); arg_re_bt_itr != arg_re_t->end(); ++ arg_re_bt_itr) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_bt = *arg_re_bt_itr;
            intrusive_ptr<Eval_List<Value> > arg_le_elist = evaluate(arg_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_re_elist = evaluate(arg_re_bt);
            for (typename Eval_List<Value>::iterator arg_le_elem_itr = arg_le_elist->begin(); arg_le_elem_itr != arg_le_elist->end(); ++ arg_le_elem_itr) {
              String arg_le_elem = *arg_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_re_elem_itr = arg_re_elist->begin(); arg_re_elem_itr != arg_re_elist->end(); ++ arg_re_elem_itr) {
                String arg_re_elem = *arg_re_elem_itr;
                String ret = ambd_Pr(arg_le_elem, arg_b, arg_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_le_elist);
            erase( arg_re_elist);
          }
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_le_bt_itr = arg_le_t->begin(); arg_le_bt_itr != arg_le_t->end(); ++ arg_le_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_le_bt = *arg_le_bt_itr;
          intrusive_ptr<Backtrace_List<Value, pos_int> > arg_re_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_re);
          if (!arg_re_t) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_bt = arg_re;
            intrusive_ptr<Eval_List<Value> > arg_le_elist = evaluate(arg_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_re_elist = evaluate(arg_re_bt);
            for (typename Eval_List<Value>::iterator arg_le_elem_itr = arg_le_elist->begin(); arg_le_elem_itr != arg_le_elist->end(); ++ arg_le_elem_itr) {
              String arg_le_elem = *arg_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_re_elem_itr = arg_re_elist->begin(); arg_re_elem_itr != arg_re_elist->end(); ++ arg_re_elem_itr) {
                String arg_re_elem = *arg_re_elem_itr;
                String ret = ambd_Pr(arg_le_elem, arg_b, arg_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_le_elist);
            erase( arg_re_elist);
          } else 
          for (typename Backtrace_List<Value, pos_int>::iterator arg_re_bt_itr = arg_re_t->begin(); arg_re_bt_itr != arg_re_t->end(); ++ arg_re_bt_itr) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_bt = *arg_re_bt_itr;
            intrusive_ptr<Eval_List<Value> > arg_le_elist = evaluate(arg_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_re_elist = evaluate(arg_re_bt);
            for (typename Eval_List<Value>::iterator arg_le_elem_itr = arg_le_elist->begin(); arg_le_elem_itr != arg_le_elist->end(); ++ arg_le_elem_itr) {
              String arg_le_elem = *arg_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_re_elem_itr = arg_re_elist->begin(); arg_re_elem_itr != arg_re_elist->end(); ++ arg_re_elem_itr) {
                String arg_re_elem = *arg_re_elem_itr;
                String ret = ambd_Pr(arg_le_elem, arg_b, arg_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_le_elist);
            erase( arg_re_elist);
          }
        }
        erase( arg_le);
        erase( arg_re);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_bl : Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Value, pos_int> {
      TUSubsequence arg_lregion;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;

Backtrace_bl(TUSubsequence arg_lregion_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_)
 : arg_lregion(arg_lregion_), arg_e(arg_e_)
{}

~Backtrace_bl()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String bl(const TUSubsequence & lregion, const String & e)
      {
#line 2529 ""
        String res;
        append( res, '.', size(lregion));
        append( res, e);
        return res;
#line 1519 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = bl(arg_lregion, arg_e_elem);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = bl(arg_lregion, arg_e_elem);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_br : Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;
      TUSubsequence arg_rregion;

Backtrace_br(intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_, TUSubsequence arg_rregion_)
 : arg_e(arg_e_), arg_rregion(arg_rregion_)
{}

~Backtrace_br()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String br(const String & e, const TUSubsequence & rregion)
      {
#line 2536 ""
        String res;
        append( res, e);
        append( res, '.', size(rregion));
        return res;
#line 1577 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = br(arg_e_elem, arg_rregion);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = br(arg_e_elem, arg_rregion);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_cadd : Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_le;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_re;

Backtrace_cadd(intrusive_ptr<Backtrace<Value, pos_int> >  arg_le_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_)
 : arg_le(arg_le_), arg_re(arg_re_)
{}

~Backtrace_cadd()
{
erase(arg_le);
erase(arg_re);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String cadd(const String & le, const String & re)
      {
#line 2421 ""
        String res;
        append( res, le);
        append( res, re);
        return res;
#line 1636 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_le_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_le);
        if (!arg_le_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_le_bt = arg_le;
          intrusive_ptr<Backtrace_List<Value, pos_int> > arg_re_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_re);
          if (!arg_re_t) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_bt = arg_re;
            intrusive_ptr<Eval_List<Value> > arg_le_elist = evaluate(arg_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_re_elist = evaluate(arg_re_bt);
            for (typename Eval_List<Value>::iterator arg_le_elem_itr = arg_le_elist->begin(); arg_le_elem_itr != arg_le_elist->end(); ++ arg_le_elem_itr) {
              String arg_le_elem = *arg_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_re_elem_itr = arg_re_elist->begin(); arg_re_elem_itr != arg_re_elist->end(); ++ arg_re_elem_itr) {
                String arg_re_elem = *arg_re_elem_itr;
                String ret = cadd(arg_le_elem, arg_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_le_elist);
            erase( arg_re_elist);
          } else 
          for (typename Backtrace_List<Value, pos_int>::iterator arg_re_bt_itr = arg_re_t->begin(); arg_re_bt_itr != arg_re_t->end(); ++ arg_re_bt_itr) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_bt = *arg_re_bt_itr;
            intrusive_ptr<Eval_List<Value> > arg_le_elist = evaluate(arg_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_re_elist = evaluate(arg_re_bt);
            for (typename Eval_List<Value>::iterator arg_le_elem_itr = arg_le_elist->begin(); arg_le_elem_itr != arg_le_elist->end(); ++ arg_le_elem_itr) {
              String arg_le_elem = *arg_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_re_elem_itr = arg_re_elist->begin(); arg_re_elem_itr != arg_re_elist->end(); ++ arg_re_elem_itr) {
                String arg_re_elem = *arg_re_elem_itr;
                String ret = cadd(arg_le_elem, arg_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_le_elist);
            erase( arg_re_elist);
          }
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_le_bt_itr = arg_le_t->begin(); arg_le_bt_itr != arg_le_t->end(); ++ arg_le_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_le_bt = *arg_le_bt_itr;
          intrusive_ptr<Backtrace_List<Value, pos_int> > arg_re_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_re);
          if (!arg_re_t) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_bt = arg_re;
            intrusive_ptr<Eval_List<Value> > arg_le_elist = evaluate(arg_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_re_elist = evaluate(arg_re_bt);
            for (typename Eval_List<Value>::iterator arg_le_elem_itr = arg_le_elist->begin(); arg_le_elem_itr != arg_le_elist->end(); ++ arg_le_elem_itr) {
              String arg_le_elem = *arg_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_re_elem_itr = arg_re_elist->begin(); arg_re_elem_itr != arg_re_elist->end(); ++ arg_re_elem_itr) {
                String arg_re_elem = *arg_re_elem_itr;
                String ret = cadd(arg_le_elem, arg_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_le_elist);
            erase( arg_re_elist);
          } else 
          for (typename Backtrace_List<Value, pos_int>::iterator arg_re_bt_itr = arg_re_t->begin(); arg_re_bt_itr != arg_re_t->end(); ++ arg_re_bt_itr) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_bt = *arg_re_bt_itr;
            intrusive_ptr<Eval_List<Value> > arg_le_elist = evaluate(arg_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_re_elist = evaluate(arg_re_bt);
            for (typename Eval_List<Value>::iterator arg_le_elem_itr = arg_le_elist->begin(); arg_le_elem_itr != arg_le_elist->end(); ++ arg_le_elem_itr) {
              String arg_le_elem = *arg_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_re_elem_itr = arg_re_elist->begin(); arg_re_elem_itr != arg_re_elist->end(); ++ arg_re_elem_itr) {
                String arg_re_elem = *arg_re_elem_itr;
                String ret = cadd(arg_le_elem, arg_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_le_elist);
            erase( arg_re_elist);
          }
        }
        erase( arg_le);
        erase( arg_re);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_cadd_Pr : Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_le;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_re;

Backtrace_cadd_Pr(intrusive_ptr<Backtrace<Value, pos_int> >  arg_le_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_)
 : arg_le(arg_le_), arg_re(arg_re_)
{}

~Backtrace_cadd_Pr()
{
erase(arg_le);
erase(arg_re);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String cadd_Pr(const String & le, const String & re)
      {
#line 2428 ""
        String res;
        append( res, le);
        append( res, re);
        return res;
#line 1744 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_le_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_le);
        if (!arg_le_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_le_bt = arg_le;
          intrusive_ptr<Backtrace_List<Value, pos_int> > arg_re_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_re);
          if (!arg_re_t) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_bt = arg_re;
            intrusive_ptr<Eval_List<Value> > arg_le_elist = evaluate(arg_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_re_elist = evaluate(arg_re_bt);
            for (typename Eval_List<Value>::iterator arg_le_elem_itr = arg_le_elist->begin(); arg_le_elem_itr != arg_le_elist->end(); ++ arg_le_elem_itr) {
              String arg_le_elem = *arg_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_re_elem_itr = arg_re_elist->begin(); arg_re_elem_itr != arg_re_elist->end(); ++ arg_re_elem_itr) {
                String arg_re_elem = *arg_re_elem_itr;
                String ret = cadd_Pr(arg_le_elem, arg_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_le_elist);
            erase( arg_re_elist);
          } else 
          for (typename Backtrace_List<Value, pos_int>::iterator arg_re_bt_itr = arg_re_t->begin(); arg_re_bt_itr != arg_re_t->end(); ++ arg_re_bt_itr) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_bt = *arg_re_bt_itr;
            intrusive_ptr<Eval_List<Value> > arg_le_elist = evaluate(arg_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_re_elist = evaluate(arg_re_bt);
            for (typename Eval_List<Value>::iterator arg_le_elem_itr = arg_le_elist->begin(); arg_le_elem_itr != arg_le_elist->end(); ++ arg_le_elem_itr) {
              String arg_le_elem = *arg_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_re_elem_itr = arg_re_elist->begin(); arg_re_elem_itr != arg_re_elist->end(); ++ arg_re_elem_itr) {
                String arg_re_elem = *arg_re_elem_itr;
                String ret = cadd_Pr(arg_le_elem, arg_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_le_elist);
            erase( arg_re_elist);
          }
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_le_bt_itr = arg_le_t->begin(); arg_le_bt_itr != arg_le_t->end(); ++ arg_le_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_le_bt = *arg_le_bt_itr;
          intrusive_ptr<Backtrace_List<Value, pos_int> > arg_re_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_re);
          if (!arg_re_t) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_bt = arg_re;
            intrusive_ptr<Eval_List<Value> > arg_le_elist = evaluate(arg_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_re_elist = evaluate(arg_re_bt);
            for (typename Eval_List<Value>::iterator arg_le_elem_itr = arg_le_elist->begin(); arg_le_elem_itr != arg_le_elist->end(); ++ arg_le_elem_itr) {
              String arg_le_elem = *arg_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_re_elem_itr = arg_re_elist->begin(); arg_re_elem_itr != arg_re_elist->end(); ++ arg_re_elem_itr) {
                String arg_re_elem = *arg_re_elem_itr;
                String ret = cadd_Pr(arg_le_elem, arg_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_le_elist);
            erase( arg_re_elist);
          } else 
          for (typename Backtrace_List<Value, pos_int>::iterator arg_re_bt_itr = arg_re_t->begin(); arg_re_bt_itr != arg_re_t->end(); ++ arg_re_bt_itr) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_bt = *arg_re_bt_itr;
            intrusive_ptr<Eval_List<Value> > arg_le_elist = evaluate(arg_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_re_elist = evaluate(arg_re_bt);
            for (typename Eval_List<Value>::iterator arg_le_elem_itr = arg_le_elist->begin(); arg_le_elem_itr != arg_le_elist->end(); ++ arg_le_elem_itr) {
              String arg_le_elem = *arg_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_re_elem_itr = arg_re_elist->begin(); arg_re_elem_itr != arg_re_elist->end(); ++ arg_re_elem_itr) {
                String arg_re_elem = *arg_re_elem_itr;
                String ret = cadd_Pr(arg_le_elem, arg_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_le_elist);
            erase( arg_re_elist);
          }
        }
        erase( arg_le);
        erase( arg_re);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_cadd_Pr_Pr : Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_le;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_re;

Backtrace_cadd_Pr_Pr(intrusive_ptr<Backtrace<Value, pos_int> >  arg_le_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_)
 : arg_le(arg_le_), arg_re(arg_re_)
{}

~Backtrace_cadd_Pr_Pr()
{
erase(arg_le);
erase(arg_re);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String cadd_Pr_Pr(const String & le, const String & re)
      {
#line 2435 ""
        String res;
        append( res, le);
        append( res, re);
        return res;
#line 1852 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_le_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_le);
        if (!arg_le_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_le_bt = arg_le;
          intrusive_ptr<Backtrace_List<Value, pos_int> > arg_re_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_re);
          if (!arg_re_t) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_bt = arg_re;
            intrusive_ptr<Eval_List<Value> > arg_le_elist = evaluate(arg_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_re_elist = evaluate(arg_re_bt);
            for (typename Eval_List<Value>::iterator arg_le_elem_itr = arg_le_elist->begin(); arg_le_elem_itr != arg_le_elist->end(); ++ arg_le_elem_itr) {
              String arg_le_elem = *arg_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_re_elem_itr = arg_re_elist->begin(); arg_re_elem_itr != arg_re_elist->end(); ++ arg_re_elem_itr) {
                String arg_re_elem = *arg_re_elem_itr;
                String ret = cadd_Pr_Pr(arg_le_elem, arg_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_le_elist);
            erase( arg_re_elist);
          } else 
          for (typename Backtrace_List<Value, pos_int>::iterator arg_re_bt_itr = arg_re_t->begin(); arg_re_bt_itr != arg_re_t->end(); ++ arg_re_bt_itr) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_bt = *arg_re_bt_itr;
            intrusive_ptr<Eval_List<Value> > arg_le_elist = evaluate(arg_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_re_elist = evaluate(arg_re_bt);
            for (typename Eval_List<Value>::iterator arg_le_elem_itr = arg_le_elist->begin(); arg_le_elem_itr != arg_le_elist->end(); ++ arg_le_elem_itr) {
              String arg_le_elem = *arg_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_re_elem_itr = arg_re_elist->begin(); arg_re_elem_itr != arg_re_elist->end(); ++ arg_re_elem_itr) {
                String arg_re_elem = *arg_re_elem_itr;
                String ret = cadd_Pr_Pr(arg_le_elem, arg_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_le_elist);
            erase( arg_re_elist);
          }
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_le_bt_itr = arg_le_t->begin(); arg_le_bt_itr != arg_le_t->end(); ++ arg_le_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_le_bt = *arg_le_bt_itr;
          intrusive_ptr<Backtrace_List<Value, pos_int> > arg_re_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_re);
          if (!arg_re_t) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_bt = arg_re;
            intrusive_ptr<Eval_List<Value> > arg_le_elist = evaluate(arg_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_re_elist = evaluate(arg_re_bt);
            for (typename Eval_List<Value>::iterator arg_le_elem_itr = arg_le_elist->begin(); arg_le_elem_itr != arg_le_elist->end(); ++ arg_le_elem_itr) {
              String arg_le_elem = *arg_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_re_elem_itr = arg_re_elist->begin(); arg_re_elem_itr != arg_re_elist->end(); ++ arg_re_elem_itr) {
                String arg_re_elem = *arg_re_elem_itr;
                String ret = cadd_Pr_Pr(arg_le_elem, arg_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_le_elist);
            erase( arg_re_elist);
          } else 
          for (typename Backtrace_List<Value, pos_int>::iterator arg_re_bt_itr = arg_re_t->begin(); arg_re_bt_itr != arg_re_t->end(); ++ arg_re_bt_itr) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_bt = *arg_re_bt_itr;
            intrusive_ptr<Eval_List<Value> > arg_le_elist = evaluate(arg_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_re_elist = evaluate(arg_re_bt);
            for (typename Eval_List<Value>::iterator arg_le_elem_itr = arg_le_elist->begin(); arg_le_elem_itr != arg_le_elist->end(); ++ arg_le_elem_itr) {
              String arg_le_elem = *arg_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_re_elem_itr = arg_re_elist->begin(); arg_re_elem_itr != arg_re_elist->end(); ++ arg_re_elem_itr) {
                String arg_re_elem = *arg_re_elem_itr;
                String ret = cadd_Pr_Pr(arg_le_elem, arg_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_le_elist);
            erase( arg_re_elist);
          }
        }
        erase( arg_le);
        erase( arg_re);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_cadd_Pr_Pr_Pr : Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_le;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_re;

Backtrace_cadd_Pr_Pr_Pr(intrusive_ptr<Backtrace<Value, pos_int> >  arg_le_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_)
 : arg_le(arg_le_), arg_re(arg_re_)
{}

~Backtrace_cadd_Pr_Pr_Pr()
{
erase(arg_le);
erase(arg_re);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String cadd_Pr_Pr_Pr(const String & le, const String & re)
      {
#line 2442 ""
        String res;
        append( res, le);
        append( res, re);
        return res;
#line 1960 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_le_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_le);
        if (!arg_le_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_le_bt = arg_le;
          intrusive_ptr<Backtrace_List<Value, pos_int> > arg_re_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_re);
          if (!arg_re_t) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_bt = arg_re;
            intrusive_ptr<Eval_List<Value> > arg_le_elist = evaluate(arg_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_re_elist = evaluate(arg_re_bt);
            for (typename Eval_List<Value>::iterator arg_le_elem_itr = arg_le_elist->begin(); arg_le_elem_itr != arg_le_elist->end(); ++ arg_le_elem_itr) {
              String arg_le_elem = *arg_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_re_elem_itr = arg_re_elist->begin(); arg_re_elem_itr != arg_re_elist->end(); ++ arg_re_elem_itr) {
                String arg_re_elem = *arg_re_elem_itr;
                String ret = cadd_Pr_Pr_Pr(arg_le_elem, arg_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_le_elist);
            erase( arg_re_elist);
          } else 
          for (typename Backtrace_List<Value, pos_int>::iterator arg_re_bt_itr = arg_re_t->begin(); arg_re_bt_itr != arg_re_t->end(); ++ arg_re_bt_itr) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_bt = *arg_re_bt_itr;
            intrusive_ptr<Eval_List<Value> > arg_le_elist = evaluate(arg_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_re_elist = evaluate(arg_re_bt);
            for (typename Eval_List<Value>::iterator arg_le_elem_itr = arg_le_elist->begin(); arg_le_elem_itr != arg_le_elist->end(); ++ arg_le_elem_itr) {
              String arg_le_elem = *arg_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_re_elem_itr = arg_re_elist->begin(); arg_re_elem_itr != arg_re_elist->end(); ++ arg_re_elem_itr) {
                String arg_re_elem = *arg_re_elem_itr;
                String ret = cadd_Pr_Pr_Pr(arg_le_elem, arg_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_le_elist);
            erase( arg_re_elist);
          }
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_le_bt_itr = arg_le_t->begin(); arg_le_bt_itr != arg_le_t->end(); ++ arg_le_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_le_bt = *arg_le_bt_itr;
          intrusive_ptr<Backtrace_List<Value, pos_int> > arg_re_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_re);
          if (!arg_re_t) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_bt = arg_re;
            intrusive_ptr<Eval_List<Value> > arg_le_elist = evaluate(arg_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_re_elist = evaluate(arg_re_bt);
            for (typename Eval_List<Value>::iterator arg_le_elem_itr = arg_le_elist->begin(); arg_le_elem_itr != arg_le_elist->end(); ++ arg_le_elem_itr) {
              String arg_le_elem = *arg_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_re_elem_itr = arg_re_elist->begin(); arg_re_elem_itr != arg_re_elist->end(); ++ arg_re_elem_itr) {
                String arg_re_elem = *arg_re_elem_itr;
                String ret = cadd_Pr_Pr_Pr(arg_le_elem, arg_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_le_elist);
            erase( arg_re_elist);
          } else 
          for (typename Backtrace_List<Value, pos_int>::iterator arg_re_bt_itr = arg_re_t->begin(); arg_re_bt_itr != arg_re_t->end(); ++ arg_re_bt_itr) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_bt = *arg_re_bt_itr;
            intrusive_ptr<Eval_List<Value> > arg_le_elist = evaluate(arg_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_re_elist = evaluate(arg_re_bt);
            for (typename Eval_List<Value>::iterator arg_le_elem_itr = arg_le_elist->begin(); arg_le_elem_itr != arg_le_elist->end(); ++ arg_le_elem_itr) {
              String arg_le_elem = *arg_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_re_elem_itr = arg_re_elist->begin(); arg_re_elem_itr != arg_re_elist->end(); ++ arg_re_elem_itr) {
                String arg_re_elem = *arg_re_elem_itr;
                String ret = cadd_Pr_Pr_Pr(arg_le_elem, arg_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_le_elist);
            erase( arg_re_elist);
          }
        }
        erase( arg_le);
        erase( arg_re);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_combine : Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_le;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_re;

Backtrace_combine(intrusive_ptr<Backtrace<Value, pos_int> >  arg_le_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_)
 : arg_le(arg_le_), arg_re(arg_re_)
{}

~Backtrace_combine()
{
erase(arg_le);
erase(arg_re);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String combine(const String & le, const String & re)
      {
#line 2657 ""
        String res;
        append( res, le);
        append( res, re);
        return res;
#line 2068 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_le_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_le);
        if (!arg_le_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_le_bt = arg_le;
          intrusive_ptr<Backtrace_List<Value, pos_int> > arg_re_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_re);
          if (!arg_re_t) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_bt = arg_re;
            intrusive_ptr<Eval_List<Value> > arg_le_elist = evaluate(arg_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_re_elist = evaluate(arg_re_bt);
            for (typename Eval_List<Value>::iterator arg_le_elem_itr = arg_le_elist->begin(); arg_le_elem_itr != arg_le_elist->end(); ++ arg_le_elem_itr) {
              String arg_le_elem = *arg_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_re_elem_itr = arg_re_elist->begin(); arg_re_elem_itr != arg_re_elist->end(); ++ arg_re_elem_itr) {
                String arg_re_elem = *arg_re_elem_itr;
                String ret = combine(arg_le_elem, arg_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_le_elist);
            erase( arg_re_elist);
          } else 
          for (typename Backtrace_List<Value, pos_int>::iterator arg_re_bt_itr = arg_re_t->begin(); arg_re_bt_itr != arg_re_t->end(); ++ arg_re_bt_itr) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_bt = *arg_re_bt_itr;
            intrusive_ptr<Eval_List<Value> > arg_le_elist = evaluate(arg_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_re_elist = evaluate(arg_re_bt);
            for (typename Eval_List<Value>::iterator arg_le_elem_itr = arg_le_elist->begin(); arg_le_elem_itr != arg_le_elist->end(); ++ arg_le_elem_itr) {
              String arg_le_elem = *arg_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_re_elem_itr = arg_re_elist->begin(); arg_re_elem_itr != arg_re_elist->end(); ++ arg_re_elem_itr) {
                String arg_re_elem = *arg_re_elem_itr;
                String ret = combine(arg_le_elem, arg_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_le_elist);
            erase( arg_re_elist);
          }
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_le_bt_itr = arg_le_t->begin(); arg_le_bt_itr != arg_le_t->end(); ++ arg_le_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_le_bt = *arg_le_bt_itr;
          intrusive_ptr<Backtrace_List<Value, pos_int> > arg_re_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_re);
          if (!arg_re_t) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_bt = arg_re;
            intrusive_ptr<Eval_List<Value> > arg_le_elist = evaluate(arg_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_re_elist = evaluate(arg_re_bt);
            for (typename Eval_List<Value>::iterator arg_le_elem_itr = arg_le_elist->begin(); arg_le_elem_itr != arg_le_elist->end(); ++ arg_le_elem_itr) {
              String arg_le_elem = *arg_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_re_elem_itr = arg_re_elist->begin(); arg_re_elem_itr != arg_re_elist->end(); ++ arg_re_elem_itr) {
                String arg_re_elem = *arg_re_elem_itr;
                String ret = combine(arg_le_elem, arg_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_le_elist);
            erase( arg_re_elist);
          } else 
          for (typename Backtrace_List<Value, pos_int>::iterator arg_re_bt_itr = arg_re_t->begin(); arg_re_bt_itr != arg_re_t->end(); ++ arg_re_bt_itr) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_bt = *arg_re_bt_itr;
            intrusive_ptr<Eval_List<Value> > arg_le_elist = evaluate(arg_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_re_elist = evaluate(arg_re_bt);
            for (typename Eval_List<Value>::iterator arg_le_elem_itr = arg_le_elist->begin(); arg_le_elem_itr != arg_le_elist->end(); ++ arg_le_elem_itr) {
              String arg_le_elem = *arg_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_re_elem_itr = arg_re_elist->begin(); arg_re_elem_itr != arg_re_elist->end(); ++ arg_re_elem_itr) {
                String arg_re_elem = *arg_re_elem_itr;
                String ret = combine(arg_le_elem, arg_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_le_elist);
            erase( arg_re_elist);
          }
        }
        erase( arg_le);
        erase( arg_re);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_drem : Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;

Backtrace_drem(intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_)
 : arg_e(arg_e_)
{}

~Backtrace_drem()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String drem(const String & e)
      {
#line 2497 ""
        return e;
#line 2171 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = drem(arg_e_elem);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = drem(arg_e_elem);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_edl : Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Value, pos_int> {
      TUSubsequence arg_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;

Backtrace_edl(TUSubsequence arg_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_)
 : arg_lb(arg_lb_), arg_e(arg_e_)
{}

~Backtrace_edl()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String edl(const TUSubsequence & lb, const String & e)
      {
#line 2475 ""
        String res;
        append( res, '.');
        append( res, e);
        return res;
#line 2229 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = edl(arg_lb, arg_e_elem);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = edl(arg_lb, arg_e_elem);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_edlr : Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Value, pos_int> {
      TUSubsequence arg_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;
      TUSubsequence arg_rb;

Backtrace_edlr(TUSubsequence arg_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_, TUSubsequence arg_rb_)
 : arg_lb(arg_lb_), arg_e(arg_e_), arg_rb(arg_rb_)
{}

~Backtrace_edlr()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String edlr(const TUSubsequence & lb, const String & e, const TUSubsequence & rb)
      {
#line 2489 ""
        String res;
        append( res, '.');
        append( res, e);
        append( res, '.');
        return res;
#line 2289 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = edlr(arg_lb, arg_e_elem, arg_rb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = edlr(arg_lb, arg_e_elem, arg_rb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_edr : Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;
      TUSubsequence arg_rb;

Backtrace_edr(intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_, TUSubsequence arg_rb_)
 : arg_e(arg_e_), arg_rb(arg_rb_)
{}

~Backtrace_edr()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String edr(const String & e, const TUSubsequence & rb)
      {
#line 2482 ""
        String res;
        append( res, e);
        append( res, '.');
        return res;
#line 2347 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = edr(arg_e_elem, arg_rb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = edr(arg_e_elem, arg_rb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_hl : Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Value, pos_int> {
      TUSubsequence arg_llb;
      TUSubsequence arg_lb;
      TUSubsequence arg_region;
      TUSubsequence arg_rb;
      TUSubsequence arg_rrb;

Backtrace_hl(TUSubsequence arg_llb_, TUSubsequence arg_lb_, TUSubsequence arg_region_, TUSubsequence arg_rb_, TUSubsequence arg_rrb_)
 : arg_llb(arg_llb_), arg_lb(arg_lb_), arg_region(arg_region_), arg_rb(arg_rb_), arg_rrb(arg_rrb_)
{}

~Backtrace_hl()
{
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String hl(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & region, const TUSubsequence & rb, const TUSubsequence & rrb)
      {
#line 2513 ""
        String res;
        append( res, "((", 2);
        append( res, '.', size(region));
        append( res, "))", 2);
        return res;
#line 2408 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        String ret = hl(arg_llb, arg_lb, arg_region, arg_rb, arg_rrb);
        push_back( answer, ret);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_il : Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Value, pos_int> {
      TUSubsequence arg_lregion;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;
      TUSubsequence arg_rregion;

Backtrace_il(TUSubsequence arg_lregion_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_, TUSubsequence arg_rregion_)
 : arg_lregion(arg_lregion_), arg_e(arg_e_), arg_rregion(arg_rregion_)
{}

~Backtrace_il()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String il(const TUSubsequence & lregion, const String & e, const TUSubsequence & rregion)
      {
#line 2543 ""
        String res;
        append( res, '.', size(lregion));
        append( res, e);
        append( res, '.', size(rregion));
        return res;
#line 2448 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = il(arg_lregion, arg_e_elem, arg_rregion);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = il(arg_lregion, arg_e_elem, arg_rregion);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_incl : Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;

Backtrace_incl(intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_)
 : arg_e(arg_e_)
{}

~Backtrace_incl()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String incl(const String & e)
      {
#line 2653 ""
        return e;
#line 2502 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = incl(arg_e_elem);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = incl(arg_e_elem);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_is : Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;

Backtrace_is(intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_)
 : arg_e(arg_e_)
{}

~Backtrace_is()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String is(const String & e)
      {
#line 2501 ""
        return e;
#line 2556 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = is(arg_e_elem);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = is(arg_e_elem);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_ml : Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Value, pos_int> {
      TUSubsequence arg_llb;
      TUSubsequence arg_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;
      TUSubsequence arg_rb;
      TUSubsequence arg_rrb;

Backtrace_ml(TUSubsequence arg_llb_, TUSubsequence arg_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_, TUSubsequence arg_rb_, TUSubsequence arg_rrb_)
 : arg_llb(arg_llb_), arg_lb(arg_lb_), arg_e(arg_e_), arg_rb(arg_rb_), arg_rrb(arg_rrb_)
{}

~Backtrace_ml()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String ml(const TUSubsequence & llb, const TUSubsequence & lb, const String & e, const TUSubsequence & rb, const TUSubsequence & rrb)
      {
#line 2551 ""
        String res;
        append( res, "((", 2);
        append( res, e);
        append( res, "))", 2);
        return res;
#line 2618 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = ml(arg_llb, arg_lb, arg_e_elem, arg_rb, arg_rrb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = ml(arg_llb, arg_lb, arg_e_elem, arg_rb, arg_rrb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_mladl : Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Value, pos_int> {
      TUSubsequence arg_llb;
      TUSubsequence arg_lb;
      TUSubsequence arg_dl;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;
      TUSubsequence arg_rb;
      TUSubsequence arg_rrb;

Backtrace_mladl(TUSubsequence arg_llb_, TUSubsequence arg_lb_, TUSubsequence arg_dl_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_, TUSubsequence arg_rb_, TUSubsequence arg_rrb_)
 : arg_llb(arg_llb_), arg_lb(arg_lb_), arg_dl(arg_dl_), arg_e(arg_e_), arg_rb(arg_rb_), arg_rrb(arg_rrb_)
{}

~Backtrace_mladl()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String mladl(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const String & e, const TUSubsequence & rb, const TUSubsequence & rrb)
      {
#line 2626 ""
        String res;
        append( res, "((", 2);
        append( res, '.');
        append( res, e);
        append( res, "))", 2);
        return res;
#line 2682 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = mladl(arg_llb, arg_lb, arg_dl, arg_e_elem, arg_rb, arg_rrb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = mladl(arg_llb, arg_lb, arg_dl, arg_e_elem, arg_rb, arg_rrb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_mladldr : Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Value, pos_int> {
      TUSubsequence arg_llb;
      TUSubsequence arg_lb;
      TUSubsequence arg_dl;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;
      TUSubsequence arg_dr;
      TUSubsequence arg_rb;
      TUSubsequence arg_rrb;

Backtrace_mladldr(TUSubsequence arg_llb_, TUSubsequence arg_lb_, TUSubsequence arg_dl_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_, TUSubsequence arg_dr_, TUSubsequence arg_rb_, TUSubsequence arg_rrb_)
 : arg_llb(arg_llb_), arg_lb(arg_lb_), arg_dl(arg_dl_), arg_e(arg_e_), arg_dr(arg_dr_), arg_rb(arg_rb_), arg_rrb(arg_rrb_)
{}

~Backtrace_mladldr()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String mladldr(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const String & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb)
      {
#line 2607 ""
        String res;
        append( res, "((", 2);
        append( res, '.');
        append( res, e);
        append( res, '.');
        append( res, "))", 2);
        return res;
#line 2748 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = mladldr(arg_llb, arg_lb, arg_dl, arg_e_elem, arg_dr, arg_rb, arg_rrb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = mladldr(arg_llb, arg_lb, arg_dl, arg_e_elem, arg_dr, arg_rb, arg_rrb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_mladlr : Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Value, pos_int> {
      TUSubsequence arg_llb;
      TUSubsequence arg_lb;
      TUSubsequence arg_dl;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;
      TUSubsequence arg_dr;
      TUSubsequence arg_rb;
      TUSubsequence arg_rrb;

Backtrace_mladlr(TUSubsequence arg_llb_, TUSubsequence arg_lb_, TUSubsequence arg_dl_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_, TUSubsequence arg_dr_, TUSubsequence arg_rb_, TUSubsequence arg_rrb_)
 : arg_llb(arg_llb_), arg_lb(arg_lb_), arg_dl(arg_dl_), arg_e(arg_e_), arg_dr(arg_dr_), arg_rb(arg_rb_), arg_rrb(arg_rrb_)
{}

~Backtrace_mladlr()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String mladlr(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const String & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb)
      {
#line 2587 ""
        String res;
        append( res, "((", 2);
        append( res, '.');
        append( res, e);
        append( res, '.');
        append( res, "))", 2);
        return res;
#line 2814 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = mladlr(arg_llb, arg_lb, arg_dl, arg_e_elem, arg_dr, arg_rb, arg_rrb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = mladlr(arg_llb, arg_lb, arg_dl, arg_e_elem, arg_dr, arg_rb, arg_rrb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_mladr : Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Value, pos_int> {
      TUSubsequence arg_llb;
      TUSubsequence arg_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;
      TUSubsequence arg_dr;
      TUSubsequence arg_rb;
      TUSubsequence arg_rrb;

Backtrace_mladr(TUSubsequence arg_llb_, TUSubsequence arg_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_, TUSubsequence arg_dr_, TUSubsequence arg_rb_, TUSubsequence arg_rrb_)
 : arg_llb(arg_llb_), arg_lb(arg_lb_), arg_e(arg_e_), arg_dr(arg_dr_), arg_rb(arg_rb_), arg_rrb(arg_rrb_)
{}

~Backtrace_mladr()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String mladr(const TUSubsequence & llb, const TUSubsequence & lb, const String & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb)
      {
#line 2568 ""
        String res;
        append( res, "((", 2);
        append( res, e);
        append( res, '.');
        append( res, "))", 2);
        return res;
#line 2878 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = mladr(arg_llb, arg_lb, arg_e_elem, arg_dr, arg_rb, arg_rrb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = mladr(arg_llb, arg_lb, arg_e_elem, arg_dr, arg_rb, arg_rrb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_mldl : Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Value, pos_int> {
      TUSubsequence arg_llb;
      TUSubsequence arg_lb;
      TUSubsequence arg_dl;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;
      TUSubsequence arg_rb;
      TUSubsequence arg_rrb;

Backtrace_mldl(TUSubsequence arg_llb_, TUSubsequence arg_lb_, TUSubsequence arg_dl_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_, TUSubsequence arg_rb_, TUSubsequence arg_rrb_)
 : arg_llb(arg_llb_), arg_lb(arg_lb_), arg_dl(arg_dl_), arg_e(arg_e_), arg_rb(arg_rb_), arg_rrb(arg_rrb_)
{}

~Backtrace_mldl()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String mldl(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const String & e, const TUSubsequence & rb, const TUSubsequence & rrb)
      {
#line 2617 ""
        String res;
        append( res, "((", 2);
        append( res, '.');
        append( res, e);
        append( res, "))", 2);
        return res;
#line 2942 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = mldl(arg_llb, arg_lb, arg_dl, arg_e_elem, arg_rb, arg_rrb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = mldl(arg_llb, arg_lb, arg_dl, arg_e_elem, arg_rb, arg_rrb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_mldladr : Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Value, pos_int> {
      TUSubsequence arg_llb;
      TUSubsequence arg_lb;
      TUSubsequence arg_dl;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;
      TUSubsequence arg_dr;
      TUSubsequence arg_rb;
      TUSubsequence arg_rrb;

Backtrace_mldladr(TUSubsequence arg_llb_, TUSubsequence arg_lb_, TUSubsequence arg_dl_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_, TUSubsequence arg_dr_, TUSubsequence arg_rb_, TUSubsequence arg_rrb_)
 : arg_llb(arg_llb_), arg_lb(arg_lb_), arg_dl(arg_dl_), arg_e(arg_e_), arg_dr(arg_dr_), arg_rb(arg_rb_), arg_rrb(arg_rrb_)
{}

~Backtrace_mldladr()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String mldladr(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const String & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb)
      {
#line 2597 ""
        String res;
        append( res, "((", 2);
        append( res, '.');
        append( res, e);
        append( res, '.');
        append( res, "))", 2);
        return res;
#line 3008 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = mldladr(arg_llb, arg_lb, arg_dl, arg_e_elem, arg_dr, arg_rb, arg_rrb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = mldladr(arg_llb, arg_lb, arg_dl, arg_e_elem, arg_dr, arg_rb, arg_rrb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_mldlr : Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Value, pos_int> {
      TUSubsequence arg_llb;
      TUSubsequence arg_lb;
      TUSubsequence arg_dl;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;
      TUSubsequence arg_dr;
      TUSubsequence arg_rb;
      TUSubsequence arg_rrb;

Backtrace_mldlr(TUSubsequence arg_llb_, TUSubsequence arg_lb_, TUSubsequence arg_dl_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_, TUSubsequence arg_dr_, TUSubsequence arg_rb_, TUSubsequence arg_rrb_)
 : arg_llb(arg_llb_), arg_lb(arg_lb_), arg_dl(arg_dl_), arg_e(arg_e_), arg_dr(arg_dr_), arg_rb(arg_rb_), arg_rrb(arg_rrb_)
{}

~Backtrace_mldlr()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String mldlr(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const String & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb)
      {
#line 2577 ""
        String res;
        append( res, "((", 2);
        append( res, '.');
        append( res, e);
        append( res, '.');
        append( res, "))", 2);
        return res;
#line 3074 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = mldlr(arg_llb, arg_lb, arg_dl, arg_e_elem, arg_dr, arg_rb, arg_rrb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = mldlr(arg_llb, arg_lb, arg_dl, arg_e_elem, arg_dr, arg_rb, arg_rrb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_mldr : Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Value, pos_int> {
      TUSubsequence arg_llb;
      TUSubsequence arg_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;
      TUSubsequence arg_dr;
      TUSubsequence arg_rb;
      TUSubsequence arg_rrb;

Backtrace_mldr(TUSubsequence arg_llb_, TUSubsequence arg_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_, TUSubsequence arg_dr_, TUSubsequence arg_rb_, TUSubsequence arg_rrb_)
 : arg_llb(arg_llb_), arg_lb(arg_lb_), arg_e(arg_e_), arg_dr(arg_dr_), arg_rb(arg_rb_), arg_rrb(arg_rrb_)
{}

~Backtrace_mldr()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String mldr(const TUSubsequence & llb, const TUSubsequence & lb, const String & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb)
      {
#line 2559 ""
        String res;
        append( res, "((", 2);
        append( res, e);
        append( res, '.');
        append( res, "))", 2);
        return res;
#line 3138 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = mldr(arg_llb, arg_lb, arg_e_elem, arg_dr, arg_rb, arg_rrb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = mldr(arg_llb, arg_lb, arg_e_elem, arg_dr, arg_rb, arg_rrb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_nil : Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Value, pos_int> {
      TUSubsequence arg_loc;

Backtrace_nil(TUSubsequence arg_loc_)
 : arg_loc(arg_loc_)
{}

~Backtrace_nil()
{
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String nil(const TUSubsequence & loc)
      {
#line 2465 ""
        String r;
        return r;
#line 3192 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        String ret = nil(arg_loc);
        push_back( answer, ret);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_nil_Pr : Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Value, pos_int> {
      TUSubsequence arg_loc;

Backtrace_nil_Pr(TUSubsequence arg_loc_)
 : arg_loc(arg_loc_)
{}

~Backtrace_nil_Pr()
{
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String nil_Pr(const TUSubsequence & loc)
      {
#line 2470 ""
        String r;
        return r;
#line 3226 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        String ret = nil_Pr(arg_loc);
        push_back( answer, ret);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_sadd : Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Value, pos_int> {
      TUSubsequence arg_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;

Backtrace_sadd(TUSubsequence arg_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_)
 : arg_lb(arg_lb_), arg_e(arg_e_)
{}

~Backtrace_sadd()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String sadd(const TUSubsequence & lb, const String & e)
      {
#line 2414 ""
        String res;
        append( res, '.');
        append( res, e);
        return res;
#line 3264 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = sadd(arg_lb, arg_e_elem);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = sadd(arg_lb, arg_e_elem);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_sp : Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Value, pos_int> {
      TUSubsequence arg_llb;
      TUSubsequence arg_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;
      TUSubsequence arg_rb;
      TUSubsequence arg_rrb;

Backtrace_sp(TUSubsequence arg_llb_, TUSubsequence arg_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_, TUSubsequence arg_rb_, TUSubsequence arg_rrb_)
 : arg_llb(arg_llb_), arg_lb(arg_lb_), arg_e(arg_e_), arg_rb(arg_rb_), arg_rrb(arg_rrb_)
{}

~Backtrace_sp()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String sp(const TUSubsequence & llb, const TUSubsequence & lb, const String & e, const TUSubsequence & rb, const TUSubsequence & rrb)
      {
#line 2521 ""
        String res;
        append( res, "((", 2);
        append( res, e);
        append( res, "))", 2);
        return res;
#line 3326 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = sp(arg_llb, arg_lb, arg_e_elem, arg_rb, arg_rrb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = sp(arg_llb, arg_lb, arg_e_elem, arg_rb, arg_rrb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_sr : Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Value, pos_int> {
      TUSubsequence arg_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;
      TUSubsequence arg_rb;

Backtrace_sr(TUSubsequence arg_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_, TUSubsequence arg_rb_)
 : arg_lb(arg_lb_), arg_e(arg_e_), arg_rb(arg_rb_)
{}

~Backtrace_sr()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String sr(const TUSubsequence & lb, const String & e, const TUSubsequence & rb)
      {
#line 2505 ""
        String res;
        append( res, '(');
        append( res, e);
        append( res, ')');
        return res;
#line 3386 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = sr(arg_lb, arg_e_elem, arg_rb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = sr(arg_lb, arg_e_elem, arg_rb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_ssadd : Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Value, pos_int> {
      TUSubsequence arg_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;

Backtrace_ssadd(TUSubsequence arg_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_)
 : arg_lb(arg_lb_), arg_e(arg_e_)
{}

~Backtrace_ssadd()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String ssadd(const TUSubsequence & lb, const String & e)
      {
#line 2642 ""
        String res;
        append( res, '.', size(lb));
        append( res, e);
        return res;
#line 3444 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = ssadd(arg_lb, arg_e_elem);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = ssadd(arg_lb, arg_e_elem);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_trafo : Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;

Backtrace_trafo(intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_)
 : arg_e(arg_e_)
{}

~Backtrace_trafo()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String trafo(const String & e)
      {
#line 2649 ""
        return e;
#line 3498 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = trafo(arg_e_elem);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = trafo(arg_e_elem);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_struct_Back : public Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>
{
Backtrace_nt_struct_Back(Klass *klass_)
  : Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>(klass_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_struct());
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_struct_Front : public Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> >  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_struct_Back<hishapeb_mfe_pfx, Value, pos_int> > back;

Backtrace_nt_struct_Front(intrusive_ptr<Backtrace_nt_struct_Back<hishapeb_mfe_pfx, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , hishapeb_mfe_pfx, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_left_unpaired_Back : public Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>
{
pos_int t_0_i;
Backtrace_nt_left_unpaired_Back(Klass *klass_, pos_int t_0_i_)
  : Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_left_unpaired(t_0_i));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_left_unpaired_Front : public Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> >  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_left_unpaired_Back<hishapeb_mfe_pfx, Value, pos_int> > back;

Backtrace_nt_left_unpaired_Front(intrusive_ptr<Backtrace_nt_left_unpaired_Back<hishapeb_mfe_pfx, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , hishapeb_mfe_pfx, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_left_dangle_Back : public Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>
{
pos_int t_0_i;
Backtrace_nt_left_dangle_Back(Klass *klass_, pos_int t_0_i_)
  : Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_left_dangle(t_0_i));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_left_dangle_Front : public Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> >  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_left_dangle_Back<hishapeb_mfe_pfx, Value, pos_int> > back;

Backtrace_nt_left_dangle_Front(intrusive_ptr<Backtrace_nt_left_dangle_Back<hishapeb_mfe_pfx, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , hishapeb_mfe_pfx, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_noleft_dangle_Back : public Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>
{
pos_int t_0_i;
Backtrace_nt_noleft_dangle_Back(Klass *klass_, pos_int t_0_i_)
  : Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_noleft_dangle(t_0_i));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_noleft_dangle_Front : public Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> >  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_noleft_dangle_Back<hishapeb_mfe_pfx, Value, pos_int> > back;

Backtrace_nt_noleft_dangle_Front(intrusive_ptr<Backtrace_nt_noleft_dangle_Back<hishapeb_mfe_pfx, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , hishapeb_mfe_pfx, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_edanglel_struct_Back : public Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_edanglel_struct_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_edanglel_struct(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_edanglel_struct_Front : public Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> >  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_edanglel_struct_Back<hishapeb_mfe_pfx, Value, pos_int> > back;

Backtrace_nt_edanglel_struct_Front(intrusive_ptr<Backtrace_nt_edanglel_struct_Back<hishapeb_mfe_pfx, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , hishapeb_mfe_pfx, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_edangler_struct_Back : public Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_edangler_struct_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_edangler_struct(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_edangler_struct_Front : public Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> >  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_edangler_struct_Back<hishapeb_mfe_pfx, Value, pos_int> > back;

Backtrace_nt_edangler_struct_Front(intrusive_ptr<Backtrace_nt_edangler_struct_Back<hishapeb_mfe_pfx, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , hishapeb_mfe_pfx, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_edanglelr_struct_Back : public Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_edanglelr_struct_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_edanglelr_struct(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_edanglelr_struct_Front : public Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> >  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_edanglelr_struct_Back<hishapeb_mfe_pfx, Value, pos_int> > back;

Backtrace_nt_edanglelr_struct_Front(intrusive_ptr<Backtrace_nt_edanglelr_struct_Back<hishapeb_mfe_pfx, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , hishapeb_mfe_pfx, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_nodangle_struct_Back : public Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_nodangle_struct_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_nodangle_struct(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_nodangle_struct_Front : public Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> >  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_nodangle_struct_Back<hishapeb_mfe_pfx, Value, pos_int> > back;

Backtrace_nt_nodangle_struct_Front(intrusive_ptr<Backtrace_nt_nodangle_struct_Back<hishapeb_mfe_pfx, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , hishapeb_mfe_pfx, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_edanglel_ml_Back : public Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_edanglel_ml_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_edanglel_ml(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_edanglel_ml_Front : public Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> >  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_edanglel_ml_Back<hishapeb_mfe_pfx, Value, pos_int> > back;

Backtrace_nt_edanglel_ml_Front(intrusive_ptr<Backtrace_nt_edanglel_ml_Back<hishapeb_mfe_pfx, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , hishapeb_mfe_pfx, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_edangler_ml_Back : public Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_edangler_ml_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_edangler_ml(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_edangler_ml_Front : public Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> >  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_edangler_ml_Back<hishapeb_mfe_pfx, Value, pos_int> > back;

Backtrace_nt_edangler_ml_Front(intrusive_ptr<Backtrace_nt_edangler_ml_Back<hishapeb_mfe_pfx, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , hishapeb_mfe_pfx, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_edanglelr_ml_Back : public Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_edanglelr_ml_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_edanglelr_ml(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_edanglelr_ml_Front : public Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> >  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_edanglelr_ml_Back<hishapeb_mfe_pfx, Value, pos_int> > back;

Backtrace_nt_edanglelr_ml_Front(intrusive_ptr<Backtrace_nt_edanglelr_ml_Back<hishapeb_mfe_pfx, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , hishapeb_mfe_pfx, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_nodangle_ml_Back : public Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_nodangle_ml_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_nodangle_ml(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_nodangle_ml_Front : public Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> >  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_nodangle_ml_Back<hishapeb_mfe_pfx, Value, pos_int> > back;

Backtrace_nt_nodangle_ml_Front(intrusive_ptr<Backtrace_nt_nodangle_ml_Back<hishapeb_mfe_pfx, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , hishapeb_mfe_pfx, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_initstem_Back : public Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_initstem_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_initstem(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_initstem_Front : public Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> >  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_initstem_Back<hishapeb_mfe_pfx, Value, pos_int> > back;

Backtrace_nt_initstem_Front(intrusive_ptr<Backtrace_nt_initstem_Back<hishapeb_mfe_pfx, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , hishapeb_mfe_pfx, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_closed_Back : public Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_closed_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_closed(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_closed_Front : public Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> >  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_closed_Back<hishapeb_mfe_pfx, Value, pos_int> > back;

Backtrace_nt_closed_Front(intrusive_ptr<Backtrace_nt_closed_Back<hishapeb_mfe_pfx, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , hishapeb_mfe_pfx, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_multiloop_Back : public Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_multiloop_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_multiloop(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_multiloop_Front : public Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> >  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_multiloop_Back<hishapeb_mfe_pfx, Value, pos_int> > back;

Backtrace_nt_multiloop_Front(intrusive_ptr<Backtrace_nt_multiloop_Back<hishapeb_mfe_pfx, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , hishapeb_mfe_pfx, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_ml_comps1_Back : public Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_ml_comps1_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_ml_comps1(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_ml_comps1_Front : public Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> >  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_ml_comps1_Back<hishapeb_mfe_pfx, Value, pos_int> > back;

Backtrace_nt_ml_comps1_Front(intrusive_ptr<Backtrace_nt_ml_comps1_Back<hishapeb_mfe_pfx, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , hishapeb_mfe_pfx, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_ml_comps2_Back : public Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_ml_comps2_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_ml_comps2(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_ml_comps2_Front : public Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> >  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_ml_comps2_Back<hishapeb_mfe_pfx, Value, pos_int> > back;

Backtrace_nt_ml_comps2_Front(intrusive_ptr<Backtrace_nt_ml_comps2_Back<hishapeb_mfe_pfx, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , hishapeb_mfe_pfx, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_ml_comps3_Back : public Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_ml_comps3_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_ml_comps3(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_ml_comps3_Front : public Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> >  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_ml_comps3_Back<hishapeb_mfe_pfx, Value, pos_int> > back;

Backtrace_nt_ml_comps3_Front(intrusive_ptr<Backtrace_nt_ml_comps3_Back<hishapeb_mfe_pfx, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , hishapeb_mfe_pfx, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_ml_comps4_Back : public Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_ml_comps4_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_ml_comps4(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_ml_comps4_Front : public Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> >  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_ml_comps4_Back<hishapeb_mfe_pfx, Value, pos_int> > back;

Backtrace_nt_ml_comps4_Front(intrusive_ptr<Backtrace_nt_ml_comps4_Back<hishapeb_mfe_pfx, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , hishapeb_mfe_pfx, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_block_dl_Back : public Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_block_dl_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_block_dl(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_block_dl_Front : public Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> >  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_block_dl_Back<hishapeb_mfe_pfx, Value, pos_int> > back;

Backtrace_nt_block_dl_Front(intrusive_ptr<Backtrace_nt_block_dl_Back<hishapeb_mfe_pfx, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , hishapeb_mfe_pfx, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_block_dlr_Back : public Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_block_dlr_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_block_dlr(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_block_dlr_Front : public Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> >  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_block_dlr_Back<hishapeb_mfe_pfx, Value, pos_int> > back;

Backtrace_nt_block_dlr_Front(intrusive_ptr<Backtrace_nt_block_dlr_Back<hishapeb_mfe_pfx, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , hishapeb_mfe_pfx, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_no_dl_no_ss_end_Back : public Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_no_dl_no_ss_end_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_no_dl_no_ss_end(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_no_dl_no_ss_end_Front : public Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> >  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_no_dl_no_ss_end_Back<hishapeb_mfe_pfx, Value, pos_int> > back;

Backtrace_nt_no_dl_no_ss_end_Front(intrusive_ptr<Backtrace_nt_no_dl_no_ss_end_Back<hishapeb_mfe_pfx, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , hishapeb_mfe_pfx, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_dl_or_ss_left_no_ss_end_Back : public Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_dl_or_ss_left_no_ss_end_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_dl_or_ss_left_no_ss_end(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_dl_or_ss_left_no_ss_end_Front : public Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> >  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_dl_or_ss_left_no_ss_end_Back<hishapeb_mfe_pfx, Value, pos_int> > back;

Backtrace_nt_dl_or_ss_left_no_ss_end_Front(intrusive_ptr<Backtrace_nt_dl_or_ss_left_no_ss_end_Back<hishapeb_mfe_pfx, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , hishapeb_mfe_pfx, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_no_dl_ss_end_Back : public Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_no_dl_ss_end_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_no_dl_ss_end(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_no_dl_ss_end_Front : public Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> >  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_no_dl_ss_end_Back<hishapeb_mfe_pfx, Value, pos_int> > back;

Backtrace_nt_no_dl_ss_end_Front(intrusive_ptr<Backtrace_nt_no_dl_ss_end_Back<hishapeb_mfe_pfx, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , hishapeb_mfe_pfx, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_dl_or_ss_left_ss_end_Back : public Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_dl_or_ss_left_ss_end_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_dl_or_ss_left_ss_end(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_dl_or_ss_left_ss_end_Front : public Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> >  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_dl_or_ss_left_ss_end_Back<hishapeb_mfe_pfx, Value, pos_int> > back;

Backtrace_nt_dl_or_ss_left_ss_end_Front(intrusive_ptr<Backtrace_nt_dl_or_ss_left_ss_end_Back<hishapeb_mfe_pfx, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , hishapeb_mfe_pfx, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_stack_Back : public Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_stack_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_stack(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_stack_Front : public Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> >  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_stack_Back<hishapeb_mfe_pfx, Value, pos_int> > back;

Backtrace_nt_stack_Front(intrusive_ptr<Backtrace_nt_stack_Back<hishapeb_mfe_pfx, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , hishapeb_mfe_pfx, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_hairpin_Back : public Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_hairpin_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_hairpin(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_hairpin_Front : public Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> >  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_hairpin_Back<hishapeb_mfe_pfx, Value, pos_int> > back;

Backtrace_nt_hairpin_Front(intrusive_ptr<Backtrace_nt_hairpin_Back<hishapeb_mfe_pfx, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , hishapeb_mfe_pfx, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_leftB_Back : public Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_leftB_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_leftB(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_leftB_Front : public Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> >  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_leftB_Back<hishapeb_mfe_pfx, Value, pos_int> > back;

Backtrace_nt_leftB_Front(intrusive_ptr<Backtrace_nt_leftB_Back<hishapeb_mfe_pfx, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , hishapeb_mfe_pfx, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_rightB_Back : public Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_rightB_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_rightB(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_rightB_Front : public Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> >  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_rightB_Back<hishapeb_mfe_pfx, Value, pos_int> > back;

Backtrace_nt_rightB_Front(intrusive_ptr<Backtrace_nt_rightB_Back<hishapeb_mfe_pfx, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , hishapeb_mfe_pfx, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_iloop_Back : public Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_iloop_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_iloop(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_iloop_Front : public Backtrace_Score<std::pair<Rope, std::pair<mfeanswer, pfanswer> >  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_iloop_Back<hishapeb_mfe_pfx, Value, pos_int> > back;

Backtrace_nt_iloop_Front(intrusive_ptr<Backtrace_nt_iloop_Back<hishapeb_mfe_pfx, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , hishapeb_mfe_pfx, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_struct();
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_left_unpaired(unsigned int t_0_i);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_left_dangle(unsigned int t_0_i);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_noleft_dangle(unsigned int t_0_i);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_edanglel_struct(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_edangler_struct(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_edanglelr_struct(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_nodangle_struct(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_edanglel_ml(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_edangler_ml(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_edanglelr_ml(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_nodangle_ml(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_initstem(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_closed(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_multiloop(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_ml_comps1(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_ml_comps2(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_ml_comps3(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_ml_comps4(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_block_dl(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_block_dlr(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_no_dl_no_ss_end(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_dl_or_ss_left_no_ss_end(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_no_dl_ss_end(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_dl_or_ss_left_ss_end(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_stack(unsigned int t_0_i, unsigned int t_0_j);
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  bt_proxy_nt_hairpin(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_leftB(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_rightB(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_iloop(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_block_dl(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_block_dlr(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_closed(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_dl_or_ss_left_no_ss_end(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_dl_or_ss_left_ss_end(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_edanglel_ml(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_edanglel_struct(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_edanglelr_ml(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_edanglelr_struct(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_edangler_ml(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_edangler_struct(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_hairpin(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_iloop(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_initstem(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_leftB(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_left_dangle(unsigned int t_0_i);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_left_unpaired(unsigned int t_0_i);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_ml_comps1(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_ml_comps2(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_ml_comps3(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_ml_comps4(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_multiloop(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_no_dl_no_ss_end(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_no_dl_ss_end(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_nodangle_ml(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_nodangle_struct(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_noleft_dangle(unsigned int t_0_i);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_rightB(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_stack(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_struct();

    intrusive_ptr<Backtrace<String, unsigned int> >  acomb_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<String, unsigned int> >  param_2);
    intrusive_ptr<Backtrace<String, unsigned int> >  addss_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0, const TUSubsequence & param_1);
    intrusive_ptr<Backtrace<String, unsigned int> >  ambd_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<String, unsigned int> >  param_2);
    intrusive_ptr<Backtrace<String, unsigned int> >  ambd_Pr_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<String, unsigned int> >  param_2);
    intrusive_ptr<Backtrace<String, unsigned int> >  bl_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1);
    intrusive_ptr<Backtrace<String, unsigned int> >  br_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0, const TUSubsequence & param_1);
    intrusive_ptr<Backtrace<String, unsigned int> >  cadd_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1);
    intrusive_ptr<Backtrace<String, unsigned int> >  cadd_Pr_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1);
    intrusive_ptr<Backtrace<String, unsigned int> >  cadd_Pr_Pr_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1);
    intrusive_ptr<Backtrace<String, unsigned int> >  cadd_Pr_Pr_Pr_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1);
    intrusive_ptr<Backtrace<String, unsigned int> >  combine_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1);
    intrusive_ptr<Backtrace<String, unsigned int> >  drem_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0);
    intrusive_ptr<Backtrace<String, unsigned int> >  edl_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1);
    intrusive_ptr<Backtrace<String, unsigned int> >  edlr_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1, const TUSubsequence & param_2);
    intrusive_ptr<Backtrace<String, unsigned int> >  edr_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0, const TUSubsequence & param_1);
    List_Ref<intrusive_ptr<Backtrace<String, unsigned int> > > h_bt_r(List_Ref<intrusive_ptr<Backtrace<String, unsigned int> > > param_0);
    intrusive_ptr<Backtrace<String, unsigned int> >  hl_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, const TUSubsequence & param_2, const TUSubsequence & param_3, const TUSubsequence & param_4);
    intrusive_ptr<Backtrace<String, unsigned int> >  il_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1, const TUSubsequence & param_2);
    intrusive_ptr<Backtrace<String, unsigned int> >  incl_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0);
    intrusive_ptr<Backtrace<String, unsigned int> >  is_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0);
    intrusive_ptr<Backtrace<String, unsigned int> >  ml_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<String, unsigned int> >  param_2, const TUSubsequence & param_3, const TUSubsequence & param_4);
    intrusive_ptr<Backtrace<String, unsigned int> >  mladl_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, const TUSubsequence & param_2, intrusive_ptr<Backtrace<String, unsigned int> >  param_3, const TUSubsequence & param_4, const TUSubsequence & param_5);
    intrusive_ptr<Backtrace<String, unsigned int> >  mladldr_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, const TUSubsequence & param_2, intrusive_ptr<Backtrace<String, unsigned int> >  param_3, const TUSubsequence & param_4, const TUSubsequence & param_5, const TUSubsequence & param_6);
    intrusive_ptr<Backtrace<String, unsigned int> >  mladlr_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, const TUSubsequence & param_2, intrusive_ptr<Backtrace<String, unsigned int> >  param_3, const TUSubsequence & param_4, const TUSubsequence & param_5, const TUSubsequence & param_6);
    intrusive_ptr<Backtrace<String, unsigned int> >  mladr_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<String, unsigned int> >  param_2, const TUSubsequence & param_3, const TUSubsequence & param_4, const TUSubsequence & param_5);
    intrusive_ptr<Backtrace<String, unsigned int> >  mldl_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, const TUSubsequence & param_2, intrusive_ptr<Backtrace<String, unsigned int> >  param_3, const TUSubsequence & param_4, const TUSubsequence & param_5);
    intrusive_ptr<Backtrace<String, unsigned int> >  mldladr_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, const TUSubsequence & param_2, intrusive_ptr<Backtrace<String, unsigned int> >  param_3, const TUSubsequence & param_4, const TUSubsequence & param_5, const TUSubsequence & param_6);
    intrusive_ptr<Backtrace<String, unsigned int> >  mldlr_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, const TUSubsequence & param_2, intrusive_ptr<Backtrace<String, unsigned int> >  param_3, const TUSubsequence & param_4, const TUSubsequence & param_5, const TUSubsequence & param_6);
    intrusive_ptr<Backtrace<String, unsigned int> >  mldr_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<String, unsigned int> >  param_2, const TUSubsequence & param_3, const TUSubsequence & param_4, const TUSubsequence & param_5);
    intrusive_ptr<Backtrace<String, unsigned int> >  nil_bt_r(const TUSubsequence & param_0);
    intrusive_ptr<Backtrace<String, unsigned int> >  nil_Pr_bt_r(const TUSubsequence & param_0);
    intrusive_ptr<Backtrace<String, unsigned int> >  sadd_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1);
    intrusive_ptr<Backtrace<String, unsigned int> >  sp_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<String, unsigned int> >  param_2, const TUSubsequence & param_3, const TUSubsequence & param_4);
    intrusive_ptr<Backtrace<String, unsigned int> >  sr_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1, const TUSubsequence & param_2);
    intrusive_ptr<Backtrace<String, unsigned int> >  ssadd_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1);
    intrusive_ptr<Backtrace<String, unsigned int> >  trafo_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0);


    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  acomb_bt(const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_le, const TUSubsequence & p_p_b, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_re);
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  addss_bt(const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb);
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ambd_bt(const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_le, const TUSubsequence & p_p_b, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_re);
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ambd_Pr_bt(const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_le, const TUSubsequence & p_p_b, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_re);
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  bl_bt(const TUSubsequence & p_p_lregion, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e);
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  br_bt(const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rregion);
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  cadd_bt(const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_le, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_re);
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  cadd_Pr_bt(const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_le, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_re);
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  cadd_Pr_Pr_bt(const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_le, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_re);
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  cadd_Pr_Pr_Pr_bt(const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_le, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_re);
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  combine_bt(const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_le, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_re);
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  drem_bt(const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e);
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  edl_bt(const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e);
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  edlr_bt(const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb);
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  edr_bt(const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > h_bt(List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > i, hishapeb_mfe_pfx_hash_h_b_pfx &  left_answers);
template <typename Iterator>
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > h_bt(std::pair<Iterator, Iterator> i, hishapeb_mfe_pfx_hash_h_b_pfx &  left_answers)
;
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > h_bt(List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > i);
template <typename Iterator>
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > h_bt(std::pair<Iterator, Iterator> i)
;
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  hl_bt(const TUSubsequence & p_p_llb, const TUSubsequence & p_p_lb, const TUSubsequence & p_p_region, const TUSubsequence & p_p_rb, const TUSubsequence & p_p_rrb);
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  il_bt(const TUSubsequence & p_p_lregion, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rregion);
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  incl_bt(const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e);
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  is_bt(const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e);
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ml_bt(const TUSubsequence & p_p_llb, const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb, const TUSubsequence & p_p_rrb);
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  mladl_bt(const TUSubsequence & p_p_llb, const TUSubsequence & p_p_lb, const TUSubsequence & p_p_dl, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb, const TUSubsequence & p_p_rrb);
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  mladldr_bt(const TUSubsequence & p_p_llb, const TUSubsequence & p_p_lb, const TUSubsequence & p_p_dl, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_dr, const TUSubsequence & p_p_rb, const TUSubsequence & p_p_rrb);
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  mladlr_bt(const TUSubsequence & p_p_llb, const TUSubsequence & p_p_lb, const TUSubsequence & p_p_dl, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_dr, const TUSubsequence & p_p_rb, const TUSubsequence & p_p_rrb);
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  mladr_bt(const TUSubsequence & p_p_llb, const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_dr, const TUSubsequence & p_p_rb, const TUSubsequence & p_p_rrb);
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  mldl_bt(const TUSubsequence & p_p_llb, const TUSubsequence & p_p_lb, const TUSubsequence & p_p_dl, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb, const TUSubsequence & p_p_rrb);
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  mldladr_bt(const TUSubsequence & p_p_llb, const TUSubsequence & p_p_lb, const TUSubsequence & p_p_dl, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_dr, const TUSubsequence & p_p_rb, const TUSubsequence & p_p_rrb);
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  mldlr_bt(const TUSubsequence & p_p_llb, const TUSubsequence & p_p_lb, const TUSubsequence & p_p_dl, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_dr, const TUSubsequence & p_p_rb, const TUSubsequence & p_p_rrb);
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  mldr_bt(const TUSubsequence & p_p_llb, const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_dr, const TUSubsequence & p_p_rb, const TUSubsequence & p_p_rrb);
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  nil_bt(const TUSubsequence & p_p_loc);
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  nil_Pr_bt(const TUSubsequence & p_p_loc);
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  sadd_bt(const TUSubsequence & p_p_b, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e);
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  sp_bt(const TUSubsequence & p_p_llb, const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb, const TUSubsequence & p_p_rrb);
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  sr_bt(const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb);
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ssadd_bt(const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e);
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  trafo_bt(const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e);

template <typename Value>   void  print_result(std::ostream &out, Value& res)

{
}
   intrusive_ptr<Backtrace<String, unsigned int> >  backtrack()
{
List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > bt  = bt_proxy_nt_struct();
return execute_backtrack_k(bt);
}
template <typename Value>   void  print_backtrack(std::ostream &out, Value& value)

{
intrusive_ptr<Backtrace<String, unsigned int> >  bt   = backtrack();
intrusive_ptr<Backtrace_List<String, unsigned int> > l =
  boost::dynamic_pointer_cast<Backtrace_List<String, unsigned int> >(bt);
assert(!bt || (bt && l));
if (l) {
for (Backtrace_List<String, unsigned int>::iterator i = l->begin();
     i != l->end(); ++i)
  (*i)->print(out);
}
}
   void  print_subopt(std::ostream &out, int  delta = 0) {}

};

#ifndef NO_GAPC_TYPEDEFS
namespace gapc {
  typedef hishapeb_mfe_pfx hishapeb_pfx_cls;
  typedef hishapeb_mfe_pfx_hash_h_b_pfx hishapeb_pfx_ret;
}
#endif

#endif

