
// A dynamic programming evaluator generated by GAP-C.
// 
//   GAP-C version:
//     bellmansgapc-2012.05.07
// 
//   GAP-C call:
//     /home/jhuang/gapc/bin/gapc hishapes_lm_nolp.gap.cc -i hishapeh_mfe_pp -o hishapeh_mfe_pp.cc --kbacktrack --kbest --no-coopt-class --class-name hhpp 
// 
// 


#define GAPC_MOD_TRANSLATION_UNIT
#include "hishapeh_mfeV4_pp.hh"

uint32_t hhpp_insp_hash_h::k_ = 3;
#include <rtlib/subopt.hh>
#include "rna.hh"
#include "filter_add.hh"
//#include "mfe_filter.hh"
#include "mfe_answer.hh"
#include "mfe_answer_v4.hh"
#include "pf_answer.hh"
#include "hishape_filter.hh"

#include <rtlib/generic_opts.hh>

hhpp_hash_h &  hhpp::nt_closed(unsigned int t_0_i, unsigned int t_0_j)
{
  if (closed_table.is_tabulated(t_0_i, t_0_j))
    {
      return closed_table.get(t_0_i, t_0_j);
    }

  hhpp_hash_h answers;
  empty(answers);
  empty( answers);
  hhpp_hash_h ret_0 = nt_stack(t_0_i, t_0_j);
  append( answers, ret_0);
  std::pair<Rope, mfeanswer_v4>  ret_1 = nt_hairpin(t_0_i, t_0_j);
  if (is_not_empty(ret_1))
    {
      push_back( answers, ret_1);
    }

  hhpp_hash_h ret_2 = nt_leftB(t_0_i, t_0_j);
  append( answers, ret_2);
  hhpp_hash_h ret_3 = nt_rightB(t_0_i, t_0_j);
  append( answers, ret_3);
  hhpp_hash_h ret_4 = nt_iloop(t_0_i, t_0_j);
  append( answers, ret_4);
  hhpp_hash_h ret_5 = nt_multiloop(t_0_i, t_0_j);
  //append( answers, ret_5);
if (_locallymin) {
  hhpp_hash_h a_0 = ret_5;
  if (is_not_empty(a_0)) {
    for (hhpp_hash_h::iterator x_0_itr = a_0.ref().begin(); x_0_itr!=a_0.ref().end(); ++x_0_itr){
      std::pair<Rope, mfeanswer_v4>  x_0 = *x_0_itr;




// IMPORTANT TODO: using x_0.energy instead of recalculate the dangle base energy
// NOTE: in this are, no. of inistem of ans >= 2 ==> beforeLastStem is not NULL
  
// reconstruct x_0_subword, x_0_firstStem and x_0_lastStem; the remaining item should be the same as ans in nt_multiloop stage
TUSubsequence x_0_subword = REGION(t_0_seq, x_0.second.subword.i+2, x_0.second.subword.j-2);
TUSubsequence x_0_firstStem = REGION(t_0_seq, x_0.second.outermost_initstem_i, x_0.second.next_ss_i);


// first_ss:       x_0_subword.i, x_0.second.outermost_initstem_i
// next_ss:        x_0.second.next_ss_i, x_0.second.next_ss_j
// after_next_ss:  x_0.second.after_next_ss_i, x_0.second.after_next_ss_j
// before_last_ss: x_0.second.before_last_ss_i, x_0.second.before_last_ss_j
// last_ss:        x_0.second.outermost_initstem_j, x_0_subword.j

bool lmCompliant = true;
//std::cout << "7z:" << ans << std::endl;
Subsequence multi_inner_stem = REGION(t_0_seq, x_0.second.subword.i+1, x_0.second.subword.j-1);
//7_a
//  ..((...))...((...)).....|  old
//  ..((...))a(b((...))c)d..|  new
// NOTE: (x_0.second.before_last_ss_j == -1) means  (x_0.second.after_next_ss_j == -1)
int the_before_last_ss_i = 0;
int the_before_last_ss_j = 0;
if (x_0.second.before_last_ss_j == -1) {  // no. of inistem == 2
  the_before_last_ss_i = x_0.second.next_ss_i;
  the_before_last_ss_j = x_0.second.next_ss_j;
} else {
  the_before_last_ss_i = x_0.second.before_last_ss_i;
  the_before_last_ss_j = x_0.second.before_last_ss_j;
}
TUSubsequence x_0_lastStem = REGION(t_0_seq, the_before_last_ss_j, x_0.second.outermost_initstem_j);


// if dangle bases exist on both sides
int before_last_ss_dangle_energy_0 = 0;
int last_ss_dangle_energy_0 = 0;
if ((the_before_last_ss_j - the_before_last_ss_i) == 1) {
  before_last_ss_dangle_energy_0 = min(dr_energy(x_0.second.beforeLastStem, x_0.second.beforeLastStem), dl_energy(x_0_lastStem, x_0_lastStem));
} else if ((the_before_last_ss_j - the_before_last_ss_i) > 1) {
  before_last_ss_dangle_energy_0 = dr_energy(x_0.second.beforeLastStem, x_0.second.beforeLastStem) + dl_energy(x_0_lastStem, x_0_lastStem);
}
if ((x_0_subword.j - x_0.second.outermost_initstem_j) == 1) {
  last_ss_dangle_energy_0 = min(dr_energy(x_0_lastStem, x_0_lastStem), dri_energy(multi_inner_stem, multi_inner_stem));
} else if ((x_0_subword.j - x_0.second.outermost_initstem_j) > 1) {
  last_ss_dangle_energy_0 = dr_energy(x_0_lastStem, x_0_lastStem) + dri_energy(multi_inner_stem, multi_inner_stem);
}


// try to ADD a bp
int before_last_ss_dangle_energy_1 = 0;
int last_ss_dangle_energy_1 = 0;
int additional_energy_1 = 0;
TUSubsequence extended_stem;
for (unsigned int before_last_ss_pos = the_before_last_ss_i; before_last_ss_pos < the_before_last_ss_j; before_last_ss_pos++) {
  if (!lmCompliant) {
    break;
  }
  for (unsigned int last_ss_pos = x_0.second.outermost_initstem_j; last_ss_pos < x_0_subword.j; last_ss_pos++) {
    if (basepairing(t_0_seq, before_last_ss_pos, last_ss_pos+1)) {
      extended_stem = REGION(t_0_seq,before_last_ss_pos,last_ss_pos+1);
      if (loop_complete_table_energy.is_tabulated(before_last_ss_pos, (unsigned int)the_before_last_ss_j, (unsigned int)x_0.second.outermost_initstem_j, last_ss_pos+1)) {
	additional_energy_1 = loop_complete_table_energy.get(before_last_ss_pos, (unsigned int)the_before_last_ss_j, (unsigned int)x_0.second.outermost_initstem_j, last_ss_pos+1); 
      } else {
	if ((the_before_last_ss_j - before_last_ss_pos) == 1 ) {   //b
	  if ((last_ss_pos - x_0.second.outermost_initstem_j) == 0) {       //c
	    additional_energy_1 = sr_energy(extended_stem, extended_stem);
	  } else if ((last_ss_pos - x_0.second.outermost_initstem_j) > 0) { //c
	    additional_energy_1 = br_energy(extended_stem, REGION(t_0_seq,(unsigned int)x_0.second.outermost_initstem_j,last_ss_pos));
	  }
	} else if ((the_before_last_ss_j - before_last_ss_pos) > 1 ) {    //b
	  if ((last_ss_pos - x_0.second.outermost_initstem_j) == 0) {               //c
	    additional_energy_1 = bl_energy(REGION(t_0_seq, before_last_ss_pos+1, (unsigned int)the_before_last_ss_j), extended_stem);
	  } else if ((last_ss_pos - x_0.second.outermost_initstem_j) > 0) {         //c
	    additional_energy_1 = il_energy(REGION(t_0_seq, before_last_ss_pos+1, (unsigned int)the_before_last_ss_j), REGION(t_0_seq,(unsigned int)x_0.second.outermost_initstem_j,last_ss_pos));
	  }
	}

	loop_complete_table_energy.set(before_last_ss_pos, (unsigned int)the_before_last_ss_j, (unsigned int)x_0.second.outermost_initstem_j, last_ss_pos+1, additional_energy_1);
      }

      
      if ((before_last_ss_pos - the_before_last_ss_i) == 1 ) {    //a
	before_last_ss_dangle_energy_1 = min(dr_energy(x_0.second.beforeLastStem, x_0.second.beforeLastStem), dl_energy(extended_stem, extended_stem));
      } else if ((before_last_ss_pos - the_before_last_ss_i) > 1) {
	before_last_ss_dangle_energy_1 = dr_energy(x_0.second.beforeLastStem, x_0.second.beforeLastStem) + dl_energy(extended_stem, extended_stem);         
      } else {
	// because of for-loop, the value are ensured with explicite assignment
	before_last_ss_dangle_energy_1 = 0;
      }
      if ((x_0_subword.j - last_ss_pos) == 2) {  //d
	last_ss_dangle_energy_1 = min(dr_energy(extended_stem, extended_stem), dri_energy(multi_inner_stem, multi_inner_stem));
      } else if ((x_0_subword.j - last_ss_pos) > 2) {
	last_ss_dangle_energy_1 = dr_energy(extended_stem, extended_stem) + dri_energy(multi_inner_stem, multi_inner_stem);
      } else {
	last_ss_dangle_energy_1 = 0;
      }

      //std::cout << "6_a: " << x_0 << ans << next_ss_dangle_energy_1 <<"+"<< last_ss_dangle_energy_1 <<"+"<< additional_energy_1 <<"<>"<< next_ss_dangle_energy_0 <<"+"<< last_ss_dangle_energy_0 << std::endl;
      if ( \
	   ( !_shouldermin && ((before_last_ss_dangle_energy_1 + last_ss_dangle_energy_1 + additional_energy_1 + termau_energy(extended_stem,extended_stem)) <= (before_last_ss_dangle_energy_0 + last_ss_dangle_energy_0 + termau_energy(x_0_lastStem,x_0_lastStem))) ) \
           || ( _shouldermin && ((before_last_ss_dangle_energy_1 + last_ss_dangle_energy_1 + additional_energy_1 + termau_energy(extended_stem,extended_stem)) < (before_last_ss_dangle_energy_0 + last_ss_dangle_energy_0 + termau_energy(x_0_lastStem,x_0_lastStem))) ) \
         ) {
	lmCompliant = false;
	break;
      }
    }
  }
}
// try to DEL a bp
//  ..((...))...((.((...))..)).....|  old
//  ..((...))....(.((...))..)......|  new
if (lmCompliant) {
  int additional_energy_0 = 0;
  TUSubsequence inner_stem = REGION(t_0_seq,(unsigned int)(the_before_last_ss_j+1),(unsigned int)(x_0.second.outermost_initstem_j-1));
  if (loop_complete_table_energy.is_tabulated((unsigned int)the_before_last_ss_j, (unsigned int)(the_before_last_ss_j+1), (unsigned int)(x_0.second.outermost_initstem_j-1), (unsigned int)x_0.second.outermost_initstem_j)) {
    additional_energy_0 = loop_complete_table_energy.get((unsigned int)the_before_last_ss_j, (unsigned int)(the_before_last_ss_j+1), (unsigned int)(x_0.second.outermost_initstem_j-1), (unsigned int)x_0.second.outermost_initstem_j); 
  } else {
    additional_energy_0 = sr_energy(x_0_lastStem, x_0_lastStem);

    loop_complete_table_energy.set((unsigned int)the_before_last_ss_j, (unsigned int)(the_before_last_ss_j+1), (unsigned int)(x_0.second.outermost_initstem_j-1), (unsigned int)x_0.second.outermost_initstem_j, additional_energy_0);
  }

  if ((the_before_last_ss_j - the_before_last_ss_i) == 0 ) {  //a
    before_last_ss_dangle_energy_1 = min(dr_energy(x_0.second.beforeLastStem, x_0.second.beforeLastStem), dl_energy(inner_stem, inner_stem));
  } else {
    before_last_ss_dangle_energy_1 = dr_energy(x_0.second.beforeLastStem, x_0.second.beforeLastStem) + dl_energy(inner_stem, inner_stem);         
  }
  if ((x_0_subword.j - x_0.second.outermost_initstem_j) == 0) {  //d
    last_ss_dangle_energy_1 = min(dr_energy(inner_stem, inner_stem), dri_energy(multi_inner_stem, multi_inner_stem));
  } else {
    last_ss_dangle_energy_1 = dr_energy(inner_stem, inner_stem) + dri_energy(multi_inner_stem, multi_inner_stem);
  }

  //std::cout << "7_a:" << x_0 << before_last_ss_dangle_energy_1 << " + " << last_ss_dangle_energy_1 << " + " << termau_energy(inner_stem,inner_stem) << " <> " << before_last_ss_dangle_energy_0 << " + " << last_ss_dangle_energy_0 << " + " << additional_energy_0 << " + " << termau_energy(x_0_lastStem,x_0_lastStem) << std::endl;
  if ( \
       ( !_shouldermin && ((before_last_ss_dangle_energy_1 + last_ss_dangle_energy_1 + termau_energy(inner_stem,inner_stem)) <= (before_last_ss_dangle_energy_0 + last_ss_dangle_energy_0 + additional_energy_0 + termau_energy(x_0_lastStem,x_0_lastStem))) ) \
       || ( _shouldermin && ((before_last_ss_dangle_energy_1 + last_ss_dangle_energy_1 + termau_energy(inner_stem,inner_stem)) < (before_last_ss_dangle_energy_0 + last_ss_dangle_energy_0 + additional_energy_0 + termau_energy(x_0_lastStem,x_0_lastStem))) ) \
     ) {
    lmCompliant = false;
  }
}




if (lmCompliant) {
  //7_d
  // try to ADD a bp
  //     |------------ans------------|
  //     (....((...))...((...)).....)  old
  //     (.a(b((...))c)d((...)).....)  new
  // including case
  //     (.......((.......))...) old
  //     (.(.....((.......)).).) new


  // if dangle bases exist on both sides
  int first_ss_dangle_energy_0 = 0;
  int next_ss_dangle_energy_0 = 0;
  if ((x_0.second.outermost_initstem_i - x_0_subword.i) == 1) {
    first_ss_dangle_energy_0 = min(dli_energy(multi_inner_stem, multi_inner_stem), dl_energy(x_0_firstStem, x_0_firstStem));
  } else if ((x_0.second.outermost_initstem_i - x_0_subword.i) > 1) {
    first_ss_dangle_energy_0 = dli_energy(multi_inner_stem, multi_inner_stem) + dl_energy(x_0_firstStem, x_0_firstStem);
  }
  if ((x_0.second.next_ss_j - x_0.second.next_ss_i) == 1) {
    next_ss_dangle_energy_0 = min(dr_energy(x_0_firstStem, x_0_firstStem), dl_energy(x_0.second.secondStem, x_0.second.secondStem));
  } else if ((x_0.second.next_ss_j - x_0.second.next_ss_i) > 1) {
    next_ss_dangle_energy_0 = dr_energy(x_0_firstStem, x_0_firstStem) + dl_energy(x_0.second.secondStem, x_0.second.secondStem);
  }

  int first_ss_dangle_energy_1 = 0;
  int next_ss_dangle_energy_1 = 0;
  additional_energy_1 = 0;//int additional_energy_1 = 0;
  //TUSubsequence extended_stem;
  for (unsigned int first_ss_pos = x_0_subword.i; first_ss_pos < x_0.second.outermost_initstem_i; first_ss_pos++) {
    if (!lmCompliant) {
      break;
    }
    for (unsigned int next_ss_pos = x_0.second.next_ss_i; next_ss_pos < x_0.second.next_ss_j; next_ss_pos++) {
      if (basepairing(t_0_seq, first_ss_pos, next_ss_pos+1)) {
	extended_stem = REGION(t_0_seq,first_ss_pos,next_ss_pos+1);
	if (loop_complete_table_energy.is_tabulated(first_ss_pos, x_0.second.outermost_initstem_i, x_0.second.next_ss_i, next_ss_pos+1)) {
	  additional_energy_1 = loop_complete_table_energy.get(first_ss_pos, x_0.second.outermost_initstem_i, x_0.second.next_ss_i, next_ss_pos+1); 
	} else {
	  if ((x_0.second.outermost_initstem_i - first_ss_pos) == 1 ) {   //b
	    if ((next_ss_pos - x_0.second.next_ss_i) == 0) {       //c
	      additional_energy_1 = sr_energy(extended_stem, extended_stem);
	    } else if ((next_ss_pos - x_0.second.next_ss_i) > 0) { //c
	      additional_energy_1 = br_energy(extended_stem, REGION(t_0_seq,(unsigned int)x_0.second.next_ss_i,next_ss_pos));
	    }
	  } else if ((x_0.second.outermost_initstem_i - first_ss_pos) > 1 ) {    //b
	    if ((next_ss_pos - x_0.second.next_ss_i) == 0) {               //c
	      additional_energy_1 = bl_energy(REGION(t_0_seq, first_ss_pos+1, (unsigned int)x_0.second.outermost_initstem_i), extended_stem);
	    } else if ((next_ss_pos - x_0.second.after_next_ss_i) > 0) {         //c
	      additional_energy_1 = il_energy(REGION(t_0_seq, first_ss_pos+1, (unsigned int)x_0.second.outermost_initstem_i), REGION(t_0_seq,(unsigned int)x_0.second.next_ss_i,next_ss_pos));
	    }  
	  }

	  loop_complete_table_energy.set(first_ss_pos, x_0.second.outermost_initstem_i, x_0.second.next_ss_i, next_ss_pos+1, additional_energy_1);
	}

	if ((first_ss_pos - x_0_subword.i) == 1 ) {    //a
	  first_ss_dangle_energy_1 = min(dli_energy(multi_inner_stem, multi_inner_stem), dl_energy(extended_stem, extended_stem));       
	} else if ((first_ss_pos - x_0_subword.i) > 1 ) {
	  first_ss_dangle_energy_1 = dli_energy(multi_inner_stem, multi_inner_stem) + dl_energy(extended_stem, extended_stem);
	} else {
	  first_ss_dangle_energy_1 = 0;
	}
	if ((x_0.second.next_ss_j - next_ss_pos) == 2) {  //d
	  next_ss_dangle_energy_1 = min(dr_energy(extended_stem, extended_stem), dl_energy(x_0.second.secondStem, x_0.second.secondStem));
	} else if ((x_0.second.next_ss_j - next_ss_pos) > 2) {
	  next_ss_dangle_energy_1 = dr_energy(extended_stem, extended_stem) + dl_energy(x_0.second.secondStem, x_0.second.secondStem);
	} else {
	  next_ss_dangle_energy_1 = 0;
	}

	//std::cout << "7d_ml("<<first_ss_pos<<","<<next_ss_pos<<"): " << ans << first_ss_dangle_energy_1 <<"+"<< next_ss_dangle_energy_1 <<"+"<< additional_energy_1 <<"+"<<termau_energy(extended_stem,extended_stem)<<"<>"<< first_ss_dangle_energy_0 <<"+"<< next_ss_dangle_energy_0 <<"+"<< termau_energy(x_0_firstStem,x_0_firstStem) << std::endl;
	if ( \
	     ( !_shouldermin && ((first_ss_dangle_energy_1 + next_ss_dangle_energy_1 + additional_energy_1 + termau_energy(extended_stem,extended_stem)) <= (first_ss_dangle_energy_0 + next_ss_dangle_energy_0 + termau_energy(x_0_firstStem,x_0_firstStem))) ) \
	     || ( _shouldermin && ((first_ss_dangle_energy_1 + next_ss_dangle_energy_1 + additional_energy_1 + termau_energy(extended_stem,extended_stem)) < (first_ss_dangle_energy_0 + next_ss_dangle_energy_0 + termau_energy(x_0_firstStem,x_0_firstStem))) )
	   ) {
	  lmCompliant = false;
	  break;
	}
      }
    }
    
    
    if (lmCompliant) {
      //7_e_A
      //     ((....((...))...((...))...((...))...((...))...))  old
      //     ((.a(b((...))...((...))...((...))...((...))c)d))  new
      //      D  A  7_a,   ml_comps, ml_comps1,    7_d    A D
      // compared with closed_non_ml
      //     ..((...((...))...))
      //        D A D      D A D
      //((...((....((...))...((...))...((...))...((...))...))...))  old
      // D A D                                               D A D
      for (unsigned int last_ss_pos = x_0.second.outermost_initstem_j; last_ss_pos < x_0_subword.j; last_ss_pos++) {
	if (basepairing(t_0_seq, first_ss_pos, last_ss_pos+1)) {
	  extended_stem = REGION(t_0_seq,first_ss_pos,last_ss_pos+1);
	  if (loop_complete_table_energy.is_tabulated(x_0_subword.i-1, first_ss_pos, last_ss_pos+1, x_0_subword.j+1)) {
	    //std::cout << "(get from table)";
	    additional_energy_1 = loop_complete_table_energy.get(x_0_subword.i-1, first_ss_pos, last_ss_pos+1, x_0_subword.j+1); 
	  } else {
	    if (first_ss_pos == x_0_subword.i) {        //a
	      if (x_0_subword.j == (last_ss_pos + 1) ) {       //d
                //std::cout << "(sr_energy)";
		additional_energy_1 = sr_energy(multi_inner_stem, multi_inner_stem);
	      } else if (x_0_subword.j > (last_ss_pos + 1)) {  //d
                //std::cout << "(br_energy)";
		additional_energy_1 = br_energy(multi_inner_stem, REGION(t_0_seq,last_ss_pos+1,x_0_subword.j));
	      }
	    } else if (first_ss_pos > x_0_subword.i) {  //a
	      if (x_0_subword.j == (last_ss_pos + 1))          //d
                //std::cout << "(bl_energy)";
		additional_energy_1 = bl_energy(REGION(t_0_seq, x_0_subword.i, first_ss_pos), multi_inner_stem);
	      if (x_0_subword.j > (last_ss_pos + 1)) {         //d
		//std::cout << "7e_ml" << ans << "," << x_0_subword.i << "," << first_ss_pos << "," << last_ss_pos+1 << "," << x_0_subword.j << std::endl;
	        //std::cout << "(il_energy)";
		additional_energy_1 = il_energy(REGION(t_0_seq, x_0_subword.i, first_ss_pos), REGION(t_0_seq,last_ss_pos+1,x_0_subword.j));
	      }
	    }

	    loop_complete_table_energy.set(x_0_subword.i-1, first_ss_pos, last_ss_pos+1, x_0_subword.j+1, additional_energy_1);
	  }

	  
	  if ((x_0.second.outermost_initstem_i - first_ss_pos) == 2 ) {    //b    
	    first_ss_dangle_energy_1 = min(dli_energy(extended_stem, extended_stem), dl_energy(x_0_firstStem, x_0_firstStem));       
	  } else if ((x_0.second.outermost_initstem_i - first_ss_pos) > 2 ) { 
	    first_ss_dangle_energy_1 = dli_energy(extended_stem, extended_stem) + dl_energy(x_0_firstStem, x_0_firstStem);
	  } else {
	    first_ss_dangle_energy_1 = 0;
	  }
	  if ((last_ss_pos - x_0.second.outermost_initstem_j) == 1) {  //c
	    last_ss_dangle_energy_1 = min(dr_energy(x_0_lastStem,x_0_lastStem), dri_energy(extended_stem, extended_stem));
	  } else if ((last_ss_pos - x_0.second.outermost_initstem_j) > 1) {
	    last_ss_dangle_energy_1 = dr_energy(x_0_lastStem,x_0_lastStem) + dri_energy(extended_stem, extended_stem);
	  } else {
	    last_ss_dangle_energy_1 = 0;
	  }

	  //std::cout << "7_e_A:" << first_ss_pos <<","<< last_ss_pos+1 << x_0 << first_ss_dangle_energy_1 <<"+"<< last_ss_dangle_energy_1 <<"+"<< additional_energy_1 <<"+"<< termau_energy(extended_stem,extended_stem) <<"<>"<< first_ss_dangle_energy_0 <<"+"<< last_ss_dangle_energy_0 <<"+"<< termau_energy(multi_inner_stem,multi_inner_stem) << std::endl;
	  if ( \
	       ( !_shouldermin && ((first_ss_dangle_energy_1 + last_ss_dangle_energy_1 + additional_energy_1 + termau_energy(extended_stem,extended_stem)) <= (first_ss_dangle_energy_0 + last_ss_dangle_energy_0 + termau_energy(multi_inner_stem,multi_inner_stem))) ) \
	       || ( _shouldermin && ((first_ss_dangle_energy_1 + last_ss_dangle_energy_1 + additional_energy_1 + termau_energy(extended_stem,extended_stem)) < (first_ss_dangle_energy_0 + last_ss_dangle_energy_0 + termau_energy(multi_inner_stem,multi_inner_stem))) ) \
	     ) {
	    lmCompliant = false;
	    break;
	  }
	}
      }    
    }
  }


  //7_d_
  // try to DEL a bp
  //     |----------ans---------|
  //    (.((...))...((...)).....)  old
  //    (..(...)....((...)).....)  old
  if (lmCompliant) {
    int additional_energy_0 = 0;  // NOTE: redefinition RISKY
    TUSubsequence inner_stem = REGION(t_0_seq,(unsigned int)(x_0.second.outermost_initstem_i+1),(unsigned int)(x_0.second.next_ss_i-1));
    if (loop_complete_table_energy.is_tabulated((unsigned int)x_0.second.outermost_initstem_i, (unsigned int)(x_0.second.outermost_initstem_i+1), (unsigned int)(x_0.second.next_ss_i-1), (unsigned int)x_0.second.next_ss_i)) {
      additional_energy_0 = loop_complete_table_energy.get((unsigned int)x_0.second.outermost_initstem_i, (unsigned int)(x_0.second.outermost_initstem_i+1), (unsigned int)(x_0.second.next_ss_i-1), (unsigned int)x_0.second.next_ss_i); 
    } else {
      additional_energy_0 = sr_energy(x_0_firstStem, x_0_firstStem);

      loop_complete_table_energy.set((unsigned int)x_0.second.outermost_initstem_i, (unsigned int)(x_0.second.outermost_initstem_i+1), (unsigned int)(x_0.second.next_ss_i-1), (unsigned int)x_0.second.next_ss_i, additional_energy_0);
    }

    if ((x_0.second.outermost_initstem_i - x_0_subword.i) == 0) {  //a
      first_ss_dangle_energy_1 = min(dli_energy(multi_inner_stem, multi_inner_stem), dl_energy(inner_stem, inner_stem));
    } else {
      first_ss_dangle_energy_1 = dli_energy(multi_inner_stem, multi_inner_stem) + dl_energy(inner_stem, inner_stem);
    }
    if ((x_0.second.next_ss_j - x_0.second.next_ss_i) == 0) {  //d
      next_ss_dangle_energy_1 = min(dr_energy(inner_stem, inner_stem), dl_energy(x_0.second.secondStem, x_0.second.secondStem));
    } else {
      next_ss_dangle_energy_1 = dr_energy(inner_stem, inner_stem) + dl_energy(x_0.second.secondStem, x_0.second.secondStem);
    }

    if ( \
         ( !_shouldermin && ((first_ss_dangle_energy_1 + next_ss_dangle_energy_1 + termau_energy(inner_stem,inner_stem)) <= (first_ss_dangle_energy_0 + next_ss_dangle_energy_0 + additional_energy_0 + termau_energy(x_0_firstStem,x_0_firstStem))) ) \
         || ( _shouldermin && ((first_ss_dangle_energy_1 + next_ss_dangle_energy_1 + termau_energy(inner_stem,inner_stem)) < (first_ss_dangle_energy_0 + next_ss_dangle_energy_0 + additional_energy_0 + termau_energy(x_0_firstStem,x_0_firstStem))) ) \
       ) {
      lmCompliant = false;
    } 
  }


  //7_e_D
  //     ((....((...))...((...))...((...))...((...))...))  old
  //     (.....((...))...((...))...((...))...((...))....)  new
  if (lmCompliant) {

    int srE_before_delete = 0;
    if (loop_complete_table_energy.is_tabulated(x_0.second.subword.i, x_0.second.subword.i+1, x_0.second.subword.j-1, x_0.second.subword.j)) {
      srE_before_delete = loop_complete_table_energy.get(x_0.second.subword.i, x_0.second.subword.i+1, x_0.second.subword.j-1, x_0.second.subword.j);
    } else {
      srE_before_delete = sr_energy(x_0.second.subword, x_0.second.subword);
      loop_complete_table_energy.set(x_0.second.subword.i, x_0.second.subword.i+1, x_0.second.subword.j-1, x_0.second.subword.j, srE_before_delete);
    }

    if ((x_0.second.outermost_initstem_i - x_0_subword.i) == 0) {  //a
      first_ss_dangle_energy_1 = min(dli_energy(x_0.second.subword, x_0.second.subword), dl_energy(x_0_firstStem, x_0_firstStem));
    } else {
      first_ss_dangle_energy_1 = dli_energy(x_0.second.subword, x_0.second.subword) + dl_energy(x_0_firstStem, x_0_firstStem);
    }
    if ((x_0_subword.j - x_0.second.outermost_initstem_j) == 0) {  //d
      last_ss_dangle_energy_1 = min(dr_energy(x_0_lastStem, x_0_lastStem), dri_energy(x_0.second.subword, x_0.second.subword));
    } else {
      last_ss_dangle_energy_1 = dr_energy(x_0_lastStem, x_0_lastStem) + dri_energy(x_0.second.subword, x_0.second.subword);
    }
    
    if ( \
         ( !_shouldermin && ((first_ss_dangle_energy_1 + last_ss_dangle_energy_1 + termau_energy(x_0.second.subword,x_0.second.subword)) <= (first_ss_dangle_energy_0 + last_ss_dangle_energy_0 + srE_before_delete + termau_energy(multi_inner_stem,multi_inner_stem))) ) \
         || ( _shouldermin && ((first_ss_dangle_energy_1 + last_ss_dangle_energy_1 + termau_energy(x_0.second.subword,x_0.second.subword)) < (first_ss_dangle_energy_0 + last_ss_dangle_energy_0 + srE_before_delete + termau_energy(multi_inner_stem,multi_inner_stem))) ) \
       ) {
      lmCompliant = false;
    } 
  }
}
  
if (lmCompliant) {
  push_back( answers, x_0);
}

  
    }
  }
  erase( a_0);
  
} else {
  append( answers, ret_5); 
}  
  
  
  
  
  
  
  hash_filter( answers);
  finalize( answers);
  closed_table.set( t_0_i, t_0_j, answers);
  return closed_table.get(t_0_i, t_0_j);
}

hhpp_hash_h &  hhpp::nt_dangle(unsigned int t_0_i, unsigned int t_0_j)
{
  if (dangle_table.is_tabulated(t_0_i, t_0_j))
    {
      return dangle_table.get(t_0_i, t_0_j);
    }

  hhpp_hash_h answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 8))
  {
    TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
    TUSubsequence a_0 = ret_1;
    if (is_not_empty(a_0))
    {
      hhpp_hash_h ret_2 = nt_initstem((t_0_i + 1), t_0_j);
      hhpp_hash_h a_1 = ret_2;
      if (is_not_empty(a_1))
        {
          for (hhpp_hash_h::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
            std::pair<Rope, mfeanswer_v4>  x_1 = *x_1_itr;
//9+  check DELETING is-bp
bool lmCompliant = true;

if (_locallymin) {
TUSubsequence inner_stem = REGION(t_0_seq,x_1.second.subword.i+1,x_1.second.subword.j-1);
if (!x_1.second.prevIsMl) {
  if ( \
       ( !_shouldermin && ((termau_energy(inner_stem,inner_stem) + dl_energy(inner_stem, inner_stem) + dr_energy(inner_stem, inner_stem) ) <= (sr_energy(x_1.second.subword,x_1.second.subword) + termau_energy(x_1.second.subword,x_1.second.subword) + dl_energy(x_1.second.subword,x_1.second.subword))) ) \
       || ( _shouldermin && ((termau_energy(inner_stem,inner_stem) + dl_energy(inner_stem, inner_stem) + dr_energy(inner_stem, inner_stem) ) < (sr_energy(x_1.second.subword,x_1.second.subword) + termau_energy(x_1.second.subword,x_1.second.subword) + dl_energy(x_1.second.subword,x_1.second.subword))) ) \
     ) {
    lmCompliant = false;
  }
} else {
  // TODO: check this position will speed up the program
}
}

if (lmCompliant) {
  std::pair<Rope, mfeanswer_v4>  ans = edl(a_0, x_1);
  if (ans.second.energy <= _thresh)  // rule1
    {
      push_back( answers, ans);
    }
}
//             std::pair<Rope, mfeanswer_v4>  ans = edl(a_0, x_1);
//             if (ans.second.energy <= _thresh)  // rule1
//               {
//                 push_back( answers, ans);
//               }

          }
        }

      erase( a_1);
    }

    erase( a_0);
  }


  if (((t_0_j - t_0_i) >= 8))
  {
    TUSubsequence ret_5 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
    TUSubsequence a_3 = ret_5;
    if (is_not_empty(a_3))
    {
      hhpp_hash_h ret_4 = nt_initstem(t_0_i, (t_0_j - 1));
      hhpp_hash_h a_2 = ret_4;
      if (is_not_empty(a_2))
        {
          for (hhpp_hash_h::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
            std::pair<Rope, mfeanswer_v4>  x_2 = *x_2_itr;
//9+  check DELETING is-bp
bool lmCompliant = true;

if (_locallymin) {
TUSubsequence inner_stem = REGION(t_0_seq,x_2.second.subword.i+1,x_2.second.subword.j-1);

// isML .(((((....)))..((....))...)).
if (!x_2.second.prevIsMl) {
  //std::cout << "9+edr:" << x_2 << (termau_energy(inner_stem,inner_stem) + dl_energy(inner_stem, inner_stem) + dr_energy(inner_stem, inner_stem) ) << " ~ " <<  (sr_energy(x_2.second.subword,x_2.second.subword) + termau_energy(x_2.second.subword,x_2.second.subword) + dr_energy(x_2.second.subword,x_2.second.subword)) << std::endl;
  if ( \
       ( !_shouldermin && ((termau_energy(inner_stem,inner_stem) + dl_energy(inner_stem, inner_stem) + dr_energy(inner_stem, inner_stem) ) <= (sr_energy(x_2.second.subword,x_2.second.subword) + termau_energy(x_2.second.subword,x_2.second.subword) + dr_energy(x_2.second.subword,x_2.second.subword))) ) \
       || ( _shouldermin && ((termau_energy(inner_stem,inner_stem) + dl_energy(inner_stem, inner_stem) + dr_energy(inner_stem, inner_stem) ) < (sr_energy(x_2.second.subword,x_2.second.subword) + termau_energy(x_2.second.subword,x_2.second.subword) + dr_energy(x_2.second.subword,x_2.second.subword))) ) \
     ) {
    lmCompliant = false;
  }
}
}

if (lmCompliant) {
  std::pair<Rope, mfeanswer_v4>  ans = edr(x_2, a_3);
  if (ans.second.energy <= _thresh)  // rule1
    {
      push_back( answers, ans);
    }
}
//             std::pair<Rope, mfeanswer_v4>  ans = edr(x_2, a_3);
//             if (ans.second.energy <= _thresh)  // rule1
//               {
//                 push_back( answers, ans);
//               }

          }
        }

      erase( a_2);
    }

    erase( a_3);
  }


  if (((t_0_j - t_0_i) >= 9))
  {
    TUSubsequence ret_9 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
    TUSubsequence a_6 = ret_9;
    if (is_not_empty(a_6))
    {
      TUSubsequence ret_7 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
      TUSubsequence a_4 = ret_7;
      if (is_not_empty(a_4))
      {
        hhpp_hash_h ret_8 = nt_initstem((t_0_i + 1), (t_0_j - 1));
        hhpp_hash_h a_5 = ret_8;
        if (is_not_empty(a_5))
          {
            for (hhpp_hash_h::iterator x_5_itr = a_5.ref().begin(); x_5_itr!=a_5.ref().end(); ++x_5_itr){
              std::pair<Rope, mfeanswer_v4>  x_5 = *x_5_itr;
//9+  check DELETING is-bp
bool lmCompliant = true;

if (_locallymin) {
TUSubsequence inner_stem = REGION(t_0_seq,x_5.second.subword.i+1,x_5.second.subword.j-1);
if (!x_5.second.prevIsMl) {
  //std::cout << "9+edlr:" << x_5 << (termau_energy(inner_stem,inner_stem) + dl_energy(inner_stem, inner_stem) + dr_energy(inner_stem, inner_stem) ) << " ~ " <<  (sr_energy(x_5.second.subword,x_5.second.subword) + termau_energy(x_5.second.subword,x_5.second.subword) + dr_energy(x_5.second.subword,x_5.second.subword) + dl_energy(x_5.second.subword,x_5.second.subword)) << std::endl;
  if ( \
       ( !_shouldermin && ((termau_energy(inner_stem,inner_stem) + dl_energy(inner_stem, inner_stem) + dr_energy(inner_stem, inner_stem) ) <= (sr_energy(x_5.second.subword,x_5.second.subword) + termau_energy(x_5.second.subword,x_5.second.subword) + dr_energy(x_5.second.subword,x_5.second.subword) + dl_energy(x_5.second.subword,x_5.second.subword))) ) \
       || ( _shouldermin && ((termau_energy(inner_stem,inner_stem) + dl_energy(inner_stem, inner_stem) + dr_energy(inner_stem, inner_stem) ) < (sr_energy(x_5.second.subword,x_5.second.subword) + termau_energy(x_5.second.subword,x_5.second.subword) + dr_energy(x_5.second.subword,x_5.second.subword) + dl_energy(x_5.second.subword,x_5.second.subword))) ) \
     ) {
    //std::cout << "true" << std::endl;
    lmCompliant = false;
  }
}
}
if (lmCompliant) {
  std::pair<Rope, mfeanswer_v4>  ans = edlr(a_4, x_5, a_6);
  if (ans.second.energy <= _thresh)  // rule1
    {
      push_back( answers, ans);
    }
}
//               std::pair<Rope, mfeanswer_v4>  ans = edlr(a_4, x_5, a_6);
//               if (ans.second.energy <= _thresh)  // rule1
//                 {
//                   push_back( answers, ans);
//                 }

            }
          }

        erase( a_5);
      }

      erase( a_4);
    }

    erase( a_6);
  }


  if (((t_0_j - t_0_i) >= 7))
  {
    hhpp_hash_h ret_11 = nt_initstem(t_0_i, t_0_j);
    hhpp_hash_h a_7 = ret_11;
    if (is_not_empty(a_7))
      {
        for (hhpp_hash_h::iterator x_7_itr = a_7.ref().begin(); x_7_itr!=a_7.ref().end(); ++x_7_itr){
          std::pair<Rope, mfeanswer_v4>  x_7 = *x_7_itr;
//9+  check DELETING is-bp
bool lmCompliant = true;

if (_locallymin) {
TUSubsequence inner_stem = REGION(t_0_seq,x_7.second.subword.i+1,x_7.second.subword.j-1);
if (!x_7.second.prevIsMl) {
  if ( \
       ( !_shouldermin && ((termau_energy(inner_stem,inner_stem) + dl_energy(inner_stem, inner_stem) + dr_energy(inner_stem, inner_stem) ) <= (sr_energy(x_7.second.subword,x_7.second.subword) + termau_energy(x_7.second.subword,x_7.second.subword))) ) \
       || ( _shouldermin && ((termau_energy(inner_stem,inner_stem) + dl_energy(inner_stem, inner_stem) + dr_energy(inner_stem, inner_stem) ) < (sr_energy(x_7.second.subword,x_7.second.subword) + termau_energy(x_7.second.subword,x_7.second.subword))) ) \
     ) {
    lmCompliant = false;
  }
}
}

if (lmCompliant) {
  std::pair<Rope, mfeanswer_v4>  ans = drem(x_7);
  if (ans.second.energy <= _thresh)  // rule1
    {
      push_back( answers, ans);
    }
}
//           std::pair<Rope, mfeanswer_v4>  ans = drem(x_7);
//           if (ans.second.energy <= _thresh)  // rule1
//             {
//               push_back( answers, ans);
//             }

        }
      }

    erase( a_7);
  }

  hash_filter( answers);
  finalize( answers);
  dangle_table.set( t_0_i, t_0_j, answers);
  return dangle_table.get(t_0_i, t_0_j);
}


/////////// -1: nt_hairpin_filter_helper_2 /////////////////
////////////////////////////////////////////
std::pair<Rope, mfeanswer_v4>  &  hhpp::nt_hairpin_complete(unsigned int t_0_i, unsigned int t_0_j)
{ //-4 HTC
  if (hairpin_table_complete.is_tabulated(t_0_i, t_0_j))
    {
      //-4 HTC
      return hairpin_table_complete.get(t_0_i, t_0_j);
    }

  std::pair<Rope, mfeanswer_v4>  answers;
  empty( answers);
  std::pair<Rope, mfeanswer_v4>  ret_0;
  if (((t_0_j - t_0_i) >= 5))
    {
      if (basepairing(t_0_seq, t_0_i, t_0_j))
      {
        TUSubsequence ret_3 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_2 = ret_3;
        if (is_not_empty(a_2))
        {
          TUSubsequence ret_2;
          if (minsize(t_0_seq, (t_0_i + 1), (t_0_j - 1), 3))
            {
              ret_2 = REGION(t_0_seq, (t_0_i + 1), (t_0_j - 1));
            }

          else
            {
              empty( ret_2);
            }

          TUSubsequence a_1 = ret_2;
          if (is_not_empty(a_1))
          {
            TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
            TUSubsequence a_0 = ret_1;
            if (is_not_empty(a_0))
              {
                ret_0 = hl(a_0, a_1, a_2);
              }

            else
              {
                empty( ret_0);
              }

            erase( a_0);
          }

          else
            {
              empty( ret_0);
            }

          erase( a_1);
        }

        else
          {
            empty( ret_0);
          }

        erase( a_2);
      }

      else
      {
        empty( ret_0);
        empty( ret_0);
      }

    }

  else
    {
      empty( ret_0);
    }

  answers = ret_0;
  //-4 HTC
  hairpin_table_complete.set( t_0_i, t_0_j, answers);
  //-4 HTC
  return hairpin_table_complete.get(t_0_i, t_0_j);
}

//nt_hairpin_filter_helper_1: hairpin_table_complete () for single bp -----------|
//nt_hairpin_filter_helper_2:     calculated by 2 ::nt_hairpin_complete ---------|- help filtering inappropriate hairpin and store them in hairpin_table
//nt_hairpin_filter_helper_3: loop_complete_table_energy (4D) for single bp-----|

///////////0: nt_hairpin_filter /////////////////
/////////////////////////////////////////////////
//0123456789012345678901
//....((.......))......
//     |--------|
//0_b: try to add a basepair between 6 and 13
//0_c: try to delete the bp(5,14)
// TODO: try to use inner_stem in 0-4
/////////////////////////////////////////////////
std::pair<Rope, mfeanswer_v4>  hhpp::nt_hairpin(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 7))
    {
      return BRope_firstG_mfeanswer_v4_secondG_E_zero;
    }

  std::pair<Rope, mfeanswer_v4>  answers;
  empty( answers);
  std::pair<Rope, mfeanswer_v4>  ret_0;
  if (((t_0_j - t_0_i) >= 7))
    {
      if (((!_exact) && pairing_center_at(t_0_seq, t_0_i, t_0_j, _match_tokens_h, _theta)) || ((_exact) && exact_pairing_center_at(t_0_seq, t_0_i, t_0_j, _match_tokens_h)))  // added
      {                                                                                                                                                               // added
        TUSubsequence ret_5 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_4 = ret_5;
        if (is_not_empty(a_4))
        {
          TUSubsequence ret_4 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
          TUSubsequence a_3 = ret_4;
          if (is_not_empty(a_3))
          {
            TUSubsequence ret_3;
            if (minsize(t_0_seq, (t_0_i + 2), (t_0_j - 2), 3))
              {
                ret_3 = REGION(t_0_seq, (t_0_i + 2), (t_0_j - 2));
              }

            else
              {
                empty( ret_3);
              }

            TUSubsequence a_2 = ret_3;
            if (is_not_empty(a_2))
            {
              TUSubsequence ret_2 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
              TUSubsequence a_1 = ret_2;
              if (is_not_empty(a_1))
              {
                TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
                TUSubsequence a_0 = ret_1;
                if (is_not_empty(a_0))
                  {
                    ret_0 = hl(a_0, a_1, a_2, a_3, a_4);
bool lmCompliant = true;

if (_locallymin) {
std::pair<Rope, mfeanswer_v4> innerRegion = hl(a_1, a_2, a_3);
//0_b
if ((a_3.j - a_1.i) >= 7) {
  //       5 
  //     4   6
  //    3 *** 7
  //    2 *** 8
  //          9
 if (basepairing(t_0_seq, a_1.i+1, a_3.j-1)) {
//    if ((nt_hairpin_complete(a_1.i+1,a_3.j-1).second.energy  + sr_energy(innerRegion.second.firstStem,innerRegion.second.firstStem)) <= innerRegion.second.energy) {
//      lmCompliant = false;
//    }
  if (!loop_complete_table_energy.is_tabulated(a_1.i, a_1.i+1, a_3.j-1, a_3.j)) {
    loop_complete_table_energy.set(a_1.i, a_1.i+1, a_3.j-1, a_3.j, sr_energy(innerRegion.second.firstStem,innerRegion.second.firstStem));
  }
  if ( \
       ( !_shouldermin && ((nt_hairpin_complete(a_1.i+1, a_3.j-1).second.energy  + loop_complete_table_energy.get(a_1.i, a_1.i+1, a_3.j-1, a_3.j)) <= innerRegion.second.energy) ) \
       || ( _shouldermin && ((nt_hairpin_complete(a_1.i+1, a_3.j-1).second.energy  + loop_complete_table_energy.get(a_1.i, a_1.i+1, a_3.j-1, a_3.j)) < innerRegion.second.energy) ) \
     ) {
    lmCompliant = false;
  }
 }
}
if (lmCompliant && ((a_3.j - a_1.i) >= 8)) {  // contains rightB
  //        ***************
  //        *             * <== REGION(t_0_seq,t_0_k_0+1,t_0_k_1-1)
  //    t_0_k_0 ***********
  //        *         t_0_k_1
  //        *             *  <-- rightB until here, therefore a_3.j-1
  //     a_1.i ************
  //                    a_3.j   
  //       5 
  //     4   6
  //    3 *** 7
  //    |     8
  //    2 *** 9
  //          10
  unsigned int t_0_k_0 = a_1.i+1;  //t_0_k_0=3
  for(unsigned int t_0_k_1 = (t_0_k_0+5); (t_0_k_1 <= (a_3.j-2)); ++t_0_k_1) {  //t_0_k_1=8
    if (basepairing(t_0_seq, t_0_k_0, t_0_k_1)) {
/*      if ((nt_hairpin_complete(t_0_k_0,t_0_k_1).second.energy  + br_energy(innerRegion.second.firstStem,REGION(t_0_seq,t_0_k_1,a_3.j-1))) <= innerRegion.second.energy) {
	lmCompliant = false;
	break;
      }*/ 
      if (!loop_complete_table_energy.is_tabulated(a_1.i, t_0_k_0, t_0_k_1, a_3.j)) {
	loop_complete_table_energy.set(a_1.i, t_0_k_0, t_0_k_1, a_3.j, br_energy(innerRegion.second.firstStem,REGION(t_0_seq,t_0_k_1,a_3.j-1)));
      }
      if ( \
	   ( !_shouldermin && ((nt_hairpin_complete(t_0_k_0,t_0_k_1).second.energy  + loop_complete_table_energy.get(a_1.i, t_0_k_0, t_0_k_1, a_3.j)) <= innerRegion.second.energy) ) \
	   || ( _shouldermin && ((nt_hairpin_complete(t_0_k_0,t_0_k_1).second.energy  + loop_complete_table_energy.get(a_1.i, t_0_k_0, t_0_k_1, a_3.j)) < innerRegion.second.energy) ) \
         ) {
	lmCompliant = false;
	break;
      }
    }
  }
}

if (lmCompliant && ((a_3.j - a_1.i) >= 8)) {  // contains leftB
  //       6 
  //     5   7
  //    4 *** 8
  //    3     |
  //    2 *** 9
  //          10
  unsigned int t_0_k_1 = a_3.j-1;  //t_0_k_1=9
  for(unsigned int t_0_k_0 = (a_1.i+2); (t_0_k_0 <= (a_3.j-6)); ++t_0_k_0) {  //t_0_k_0=4
    if (basepairing(t_0_seq, t_0_k_0, t_0_k_1)) {
//       if ((nt_hairpin_complete(t_0_k_0,t_0_k_1).second.energy  + bl_energy(REGION(t_0_seq,a_1.i+1,t_0_k_0),innerRegion.second.firstStem)) <= innerRegion.second.energy) {
// 	lmCompliant = false;
// 	break;
//       }
      if (!loop_complete_table_energy.is_tabulated(a_1.i, t_0_k_0, t_0_k_1, a_3.j)) {
	loop_complete_table_energy.set(a_1.i, t_0_k_0, t_0_k_1, a_3.j, bl_energy(REGION(t_0_seq,a_1.i+1,t_0_k_0),innerRegion.second.firstStem));
      }
      if ( \
	   ( !_shouldermin && ((nt_hairpin_complete(t_0_k_0,t_0_k_1).second.energy  + loop_complete_table_energy.get(a_1.i, t_0_k_0, t_0_k_1, a_3.j)) <= innerRegion.second.energy) ) \
	   || ( _shouldermin && ((nt_hairpin_complete(t_0_k_0,t_0_k_1).second.energy  + loop_complete_table_energy.get(a_1.i, t_0_k_0, t_0_k_1, a_3.j)) < innerRegion.second.energy) ) \
         ) {
	lmCompliant = false;
	break;
      }
    }
  }
}


//       6 
//     5   7
//    4 *** 8
//    3     9
//    2 *** 10
//          11

if (lmCompliant && ((a_3.j - a_1.i) >= 9)) {  // contains iloop
  for(unsigned int t_0_k_0 = (a_1.i+2); (t_0_k_0 <= (a_3.j-7)); ++t_0_k_0) {  //t_0_k_0=4
    if (lmCompliant == false) {
      break; 
    }
    for(unsigned int t_0_k_1 = (t_0_k_0+5); (t_0_k_1 <= (a_3.j-2)); ++t_0_k_1) {  //t_0_k_1=9
      if (basepairing(t_0_seq, t_0_k_0, t_0_k_1)) {
// 	if ((nt_hairpin_complete(t_0_k_0,t_0_k_1).second.energy  + il_energy(REGION(t_0_seq,a_1.i+1,t_0_k_0),REGION(t_0_seq,t_0_k_1,a_3.j-1))) <= innerRegion.second.energy) {
// 	  lmCompliant = false;
// 	  break;
// 	}
	// NOTE: using stored records to speed up; loop_complete_table_energy only store the energies
	if (!loop_complete_table_energy.is_tabulated(a_1.i, t_0_k_0, t_0_k_1, a_3.j)) {
	  loop_complete_table_energy.set(a_1.i, t_0_k_0, t_0_k_1, a_3.j, il_energy(REGION(t_0_seq,a_1.i+1,t_0_k_0),REGION(t_0_seq,t_0_k_1,a_3.j-1)));
	}
	if ( \
	     ( !_shouldermin && ((nt_hairpin_complete(t_0_k_0,t_0_k_1).second.energy  + loop_complete_table_energy.get(a_1.i, t_0_k_0, t_0_k_1, a_3.j)) <= innerRegion.second.energy) ) \
	     || ( _shouldermin && ((nt_hairpin_complete(t_0_k_0,t_0_k_1).second.energy  + loop_complete_table_energy.get(a_1.i, t_0_k_0, t_0_k_1, a_3.j)) < innerRegion.second.energy) ) \
	   ) {
	  lmCompliant = false;
	  break;
	}
      }
    } 
  }
}

//0_c
if (lmCompliant) {
  if ( \
       ( !_shouldermin && (nt_hairpin_complete(a_0.i,a_4.j).second.energy <= ret_0.second.energy) ) \
       || ( _shouldermin && (nt_hairpin_complete(a_0.i,a_4.j).second.energy < ret_0.second.energy) ) \
     ) {
    lmCompliant = false; 
  }
}
}

// && is_not_empty(ret_0)
if (!lmCompliant)
{
  empty( ret_0);
}
                  }

                else
                  {
                    empty( ret_0);
                  }

                erase( a_0);
              }

              else
                {
                  empty( ret_0);
                }

              erase( a_1);
            }

            else
              {
                empty( ret_0);
              }

            erase( a_2);
          }

          else
            {
              empty( ret_0);
            }

          erase( a_3);
        }

        else
          {
            empty( ret_0);
          }

        erase( a_4);
      }

      else
      {
        empty( ret_0);
        empty( ret_0);
      }

    }

  else
    {
      empty( ret_0);
    }

  answers = ret_0;
  return answers;
}

hhpp_hash_h hhpp::nt_iloop(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 13))
    {
      return LBRope_firstG_mfeanswer_v4_secondG_EMhdecl0x2c432e0_zero;
    }

  hhpp_hash_h answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 13))
    {
      if (stackpairing(t_0_seq, t_0_i, t_0_j))
      {
        TUSubsequence ret_8 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_7 = ret_8;
        if (is_not_empty(a_7))
        {
          TUSubsequence ret_7 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
          TUSubsequence a_6 = ret_7;
          if (is_not_empty(a_6))
          {
            TUSubsequence ret_2 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
            TUSubsequence a_1 = ret_2;
            if (is_not_empty(a_1))
            {
              TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
              TUSubsequence a_0 = ret_1;
              if (is_not_empty(a_0))
              {
                hhpp_hash_h ret_3;
                empty(ret_3);
                if ((((t_0_j - 2) - (t_0_i + 2)) >= 9))
                  {
                    for(                    unsigned int t_0_k_0 = ((t_0_i + 2) + 1); ((t_0_k_0 <= ((t_0_j - 2) - 8)) && (t_0_k_0 <= ((t_0_i + 2) + 30))); ++t_0_k_0)
                    {
                      for(                      unsigned int t_0_k_1 = ((((t_0_j - 2) - (t_0_k_0 + 7)) >= 30)) ? (((t_0_j - 2) - 30)) : ((t_0_k_0 + 7)); (t_0_k_1 <= ((t_0_j - 2) - 1)); ++t_0_k_1)
                      {
                        TUSubsequence ret_6;
                        if (maxsize(t_0_seq, t_0_k_1, (t_0_j - 2), 30))
                          {
                            ret_6 = REGION(t_0_seq, t_0_k_1, (t_0_j - 2));
                          }

                        else
                          {
                            empty( ret_6);
                          }

                        TUSubsequence a_5 = ret_6;
                        if (is_not_empty(a_5))
                        {
                          TUSubsequence ret_4;
                          if (maxsize(t_0_seq, (t_0_i + 2), t_0_k_0, 30))
                            {
                              ret_4 = REGION(t_0_seq, (t_0_i + 2), t_0_k_0);
                            }

                          else
                            {
                              empty( ret_4);
                            }

                          TUSubsequence a_3 = ret_4;
                          if (is_not_empty(a_3))
                          {
                            hhpp_hash_h ret_5 = nt_closed(t_0_k_0, t_0_k_1);
                            hhpp_hash_h a_4 = ret_5;
                            if (is_not_empty(a_4))
                              {
                                for (hhpp_hash_h::iterator x_4_itr = a_4.ref().begin(); x_4_itr!=a_4.ref().end(); ++x_4_itr){
                                  std::pair<Rope, mfeanswer_v4>  x_4 = *x_4_itr;
                                  std::pair<Rope, mfeanswer_v4>  ans = il(a_3, x_4, a_5);
                                  push_back( ret_3, ans);
                                }
                              }

                            erase( a_4);
                          }

                          erase( a_3);
                        }

                        erase( a_5);
                      }

                    }

                  }

                finalize( ret_3);
                hhpp_hash_h a_2 = ret_3;
                if (is_not_empty(a_2))
                  {
                    for (hhpp_hash_h::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                      std::pair<Rope, mfeanswer_v4>  x_2 = *x_2_itr;
                      std::pair<Rope, mfeanswer_v4>  ans = sp(a_0, a_1, x_2, a_6, a_7);
bool lmCompliant = true;
//std::cout << "1z: " << x_2 << std::endl;
if (_locallymin) {
//1_a
// NOTE: the prevSubword of ((..((...))..)) is ((...))
int iloopE_before_delete = 0;
if (loop_complete_table_energy.is_tabulated(a_1.i, x_2.second.prevSubword.i, x_2.second.prevSubword.j, a_6.j)) {
  iloopE_before_delete = loop_complete_table_energy.get(a_1.i, x_2.second.prevSubword.i, x_2.second.prevSubword.j, a_6.j);
} else {
  iloopE_before_delete = il_energy(REGION(t_0_seq,a_1.i+1,x_2.second.prevSubword.i),REGION(t_0_seq,x_2.second.prevSubword.j,a_6.j-1));
  loop_complete_table_energy.set(a_1.i, x_2.second.prevSubword.i, x_2.second.prevSubword.j, a_6.j, iloopE_before_delete);
}

int srE_before_delete = 0;
if (loop_complete_table_energy.is_tabulated(x_2.second.prevSubword.i, x_2.second.prevSubword.i+1, x_2.second.prevSubword.j-1, x_2.second.prevSubword.j)) {
  srE_before_delete = loop_complete_table_energy.get(x_2.second.prevSubword.i, x_2.second.prevSubword.i+1, x_2.second.prevSubword.j-1, x_2.second.prevSubword.j);
} else {
  srE_before_delete = sr_energy(x_2.second.prevSubword, x_2.second.prevSubword);
  loop_complete_table_energy.set(x_2.second.prevSubword.i, x_2.second.prevSubword.i+1, x_2.second.prevSubword.j-1, x_2.second.prevSubword.j, srE_before_delete);
}

int iloopE_after_delete = 0;
if (loop_complete_table_energy.is_tabulated(a_1.i, x_2.second.prevSubword.i+1, x_2.second.prevSubword.j-1, a_6.j)) {
  iloopE_after_delete = loop_complete_table_energy.get(a_1.i, x_2.second.prevSubword.i+1, x_2.second.prevSubword.j-1, a_6.j); 
} else {
  iloopE_after_delete = il_energy(REGION(t_0_seq,a_1.i+1,x_2.second.prevSubword.i+1),REGION(t_0_seq,x_2.second.prevSubword.j-1,a_6.j-1));
  loop_complete_table_energy.set(a_1.i, x_2.second.prevSubword.i+1, x_2.second.prevSubword.j-1, a_6.j, iloopE_after_delete);
}

//std::cout << "1a:" << x_2 << ": " << iloopE_after_delete << " ~ " << srE_before_delete <<" + "<< iloopE_before_delete << ans << std::endl;
if ( \
     ( !_shouldermin && (iloopE_after_delete <= (srE_before_delete + iloopE_before_delete)) ) \
     || ( _shouldermin && (iloopE_after_delete < (srE_before_delete + iloopE_before_delete)) ) \
   ) {
  lmCompliant = false;
}  



//1_b
if (lmCompliant) {
  // upstreamB and upstreamE is the region without including embedded basepair and closing basepair
  unsigned int upstreamB = a_1.i+1; //a_2.i; //(=2)
  unsigned int upstreamE = x_2.second.prevSubword.i-1;  //a_2.j-1; //(=5-1=4)  // upstreamE - upstreamB >= 1
  unsigned int downstreamB = x_2.second.prevSubword.j;  //a_4.i; //(=13)
  unsigned int downstreamE = a_6.j-2;   //a_4.j-1; //(=17-1=16)     // downstreamE - downstreamB >= 1
  //ASSERT_ERROR if ((upstreamE - upstreamB) >= 1)
  //ASSERT_ERROR   std::cout << upstreamE << "," << upstreamB << std::endl;
  //ASSERT_ERROR assert((upstreamE - upstreamB) >= 1);  // ==1 mean only a BASE    
  //ASSERT_ERROR assert((downstreamE - downstreamB) >= 1);



  for (unsigned int upstreamP = upstreamB; upstreamP <= upstreamE; upstreamP++) {  // 2 to 4  
    if (lmCompliant == false) {
      break;
    }  
    for (unsigned int downstreamP = downstreamB; downstreamP <= downstreamE; downstreamP++) {  // 13 to 16

      if (!basepairing(t_0_seq, upstreamP, downstreamP+1))
      {
	continue;
      }
//      std::cout << " upstreamB=" << upstreamB << " upstreamP=" << upstreamP << " upstreamE=" << upstreamE
//      << " downstreamB=" << downstreamB << " downstreamP=" << downstreamP << " downstreamE=" << downstreamE << std::endl;
      // add a stack
      unsigned int firstUp = upstreamP - upstreamB;       // 2 to 4    -2   0  = 0-2
      unsigned int secondUp = upstreamE - upstreamP;      // upstreamE=4    2 to 4  = 0-2
      unsigned int firstDown = downstreamP - downstreamB;  // 13 to 16   -13  =  3-0
      unsigned int secondDown = downstreamE - downstreamP; // downstreamE=16   13 to 16 = 3-0
      assert(firstUp >= 0);
      assert(secondUp >= 0);
      assert(firstDown >= 0);
      assert(secondDown >= 0);
      
  //        X          (X = some closed structure)
  //      |   |
  //      k - l        (k and l form the embedded basepair)
  //  k-1       l+1    (k-1 and l+1 are the unpaired bases in the internal loop)
  //   .         .
  //  i+1       j-1    (i+1 and j-1 are the unpaired bases in the internal loop)
  //      i - j        (i and j form the closing basepair)
  //      |   |
  //      5'  3'
  //   for (unsigned k = 0; k < a.seq->rows(); k++)
  //     energy += il_energy(a.seq->row(k), a.i-1, a.j, b.i-1, b.j);
  // 012345678901234567890
  // CUGCGGCUUUGGCUCUAGCC
  //  (....(....).....)      2,6,12,17  => REGION(t_0_seq,i+1,k),REGION(t_0_seq,l+1,j)
  //     
  //        X          (X = some closed structure)
  //      |   |
  //    l+1 - j-1      (l+1 and j-1 form the embedded basepair)
  //   l      |        (l is the last unpaired bases in the bulge loop)
  //   .      |
  //   k      |        (k is the first the unpaired bases in the bulge loop)
  //      i - j        (i and j form the closing basepair)
  //      |   |
  //      5'  3'
  //   for (unsigned k = 0; k < lr.seq->rows(); k++)
  //     energy += bl_energy(lr.seq->row(k), lr.i-1, lr.i, lr.j-1,   rb.j-1, rb.j-2);
  //                                REGION(t_0_seq,i+1,l+1(=the corner point left above)),REGION(t_0_seq,i,j+1)
  //   
      
      /*
    symmetric case to "bl_energy"
	X          (X = some closed structure)
      |   |
    i+1 - k-1      (i+1 and k-1 form the embedded basepair)
      |      k     (k is the first unpaired bases in the bulge loop)
      |      .
      |      l     (l is the last the unpaired bases in the bulge loop)
      i - j        (i and j form the closing basepair)
      |   |
      5'  3'
  */
  //   for (unsigned k = 0; k < lb.seq->rows(); k++)
  //     energy += br_energy(lb.seq->row(k), lb.i, rr.i, rr.j-1, rr.j, lb.i+1);
  //                                REGION(t_0_seq,i,j+1),REGION(t_0_seq,k,l+1(=j))
  //   

  //        X          (X = some closed structure)
  //      |   |
  //    i+1 - j-1      (i+1 and j-1 form the embedded basepair)
  //      |   |
  //      i - j        (i and j form the closing basepair)
  //      |   |
  //      5'  3'
  //   for (unsigned k = 0; k < a.seq->rows(); k++)
  //     energy += sr_energy(a.seq->row(k), a.i, b.j-1);
  //                                REGION(t_0_seq,i,j+1)

  // all together, constructing a region means take an index of beginning (first base of s is 0, second 1, ... from the 5' end)
  // and the end index should be added 1, for example the region of last figure should be REGION(t_0_seq, i, j+1),
  // the REGION from k to l in 3rd figure should be REGION(t_0_seq, k, l+1)=rregion, REGION(t_0_seq,i,j+1)=innerstem, bl energy is e.energy+br_energy(innerstem,rregion)
    

    
    
  //        X          (X = some closed structure)
  //      |   |
  //      k - l        (k and l form the embedded basepair)
  // uE 4 (secondUp) 13 dB (firstDown)
  // uP 3 ---------- 14 dP    
  // uB 2 (firstUp)  15 (secondDown)
  //                 16 dE
  //      i - j        (i and j form the closing basepair)
  //      |   |
  //      5'  3' 
  // check if ADDing a basepair will lower the energy

      //// calculate the E of structure above ////
      int energyAbove = 0;
      if (loop_complete_table_energy.is_tabulated(upstreamP, upstreamE+1, downstreamB, downstreamP+1)) {
	energyAbove = loop_complete_table_energy.get(upstreamP, upstreamE+1, downstreamB, downstreamP+1);
      } else {
	if (secondUp == 0 && firstDown == 0) { // the structure above is stack
	  energyAbove = sr_energy(REGION(t_0_seq,upstreamP,downstreamP+1),REGION(t_0_seq,upstreamP,downstreamP+1));
	}
	else if (secondUp == 0 && firstDown > 0) { // the structure above is rightB
						  //innerstem                      rregion
	  energyAbove = br_energy(REGION(t_0_seq,upstreamP,downstreamP+1),REGION(t_0_seq,downstreamB,downstreamP));
	}
	else if (secondUp > 0 && firstDown == 0) { // the structure below is leftB
						  //lregion                        innerstem
	  energyAbove = bl_energy(REGION(t_0_seq,upstreamP+1,upstreamE+1),REGION(t_0_seq,upstreamP,downstreamP+1));
	}
	else if (secondUp > 0 && firstDown > 0) { // the structure below is iloop
	  energyAbove = il_energy(REGION(t_0_seq,upstreamP+1,upstreamE+1),REGION(t_0_seq,downstreamB,downstreamP));
	} else {
	  std::cout << "mistake!" << std::endl;
	}
        loop_complete_table_energy.set(upstreamP, upstreamE+1, downstreamB, downstreamP+1,energyAbove);
      }

      
      //// calculate the E of structure below ////
      // A, A
      // A, C
      // B, A
      // B, C
      int energyBelow = 0;
      if (loop_complete_table_energy.is_tabulated(upstreamB-1, upstreamP, downstreamP+1, downstreamE+2)) {
	energyBelow = loop_complete_table_energy.get(upstreamB-1, upstreamP, downstreamP+1, downstreamE+2);
      } else {
	if (firstUp == 0 && secondDown == 0) { // the structure below is stack
	  energyBelow = sr_energy(REGION(t_0_seq,upstreamB-1,downstreamE+2),REGION(t_0_seq,upstreamB-1,downstreamE+2));
	}
	else if (firstUp == 0 && secondDown > 0) { // the structure below is rightB
						  //innerstem                      rregion
	  energyBelow = br_energy(REGION(t_0_seq,upstreamB-1,downstreamE+2),REGION(t_0_seq,downstreamP+1,downstreamE+1));
	}
	else if (firstUp > 0 && secondDown == 0) { // the structure below is leftB
						  //lregion                        innerstem
	  energyBelow = bl_energy(REGION(t_0_seq,upstreamB,upstreamP),REGION(t_0_seq,upstreamB-1,downstreamE+2));
	}
	else if (firstUp > 0 && secondDown > 0) { // the structure below is iloop
	  energyBelow = il_energy(REGION(t_0_seq,upstreamB,upstreamP),REGION(t_0_seq,downstreamP+1,downstreamE+1));
	} 
	loop_complete_table_energy.set(upstreamB-1, upstreamP, downstreamP+1, downstreamE+2, energyBelow);
      }

      //std::cout << "1b:"<< energyAbove<<"+" <<energyBelow <<"<"<<ans.second.energy << "    " << x_2 <<"vs" <<ans << "    "<< secondUp << "," << firstDown << "," << firstUp << "," << secondDown << std::endl;
      if ( \
	   ( !_shouldermin && ((energyAbove + energyBelow) <= iloopE_before_delete) ) \
	   || ( _shouldermin && ((energyAbove + energyBelow) < iloopE_before_delete) ) \
         ) {
        lmCompliant = false;
	break;
      }
    }
  }
}

//1_c
if (lmCompliant) {
  iloopE_after_delete = 0;
  if (loop_complete_table_energy.is_tabulated(a_0.i, x_2.second.prevSubword.i, x_2.second.prevSubword.j, a_7.j)) {
   iloopE_after_delete = loop_complete_table_energy.get(a_0.i, x_2.second.prevSubword.i, x_2.second.prevSubword.j, a_7.j); 
  } else {
    iloopE_after_delete = il_energy(REGION(t_0_seq,a_0.i+1,x_2.second.prevSubword.i),REGION(t_0_seq,x_2.second.prevSubword.j,a_7.j-1));
    loop_complete_table_energy.set(a_0.i, x_2.second.prevSubword.i, x_2.second.prevSubword.j, a_7.j, iloopE_after_delete);
  }

  srE_before_delete = 0;
  if (loop_complete_table_energy.is_tabulated(a_0.i, a_1.i, a_6.j, a_7.j)) {
    srE_before_delete = loop_complete_table_energy.get(a_0.i, a_1.i, a_6.j, a_7.j);
  } else {
    srE_before_delete = sr_energy(ans.second.subword, ans.second.subword);
    loop_complete_table_energy.set(a_0.i, a_1.i, a_6.j, a_7.j, srE_before_delete);
  }

  //std::cout << "1c:" << x_2 << ": " << iloopE_after_delete << " ~ " << srE_before_delete <<" + "<< iloopE_before_delete << ans << std::endl;
  if ( \
       ( !_shouldermin && (iloopE_after_delete <= (iloopE_before_delete + srE_before_delete)) ) \
       || ( _shouldermin && (iloopE_after_delete < (iloopE_before_delete + srE_before_delete)) ) \
     ) {
    lmCompliant = false;
  } 
}

//1_ss
if (lmCompliant) {
  if ((x_2.second.prevSubword.i - x_2.second.subword.i) >= 5) {   
    int first_ss_dangle_energy_1 = 0;
    int next_ss_dangle_energy_1 = 0;
    int last_ss_dangle_energy_1 = 0;

    TUSubsequence multi_inner_stem = REGION(t_0_seq,a_1.i,a_6.j);
    if ((x_2.second.subword.j - x_2.second.prevSubword.j) == 1) {
      last_ss_dangle_energy_1 = min(dr_energy(x_2.second.prevSubword, x_2.second.prevSubword), dri_energy(multi_inner_stem, multi_inner_stem));
    } else if ((x_2.second.subword.j - x_2.second.prevSubword.j) > 1) {
      last_ss_dangle_energy_1 = dr_energy(x_2.second.prevSubword, x_2.second.prevSubword) + dri_energy(multi_inner_stem, multi_inner_stem);
    }
    TUSubsequence new_stem;
    for (unsigned int t_0_k_0 = x_2.second.subword.i; t_0_k_0 <= (x_2.second.prevSubword.i-5); ++t_0_k_0) {  //t_0_k_0=3
      if (lmCompliant == false) {
	break; 
      }

      for(unsigned int t_0_k_1 = (t_0_k_0+5); (t_0_k_1 <= x_2.second.prevSubword.i); ++t_0_k_1) {  //t_0_k_1=8
	if (basepairing(t_0_seq, t_0_k_0, t_0_k_1)) {
	  new_stem = REGION(t_0_seq,t_0_k_0,t_0_k_1);
          if ((t_0_k_0 - x_2.second.subword.i) == 1) {
	    first_ss_dangle_energy_1 = min(dli_energy(multi_inner_stem, multi_inner_stem), dl_energy(new_stem, new_stem));
	  } else if ((t_0_k_0 - x_2.second.subword.i) > 1) {
	    first_ss_dangle_energy_1 = dli_energy(multi_inner_stem, multi_inner_stem) + dl_energy(new_stem, new_stem);
	  } else {
	    first_ss_dangle_energy_1 = 0;
	  }
	  
	  // NOTE: t_0_k_1 has 1 offset, it is j-like index
	  if ((x_2.second.prevSubword.i - t_0_k_1) == 1) {
	    next_ss_dangle_energy_1 = min(dr_energy(new_stem, new_stem), dl_energy(x_2.second.prevSubword, x_2.second.prevSubword));
	  } else if ((x_2.second.prevSubword.i - t_0_k_1) > 1) {
	    next_ss_dangle_energy_1 = dr_energy(new_stem, new_stem) + dl_energy(x_2.second.prevSubword, x_2.second.prevSubword);
	  } else {
	    next_ss_dangle_energy_1 = 0;
	  }
	  
	  if ( \
	       ( !_shouldermin && ((ml_energy() + ul_energy() + (2*ul_energy() + first_ss_dangle_energy_1 + nt_hairpin_complete(t_0_k_0,t_0_k_1).second.energy + termau_energy(new_stem, new_stem) + next_ss_dangle_energy_1 + x_2.second.prevE + termau_energy(x_2.second.prevSubword, x_2.second.prevSubword) + last_ss_dangle_energy_1) + sr_energy(ans.second.subword,ans.second.subword) + termau_energy(multi_inner_stem,multi_inner_stem)) <= ans.second.energy) ) \
	       || ( _shouldermin && ((ml_energy() + ul_energy() + (2*ul_energy() + first_ss_dangle_energy_1 + nt_hairpin_complete(t_0_k_0,t_0_k_1).second.energy + termau_energy(new_stem, new_stem) + next_ss_dangle_energy_1 + x_2.second.prevE + termau_energy(x_2.second.prevSubword, x_2.second.prevSubword) + last_ss_dangle_energy_1) + sr_energy(ans.second.subword,ans.second.subword) + termau_energy(multi_inner_stem,multi_inner_stem)) < ans.second.energy) ) \
	     ) {
	    lmCompliant = false;
	    break;
	  }
	  
	}
      }
    }
  }
}

if (lmCompliant) {
  if ((x_2.second.subword.j - x_2.second.prevSubword.j) >= 5) {   
    int first_ss_dangle_energy_1 = 0;
    int next_ss_dangle_energy_1 = 0;
    int last_ss_dangle_energy_1 = 0;

    TUSubsequence multi_inner_stem = REGION(t_0_seq,a_1.i,a_6.j);
    if ((x_2.second.prevSubword.i - x_2.second.subword.i) == 1) {
      first_ss_dangle_energy_1 = min(dli_energy(multi_inner_stem, multi_inner_stem), dl_energy(x_2.second.prevSubword, x_2.second.prevSubword));
    } else if ((x_2.second.prevSubword.i - x_2.second.subword.i) > 1) {
      first_ss_dangle_energy_1 = dli_energy(multi_inner_stem, multi_inner_stem) + dl_energy(x_2.second.prevSubword, x_2.second.prevSubword);
    }
    TUSubsequence new_stem;
    for (unsigned int t_0_k_0 = x_2.second.prevSubword.j; t_0_k_0 <= (x_2.second.subword.j-5); ++t_0_k_0) {
      if (lmCompliant == false) {
	break; 
      }

      for(unsigned int t_0_k_1 = (t_0_k_0+5); (t_0_k_1 <= x_2.second.subword.j); ++t_0_k_1) {
	if (basepairing(t_0_seq, t_0_k_0, t_0_k_1)) {
	  new_stem = REGION(t_0_seq,t_0_k_0,t_0_k_1);
          if ((t_0_k_0 - x_2.second.prevSubword.j) == 1) {
	    next_ss_dangle_energy_1 = min(dr_energy(x_2.second.prevSubword, x_2.second.prevSubword), dl_energy(new_stem, new_stem));
	  } else if ((t_0_k_0 - x_2.second.prevSubword.j) > 1) {
	    next_ss_dangle_energy_1 = dr_energy(x_2.second.prevSubword, x_2.second.prevSubword) + dl_energy(new_stem, new_stem);
	  } else {
	    next_ss_dangle_energy_1 = 0;
	  }
	  
	  // NOTE: t_0_k_1 has 1 offset, it is j-like index
          if ((x_2.second.subword.j - t_0_k_1) == 1) {
	    last_ss_dangle_energy_1 = min(dr_energy(new_stem, new_stem), dri_energy(multi_inner_stem, multi_inner_stem));
	  } else if ((x_2.second.subword.j - t_0_k_1) > 1) {
	    last_ss_dangle_energy_1 = dr_energy(new_stem, new_stem) + dri_energy(multi_inner_stem, multi_inner_stem);
	  } else {
	    last_ss_dangle_energy_1 = 0;
	  }
	  
	  
	  //ml_energy() + ul_energy() + e.energy + sr_energy(res.firstStem,res.firstStem) + termau_energy(innerstem,innerstem)
	  if ( \
	       ( !_shouldermin && ((ml_energy() + ul_energy() + (2*ul_energy() + first_ss_dangle_energy_1 + x_2.second.prevE + termau_energy(x_2.second.prevSubword, x_2.second.prevSubword) + next_ss_dangle_energy_1 + nt_hairpin_complete(t_0_k_0,t_0_k_1).second.energy + termau_energy(new_stem, new_stem) + last_ss_dangle_energy_1) + sr_energy(ans.second.subword,ans.second.subword) + termau_energy(multi_inner_stem,multi_inner_stem)) <= ans.second.energy) ) \
	       || ( _shouldermin && ((ml_energy() + ul_energy() + (2*ul_energy() + first_ss_dangle_energy_1 + x_2.second.prevE + termau_energy(x_2.second.prevSubword, x_2.second.prevSubword) + next_ss_dangle_energy_1 + nt_hairpin_complete(t_0_k_0,t_0_k_1).second.energy + termau_energy(new_stem, new_stem) + last_ss_dangle_energy_1) + sr_energy(ans.second.subword,ans.second.subword) + termau_energy(multi_inner_stem,multi_inner_stem)) < ans.second.energy) ) \
	     ) {
	    lmCompliant = false;
	    break;
	  }
	  
	}
      }
    }
  }
}


}


if (lmCompliant) {
  push_back( answers, ans);
}
                      //push_back( answers, ans);
                    }
                  }

                erase( a_2);
              }

              erase( a_0);
            }

            erase( a_1);
          }

          erase( a_6);
        }

        erase( a_7);
      }

      else
        {
          empty( answers);
        }

    }

  hash_filter( answers);
  finalize( answers);
  return answers;
}

hhpp_hash_h hhpp::nt_initstem(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 7))
    {
      return LBRope_firstG_mfeanswer_v4_secondG_EMhdecl0x2c432e0_zero;
    }

  hhpp_hash_h answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 7))
  {
    hhpp_hash_h ret_1 = nt_closed(t_0_i, t_0_j);
    hhpp_hash_h a_0 = ret_1;
    if (is_not_empty(a_0))
      {
        for (hhpp_hash_h::iterator x_0_itr = a_0.ref().begin(); x_0_itr!=a_0.ref().end(); ++x_0_itr){
          std::pair<Rope, mfeanswer_v4>  x_0 = *x_0_itr;
          std::pair<Rope, mfeanswer_v4>  ans = is(x_0);
          push_back( answers, ans);
        }
      }

    erase( a_0);
  }

  hash_filter( answers);
  finalize( answers);
  return answers;
}

hhpp_hash_h hhpp::nt_leftB(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 12))
    {
      return LBRope_firstG_mfeanswer_v4_secondG_EMhdecl0x2c432e0_zero;
    }

  hhpp_hash_h answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 12))
    {
      if (stackpairing(t_0_seq, t_0_i, t_0_j))
      {
        TUSubsequence ret_7 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_6 = ret_7;
        if (is_not_empty(a_6))
        {
          TUSubsequence ret_6 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
          TUSubsequence a_5 = ret_6;
          if (is_not_empty(a_5))
          {
            TUSubsequence ret_2 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
            TUSubsequence a_1 = ret_2;
            if (is_not_empty(a_1))
            {
              TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
              TUSubsequence a_0 = ret_1;
              if (is_not_empty(a_0))
              {
                hhpp_hash_h ret_3;
                empty(ret_3);
                if ((((t_0_j - 2) - (t_0_i + 2)) >= 8))
                  {
                    for(                    unsigned int t_0_k_0 = ((t_0_i + 2) + 1); (t_0_k_0 <= ((t_0_j - 2) - 7)); ++t_0_k_0)
                    {
                      TUSubsequence ret_4 = REGION(t_0_seq, (t_0_i + 2), t_0_k_0);
                      TUSubsequence a_3 = ret_4;
                      if (is_not_empty(a_3))
                      {
                        hhpp_hash_h ret_5 = nt_closed(t_0_k_0, (t_0_j - 2));
                        hhpp_hash_h a_4 = ret_5;
                        if (is_not_empty(a_4))
                          {
                            for (hhpp_hash_h::iterator x_4_itr = a_4.ref().begin(); x_4_itr!=a_4.ref().end(); ++x_4_itr){
                              std::pair<Rope, mfeanswer_v4>  x_4 = *x_4_itr;
                              std::pair<Rope, mfeanswer_v4>  ans = bl(a_3, x_4);
                              push_back( ret_3, ans);
                            }
                          }

                        erase( a_4);
                      }

                      erase( a_3);
                    }

                  }

                finalize( ret_3);
                hhpp_hash_h a_2 = ret_3;
                if (is_not_empty(a_2))
                  {
                    for (hhpp_hash_h::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                      std::pair<Rope, mfeanswer_v4>  x_2 = *x_2_itr;
                      std::pair<Rope, mfeanswer_v4>  ans = sp(a_0, a_1, x_2, a_5, a_6);
bool lmCompliant = true;

if (_locallymin) {
//2_a
int leftBE_before_delete = 0;
if (loop_complete_table_energy.is_tabulated(a_1.i, x_2.second.prevSubword.i, x_2.second.prevSubword.j, a_5.j)) {
  leftBE_before_delete = loop_complete_table_energy.get(a_1.i, x_2.second.prevSubword.i, x_2.second.prevSubword.j, a_5.j);
} else {
  leftBE_before_delete = bl_energy(REGION(t_0_seq,a_1.i+1,x_2.second.prevSubword.i),REGION(t_0_seq,a_1.i,a_5.j));
  loop_complete_table_energy.set(a_1.i, x_2.second.prevSubword.i, x_2.second.prevSubword.j, a_5.j, leftBE_before_delete);
}

int srE_before_delete = 0;
if (loop_complete_table_energy.is_tabulated(x_2.second.prevSubword.i, x_2.second.prevSubword.i+1, x_2.second.prevSubword.j-1, x_2.second.prevSubword.j)) {
  srE_before_delete = loop_complete_table_energy.get(x_2.second.prevSubword.i, x_2.second.prevSubword.i+1, x_2.second.prevSubword.j-1, x_2.second.prevSubword.j);
} else {
  srE_before_delete = sr_energy(x_2.second.prevSubword, x_2.second.prevSubword);
  loop_complete_table_energy.set(x_2.second.prevSubword.i, x_2.second.prevSubword.i+1, x_2.second.prevSubword.j-1, x_2.second.prevSubword.j, srE_before_delete);
}

int iloopE_after_delete = 0;
if (loop_complete_table_energy.is_tabulated(a_1.i, x_2.second.prevSubword.i+1, x_2.second.prevSubword.j-1, a_5.j)) {
  iloopE_after_delete = loop_complete_table_energy.get(a_1.i, x_2.second.prevSubword.i+1, x_2.second.prevSubword.j-1, a_5.j); 
} else {
  iloopE_after_delete = il_energy(REGION(t_0_seq,a_1.i+1,x_2.second.prevSubword.i+1),REGION(t_0_seq,x_2.second.prevSubword.j-1,a_5.j-1));
  loop_complete_table_energy.set(a_1.i, x_2.second.prevSubword.i+1, x_2.second.prevSubword.j-1, a_5.j, iloopE_after_delete);
}

if ( \
     ( !_shouldermin && (iloopE_after_delete <= (srE_before_delete + leftBE_before_delete)) ) \
     || ( _shouldermin && (iloopE_after_delete < (srE_before_delete + leftBE_before_delete)) ) \
   ) {
  lmCompliant = false;
}     

//2_c
if (lmCompliant) {
  iloopE_after_delete = 0;
  if (loop_complete_table_energy.is_tabulated(a_0.i, x_2.second.prevSubword.i, x_2.second.prevSubword.j, a_6.j)) {
   iloopE_after_delete = loop_complete_table_energy.get(a_0.i, x_2.second.prevSubword.i, x_2.second.prevSubword.j, a_6.j); 
  } else {
    iloopE_after_delete = il_energy(REGION(t_0_seq,a_0.i+1,x_2.second.prevSubword.i),REGION(t_0_seq,x_2.second.prevSubword.j,a_6.j-1));
    loop_complete_table_energy.set(a_0.i, x_2.second.prevSubword.i, x_2.second.prevSubword.j, a_6.j, iloopE_after_delete);
  }

  srE_before_delete = 0;
  if (loop_complete_table_energy.is_tabulated(a_0.i, a_1.i, a_5.j, a_6.j)) {
    srE_before_delete = loop_complete_table_energy.get(a_0.i, a_1.i, a_5.j, a_6.j);
  } else {
    srE_before_delete = sr_energy(ans.second.subword, ans.second.subword);
    loop_complete_table_energy.set(a_0.i, a_1.i, a_5.j, a_6.j, srE_before_delete);
  }

  if ( \
       ( !_shouldermin && (iloopE_after_delete <= (leftBE_before_delete + srE_before_delete)) ) \
       || ( _shouldermin && (iloopE_after_delete < (leftBE_before_delete + srE_before_delete)) ) \
     ) {
    lmCompliant = false;
  } 
}

//2_ss
//  a_3.j = x_2.second.prevSubword.i
//  a_1.i = x_2.second.subword.i
if (lmCompliant) {

  if ((x_2.second.prevSubword.i - x_2.second.subword.i) >= 5) {  // contains iloop    
    int first_ss_dangle_energy_1 = 0;
    int next_ss_dangle_energy_1 = 0;
    TUSubsequence multi_inner_stem = REGION(t_0_seq,a_1.i,a_5.j);
    TUSubsequence new_stem;
    for (unsigned int t_0_k_0 = x_2.second.subword.i; t_0_k_0 <= (x_2.second.prevSubword.i-5); ++t_0_k_0) {  //t_0_k_0=3
      if (lmCompliant == false) {
	break; 
      }

      for(unsigned int t_0_k_1 = (t_0_k_0+5); (t_0_k_1 <= x_2.second.prevSubword.i); ++t_0_k_1) {  //t_0_k_1=8
	if (basepairing(t_0_seq, t_0_k_0, t_0_k_1)) {
	  new_stem = REGION(t_0_seq,t_0_k_0,t_0_k_1);
          if ((t_0_k_0 - x_2.second.subword.i) == 1) {
	    first_ss_dangle_energy_1 = min(dli_energy(multi_inner_stem, multi_inner_stem), dl_energy(new_stem, new_stem));
	  } else if ((t_0_k_0 - x_2.second.subword.i) > 1) {
	    first_ss_dangle_energy_1 = dli_energy(multi_inner_stem, multi_inner_stem) + dl_energy(new_stem, new_stem);
	  } else {
	    first_ss_dangle_energy_1 = 0;
	  }
	  
	  // NOTE: t_0_k_1 has 1 offset, it is j-like index
	  if ((x_2.second.prevSubword.i - t_0_k_1) == 1) {
	    next_ss_dangle_energy_1 = min(dr_energy(new_stem, new_stem), dl_energy(x_2.second.prevSubword, x_2.second.prevSubword));
	  } else if ((x_2.second.prevSubword.i - t_0_k_1) > 1) {
	    next_ss_dangle_energy_1 = dr_energy(new_stem, new_stem) + dl_energy(x_2.second.prevSubword, x_2.second.prevSubword);
	  } else {
	    next_ss_dangle_energy_1 = 0;
	  }
	  
	  //ml_energy() + ul_energy() + e.energy + sr_energy(res.firstStem,res.firstStem) + termau_energy(innerstem,innerstem)
	  // TODO: check if 3*ul_energy() is correct
	  // GGCCCCUUUGGGGGCCAGACCCCUAAAGGGGUC
	  // (((.(......)..((((....))....)))))
	  //( ((...........((((....))....)))) , (530, (1, -1), (-1,-1), (0,0), (0,0), (-1,32), ) )4,12,660:340+40+80+ -80+250+0+0+280+0+ -250+0<>530
	  //( ((...........((((....))....)))) , (530, (1, -1), (-1,-1), (0,0), (0,0), (-1,32), ) )4,12,510:340+40+80+ -80+250+0+-150+280+0+ -250+0<>530
	  //std::cout << ans << t_0_k_0 <<","<< t_0_k_1 <<","<< (ml_energy() + ul_energy() + (2*ul_energy() + first_ss_dangle_energy_1 + nt_hairpin_complete(t_0_k_0,t_0_k_1).second.energy + termau_energy(new_stem, new_stem) + next_ss_dangle_energy_1 + x_2.second.prevE + termau_energy(x_2.second.prevSubword, x_2.second.prevSubword)) + sr_energy(ans.second.subword,ans.second.subword) + termau_energy(multi_inner_stem,multi_inner_stem)) <<":"<< ml_energy() <<"+"<< ul_energy() <<"+"<< 2*ul_energy() <<"+"<< first_ss_dangle_energy_1 <<"+"<< nt_hairpin_complete(t_0_k_0,t_0_k_1).second.energy <<"+"<< termau_energy(new_stem, new_stem) <<"+"<< next_ss_dangle_energy_1 <<"+"<< x_2.second.prevE <<"+"<< termau_energy(x_2.second.prevSubword, x_2.second.prevSubword) <<"+"<< sr_energy(ans.second.subword,ans.second.subword) <<"+"<< termau_energy(multi_inner_stem,multi_inner_stem) <<"<>"<< ans.second.energy << std::endl;
	  if ( \
	       ( !_shouldermin && ((ml_energy() + ul_energy() + (2*ul_energy() +     first_ss_dangle_energy_1 + nt_hairpin_complete(t_0_k_0,t_0_k_1).second.energy + termau_energy(new_stem, new_stem) + next_ss_dangle_energy_1 + x_2.second.prevE + termau_energy(x_2.second.prevSubword, x_2.second.prevSubword)) + sr_energy(ans.second.subword,ans.second.subword) + termau_energy(multi_inner_stem,multi_inner_stem)) <= ans.second.energy) ) \
	       || ( _shouldermin && ((ml_energy() + ul_energy() + (2*ul_energy() +     first_ss_dangle_energy_1 + nt_hairpin_complete(t_0_k_0,t_0_k_1).second.energy + termau_energy(new_stem, new_stem) + next_ss_dangle_energy_1 + x_2.second.prevE + termau_energy(x_2.second.prevSubword, x_2.second.prevSubword)) + sr_energy(ans.second.subword,ans.second.subword) + termau_energy(multi_inner_stem,multi_inner_stem)) < ans.second.energy) ) \
	     ) {
	                                    // edlr(is(hl))
	  //if ((ml_energy() + ul_energy() + (first_ss_dangle_energy_1 + nt_hairpin_complete(t_0_k_0,t_0_k_1).second.energy + termau_energy(new_stem, new_stem) + next_ss_dangle_energy_1)) < 0) {
	    lmCompliant = false;
	    break;
	  }
	  
	}
      }
    }
  }
}

}

if (lmCompliant) {
  push_back( answers, ans);
}
                      //push_back( answers, ans);
                    }
                  }

                erase( a_2);
              }

              erase( a_0);
            }

            erase( a_1);
          }

          erase( a_5);
        }

        erase( a_6);
      }

      else
        {
          empty( answers);
        }

    }

  hash_filter( answers);
  finalize( answers);
  return answers;
}

hhpp_hash_h &  hhpp::nt_ml_comps(unsigned int t_0_i, unsigned int t_0_j)
{
  if (ml_comps_table.is_tabulated(t_0_i, t_0_j))
    {
      return ml_comps_table.get(t_0_i, t_0_j);
    }

  hhpp_hash_h answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 14))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 7); (t_0_k_0 <= (t_0_j - 7)); ++t_0_k_0)
      {
        hhpp_hash_h ret_3 = nt_ml_comps1(t_0_k_0, t_0_j);
        hhpp_hash_h a_2 = ret_3;
        if (is_not_empty(a_2))
        {
          hhpp_hash_h ret_1;
          empty(ret_1);
          if (((t_0_k_0 - t_0_i) >= 7))
          {
            hhpp_hash_h ret_2 = nt_dangle(t_0_i, t_0_k_0);
            hhpp_hash_h a_1 = ret_2;
            if (is_not_empty(a_1))
              {
                for (hhpp_hash_h::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
                  std::pair<Rope, mfeanswer_v4>  x_1 = *x_1_itr;
                  std::pair<Rope, mfeanswer_v4>  ans = incl(x_1);
                  push_back( ret_1, ans);
                }
              }

            erase( a_1);
          }

          finalize( ret_1);
          hhpp_hash_h a_0 = ret_1;
          if (is_not_empty(a_0))
            {
              for (hhpp_hash_h::iterator x_0_itr = a_0.ref().begin(); x_0_itr!=a_0.ref().end(); ++x_0_itr){
                std::pair<Rope, mfeanswer_v4>  x_0 = *x_0_itr;
                for (hhpp_hash_h::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                  std::pair<Rope, mfeanswer_v4>  x_2 = *x_2_itr;
                  std::pair<Rope, mfeanswer_v4>  ans = cadd(x_0, x_2);
bool lmCompliant = true;
//std::cout << "6z:" << x_0 <<"+"<< x_2 <<"="<< ans << std::endl;
if (_locallymin) {
if (x_2.second.next_ss_i != -1) {  // no. of inistem >= 2
  //6_a: for most right initstem
  //  ..((...))...((...)).....  old
  //  ..((...))a(b((...))c)d..  new
  // NOTE: 6_a is moved into 7_a


  //6_b
  // from second initstem
  //  ...         
  //  ...((...))...((...))...((...)).....  old
  //  ...((...))a(b((...))c)d((...)).....  new
  //          next_ss_pos  |
  //                      after_next_ss_pos
  if (ans.second.after_next_ss_j != -1) {  //  ==> no. of inistem > 2   
    // if dangle bases exist on both sides
    int next_ss_dangle_energy_0 = 0;
    int after_next_ss_dangle_energy_0 = 0;
    if ((ans.second.next_ss_j - ans.second.next_ss_i) == 1) {
      next_ss_dangle_energy_0 = min(dr_energy(x_0.second.firstStem, x_0.second.firstStem), dl_energy(x_2.second.firstStem, x_2.second.firstStem));
    } else if ((ans.second.next_ss_j - ans.second.next_ss_i) > 1) {
      next_ss_dangle_energy_0 = dr_energy(x_0.second.firstStem, x_0.second.firstStem) + dl_energy(x_2.second.firstStem, x_2.second.firstStem);
    }
    if ((ans.second.after_next_ss_j - ans.second.after_next_ss_i) == 1) {
      after_next_ss_dangle_energy_0 = min(dr_energy(x_2.second.firstStem, x_2.second.firstStem), dl_energy(x_2.second.secondStem, x_2.second.secondStem));
    } else if ((ans.second.after_next_ss_j - ans.second.after_next_ss_i) > 1) {
      after_next_ss_dangle_energy_0 = dr_energy(x_2.second.firstStem, x_2.second.firstStem) + dl_energy(x_2.second.secondStem, x_2.second.secondStem);
    }

    // try to ADD a bp
    int next_ss_dangle_energy_1 = 0;
    int after_next_ss_dangle_energy_1 = 0;
    int additional_energy_1 = 0;
    TUSubsequence extended_stem;
    for (unsigned int next_ss_pos = ans.second.next_ss_i; next_ss_pos < ans.second.next_ss_j; next_ss_pos++) {
      if (!lmCompliant) {
	break;
      }
      for (unsigned int after_next_ss_pos = ans.second.after_next_ss_i; after_next_ss_pos < ans.second.after_next_ss_j; after_next_ss_pos++) {
	if (basepairing(t_0_seq, next_ss_pos, after_next_ss_pos+1)) {
	extended_stem = REGION(t_0_seq,next_ss_pos,after_next_ss_pos+1);
	  if (loop_complete_table_energy.is_tabulated(next_ss_pos, (unsigned int)ans.second.next_ss_j, (unsigned int)ans.second.after_next_ss_i, after_next_ss_pos+1)) {
	    additional_energy_1 = loop_complete_table_energy.get(next_ss_pos, (unsigned int)ans.second.next_ss_j, (unsigned int)ans.second.after_next_ss_i, after_next_ss_pos+1); 
	  } else {
	    if ((ans.second.next_ss_j - next_ss_pos) == 1 ) {   //b
	      if ((after_next_ss_pos - ans.second.after_next_ss_i) == 0) {       //c
		additional_energy_1 = sr_energy(extended_stem, extended_stem);
	      } else if ((after_next_ss_pos - ans.second.after_next_ss_i) > 0) { //c
		additional_energy_1 = br_energy(extended_stem, REGION(t_0_seq,(unsigned int)ans.second.after_next_ss_i,after_next_ss_pos));
	      }
	    } else if ((ans.second.next_ss_j - next_ss_pos) > 1 ) {    //b
	      if ((after_next_ss_pos - ans.second.after_next_ss_i) == 0) {               //c
		additional_energy_1 = bl_energy(REGION(t_0_seq, next_ss_pos+1, (unsigned int)ans.second.next_ss_j), extended_stem);
	      } else if ((after_next_ss_pos - ans.second.after_next_ss_i) > 0) {         //c
		additional_energy_1 = il_energy(REGION(t_0_seq, next_ss_pos+1, (unsigned int)ans.second.next_ss_j), REGION(t_0_seq,(unsigned int)ans.second.after_next_ss_i,after_next_ss_pos));
	      }
	    }

	    loop_complete_table_energy.set(next_ss_pos, (unsigned int)ans.second.next_ss_j, (unsigned int)ans.second.after_next_ss_i, after_next_ss_pos+1, additional_energy_1);
	  }

	  
	  if ((next_ss_pos - ans.second.next_ss_i) == 1 ) {    //a
	    next_ss_dangle_energy_1 = min(dr_energy(x_0.second.firstStem, x_0.second.firstStem), dl_energy(extended_stem, extended_stem));
	  } else if ((next_ss_pos - ans.second.next_ss_i) > 1) {
	    next_ss_dangle_energy_1 = dr_energy(x_0.second.firstStem, x_0.second.firstStem) + dl_energy(extended_stem, extended_stem);         
	  } else {
	    next_ss_dangle_energy_1 = 0;
	  }
	  if ((ans.second.after_next_ss_j - after_next_ss_pos) == 2) {  //d
	    after_next_ss_dangle_energy_1 = min(dr_energy(extended_stem, extended_stem), dl_energy(x_2.second.secondStem, x_2.second.secondStem));
	  } else if ((ans.second.after_next_ss_j - after_next_ss_pos) > 2) {
	    after_next_ss_dangle_energy_1 = dr_energy(extended_stem, extended_stem) + dl_energy(x_2.second.secondStem, x_2.second.secondStem);
	  } else {
	    after_next_ss_dangle_energy_1 = 0;
	  }

	  if ( \
	       ( !_shouldermin && ((next_ss_dangle_energy_1 + after_next_ss_dangle_energy_1 + additional_energy_1 + termau_energy(extended_stem,extended_stem)) <= (next_ss_dangle_energy_0 + after_next_ss_dangle_energy_0 + termau_energy(x_2.second.firstStem,x_2.second.firstStem))) ) \
	       || ( _shouldermin && ((next_ss_dangle_energy_1 + after_next_ss_dangle_energy_1 + additional_energy_1 + termau_energy(extended_stem,extended_stem)) < (next_ss_dangle_energy_0 + after_next_ss_dangle_energy_0 + termau_energy(x_2.second.firstStem,x_2.second.firstStem))) ) \ 
	     ) {
	    lmCompliant = false;
	    break;
	  }
	}
      }
    }
    // try to DEL a bp
    //  ...((...))...((...))...((...)).....  old
    //  ...((...))....(...)....((...)).....  new
    if (lmCompliant) {
      int additional_energy_0 = 0;
      TUSubsequence inner_stem = REGION(t_0_seq,(unsigned int)(ans.second.next_ss_j+1),(unsigned int)(ans.second.after_next_ss_i-1));
      if (loop_complete_table_energy.is_tabulated((unsigned int)ans.second.next_ss_j, (unsigned int)(ans.second.next_ss_j+1), (unsigned int)(ans.second.after_next_ss_i-1), (unsigned int)ans.second.after_next_ss_i)) {
	additional_energy_0 = loop_complete_table_energy.get((unsigned int)ans.second.next_ss_j, (unsigned int)(ans.second.next_ss_j+1), (unsigned int)(ans.second.after_next_ss_i-1), (unsigned int)ans.second.after_next_ss_i); 
      } else {
	additional_energy_0 = sr_energy(x_2.second.firstStem, x_2.second.firstStem);

	loop_complete_table_energy.set((unsigned int)ans.second.next_ss_j, (unsigned int)(ans.second.next_ss_j+1), (unsigned int)(ans.second.after_next_ss_i-1), (unsigned int)ans.second.after_next_ss_i, additional_energy_0);
      }

      if ((ans.second.next_ss_j - ans.second.next_ss_i) == 0 ) {    //a
	next_ss_dangle_energy_1 = min(dr_energy(x_0.second.firstStem, x_0.second.firstStem), dl_energy(inner_stem, inner_stem));
      } else {
	next_ss_dangle_energy_1 = dr_energy(x_0.second.firstStem, x_0.second.firstStem) + dl_energy(inner_stem, inner_stem);         
      }
      if ((ans.second.after_next_ss_j - ans.second.after_next_ss_i) == 0) {  //d
        //std::cout << "6_b:" << x_0 << x_2 << ans << x_2.second.secondStem << std::endl;
	after_next_ss_dangle_energy_1 = min(dr_energy(inner_stem, inner_stem), dl_energy(x_2.second.secondStem, x_2.second.secondStem));
      } else {
	after_next_ss_dangle_energy_1 = dr_energy(inner_stem, inner_stem) + dl_energy(x_2.second.secondStem, x_2.second.secondStem);
      }

      if ( \
	   ( !_shouldermin && ((next_ss_dangle_energy_1 + after_next_ss_dangle_energy_1 + termau_energy(inner_stem,inner_stem)) <= (next_ss_dangle_energy_0 + after_next_ss_dangle_energy_0 + additional_energy_0 + termau_energy(x_2.second.firstStem,x_2.second.firstStem))) ) \
	   || ( _shouldermin && ((next_ss_dangle_energy_1 + after_next_ss_dangle_energy_1 + termau_energy(inner_stem,inner_stem)) < (next_ss_dangle_energy_0 + after_next_ss_dangle_energy_0 + additional_energy_0 + termau_energy(x_2.second.firstStem,x_2.second.firstStem))) ) \ 
         ) {
	lmCompliant = false;
      } 
    }

  }
}
}

if (lmCompliant) {
  push_back( answers, ans);
}
                  //push_back( answers, ans);
                }
              }
            }

          erase( a_0);
        }

        erase( a_2);
      }

    }


  if (((t_0_j - t_0_i) >= 15))
  {
    TUSubsequence ret_5 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
    TUSubsequence a_3 = ret_5;
    if (is_not_empty(a_3))
    {
      hhpp_hash_h ret_6 = nt_ml_comps((t_0_i + 1), t_0_j);
      hhpp_hash_h a_4 = ret_6;
      if (is_not_empty(a_4))
        {
          for (hhpp_hash_h::iterator x_4_itr = a_4.ref().begin(); x_4_itr!=a_4.ref().end(); ++x_4_itr){
            std::pair<Rope, mfeanswer_v4>  x_4 = *x_4_itr;
            std::pair<Rope, mfeanswer_v4>  ans = sadd(a_3, x_4);
            push_back( answers, ans);
          }
        }

      erase( a_4);
    }

    erase( a_3);
  }

  hash_filter( answers);
  finalize( answers);
  ml_comps_table.set( t_0_i, t_0_j, answers);
  return ml_comps_table.get(t_0_i, t_0_j);
}

hhpp_hash_h &  hhpp::nt_ml_comps1(unsigned int t_0_i, unsigned int t_0_j)
{
  if (ml_comps1_table.is_tabulated(t_0_i, t_0_j))
    {
      return ml_comps1_table.get(t_0_i, t_0_j);
    }

  hhpp_hash_h answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 14))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 7); (t_0_k_0 <= (t_0_j - 7)); ++t_0_k_0)
      {
        hhpp_hash_h ret_3 = nt_ml_comps1(t_0_k_0, t_0_j);
        hhpp_hash_h a_2 = ret_3;
        if (is_not_empty(a_2))
        {
          hhpp_hash_h ret_1;
          empty(ret_1);
          if (((t_0_k_0 - t_0_i) >= 7))
          {
            hhpp_hash_h ret_2 = nt_dangle(t_0_i, t_0_k_0);
            hhpp_hash_h a_1 = ret_2;
            if (is_not_empty(a_1))
              {
                for (hhpp_hash_h::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
                  std::pair<Rope, mfeanswer_v4>  x_1 = *x_1_itr;
                  std::pair<Rope, mfeanswer_v4>  ans = incl(x_1);
                  push_back( ret_1, ans);
                }
              }

            erase( a_1);
          }

          finalize( ret_1);
          hhpp_hash_h a_0 = ret_1;
          if (is_not_empty(a_0))
            {
              for (hhpp_hash_h::iterator x_0_itr = a_0.ref().begin(); x_0_itr!=a_0.ref().end(); ++x_0_itr){
                std::pair<Rope, mfeanswer_v4>  x_0 = *x_0_itr;
                for (hhpp_hash_h::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                  std::pair<Rope, mfeanswer_v4>  x_2 = *x_2_itr;
                  std::pair<Rope, mfeanswer_v4>  ans = cadd(x_0, x_2);
bool lmCompliant = true;

if (_locallymin) {
if (x_2.second.next_ss_i != -1) {  // no. of inistem >= 2
  //5_a: for most right initstem
  //  ..((...))...((...)).....  old
  //  ..((...))a(b((...))c)d..  new
  // NOTE: 5_a is moved into 7_a


  //5_b
  // from second initstem
  //  ...         
  //  ...((...))...((...))...((...)).....  old
  //  ...((...))a(b((...))c)d((...)).....  new
  //          next_ss_pos  |
  //                      after_next_ss_pos
  if (ans.second.after_next_ss_j != -1) {  // ==> no. of inistem > 2   
    // if dangle bases exist on both sides
    int next_ss_dangle_energy_0 = 0;
    int after_next_ss_dangle_energy_0 = 0;
    if ((ans.second.next_ss_j - ans.second.next_ss_i) == 1) {
      next_ss_dangle_energy_0 = min(dr_energy(x_0.second.firstStem, x_0.second.firstStem), dl_energy(x_2.second.firstStem, x_2.second.firstStem));
    } else if ((ans.second.next_ss_j - ans.second.next_ss_i) > 1) {
      next_ss_dangle_energy_0 = dr_energy(x_0.second.firstStem, x_0.second.firstStem) + dl_energy(x_2.second.firstStem, x_2.second.firstStem);
    }
    if ((ans.second.after_next_ss_j - ans.second.after_next_ss_i) == 1) {
      after_next_ss_dangle_energy_0 = min(dr_energy(x_2.second.firstStem, x_2.second.firstStem), dl_energy(x_2.second.secondStem, x_2.second.secondStem));
    } else if ((ans.second.after_next_ss_j - ans.second.after_next_ss_i) > 1) {
      after_next_ss_dangle_energy_0 = dr_energy(x_2.second.firstStem, x_2.second.firstStem) + dl_energy(x_2.second.secondStem, x_2.second.secondStem);
    }

    // try to ADD a bp
    int next_ss_dangle_energy_1 = 0;
    int after_next_ss_dangle_energy_1 = 0;
    int additional_energy_1 = 0;
    TUSubsequence extended_stem;
    for (unsigned int next_ss_pos = ans.second.next_ss_i; next_ss_pos < ans.second.next_ss_j; next_ss_pos++) {
      if (!lmCompliant) {
	break;
      }
      for (unsigned int after_next_ss_pos = ans.second.after_next_ss_i; after_next_ss_pos < ans.second.after_next_ss_j; after_next_ss_pos++) {
	if (basepairing(t_0_seq, next_ss_pos, after_next_ss_pos+1)) {
	  extended_stem = REGION(t_0_seq,next_ss_pos,after_next_ss_pos+1);
	  if (loop_complete_table_energy.is_tabulated(next_ss_pos, (unsigned int)ans.second.next_ss_j, (unsigned int)ans.second.after_next_ss_i, after_next_ss_pos+1)) {
	    additional_energy_1 = loop_complete_table_energy.get(next_ss_pos, (unsigned int)ans.second.next_ss_j, (unsigned int)ans.second.after_next_ss_i, after_next_ss_pos+1); 
	  } else {
	    if ((ans.second.next_ss_j - next_ss_pos) == 1 ) {   //b
	      if ((after_next_ss_pos - ans.second.after_next_ss_i) == 0) {       //c
		additional_energy_1 = sr_energy(extended_stem, extended_stem);
	      } else if ((after_next_ss_pos - ans.second.after_next_ss_i) > 0) { //c
		additional_energy_1 = br_energy(extended_stem, REGION(t_0_seq,(unsigned int)ans.second.after_next_ss_i,after_next_ss_pos));
	      }
	    } else if ((ans.second.next_ss_j - next_ss_pos) > 1 ) {    //b
	      if ((after_next_ss_pos - ans.second.after_next_ss_i) == 0) {               //c
		additional_energy_1 = bl_energy(REGION(t_0_seq, next_ss_pos+1, (unsigned int)ans.second.next_ss_j), extended_stem);
	      } else if ((after_next_ss_pos - ans.second.after_next_ss_i) > 0) {         //c
		additional_energy_1 = il_energy(REGION(t_0_seq, next_ss_pos+1, (unsigned int)ans.second.next_ss_j), REGION(t_0_seq,(unsigned int)ans.second.after_next_ss_i,after_next_ss_pos));
	      }
	    }

	    loop_complete_table_energy.set(next_ss_pos, (unsigned int)ans.second.next_ss_j, (unsigned int)ans.second.after_next_ss_i, after_next_ss_pos+1, additional_energy_1);
	  }

	  
	  if ((next_ss_pos - ans.second.next_ss_i) == 1 ) {    //a
	    next_ss_dangle_energy_1 = min(dr_energy(x_0.second.firstStem, x_0.second.firstStem), dl_energy(extended_stem, extended_stem));
	  } else if ((next_ss_pos - ans.second.next_ss_i) > 1) {
	    next_ss_dangle_energy_1 = dr_energy(x_0.second.firstStem, x_0.second.firstStem) + dl_energy(extended_stem, extended_stem);         
	  } else {
	    next_ss_dangle_energy_1 = 0;
	  }
	  if ((ans.second.after_next_ss_j - after_next_ss_pos) == 2) {  //d
	    after_next_ss_dangle_energy_1 = min(dr_energy(extended_stem, extended_stem), dl_energy(x_2.second.secondStem, x_2.second.secondStem));
	  } else if ((ans.second.after_next_ss_j - after_next_ss_pos) > 2) {
	    after_next_ss_dangle_energy_1 = dr_energy(extended_stem, extended_stem) + dl_energy(x_2.second.secondStem, x_2.second.secondStem);
	  } else {
	    after_next_ss_dangle_energy_1 = 0;
	  }

	  if ( \
	       ( !_shouldermin && ((next_ss_dangle_energy_1 + after_next_ss_dangle_energy_1 + additional_energy_1 + termau_energy(extended_stem,extended_stem)) <= (next_ss_dangle_energy_0 + after_next_ss_dangle_energy_0 + termau_energy(x_2.second.firstStem,x_2.second.firstStem))) ) \
	       || ( _shouldermin && ((next_ss_dangle_energy_1 + after_next_ss_dangle_energy_1 + additional_energy_1 + termau_energy(extended_stem,extended_stem)) < (next_ss_dangle_energy_0 + after_next_ss_dangle_energy_0 + termau_energy(x_2.second.firstStem,x_2.second.firstStem))) ) \
	     ) {
	    lmCompliant = false;
	    break;
	  }
	}
      }
    }
    // try to DEL a bp
    //  ...((...))...((...))...((...)).....  old
    //  ...((...))....(...)....((...)).....  new
    if (lmCompliant) {
      int additional_energy_0 = 0;
      TUSubsequence inner_stem = REGION(t_0_seq,(unsigned int)(ans.second.next_ss_j+1),(unsigned int)(ans.second.after_next_ss_i-1));
      if (loop_complete_table_energy.is_tabulated((unsigned int)ans.second.next_ss_j, (unsigned int)(ans.second.next_ss_j+1), (unsigned int)(ans.second.after_next_ss_i-1), (unsigned int)ans.second.after_next_ss_i)) {
	additional_energy_0 = loop_complete_table_energy.get((unsigned int)ans.second.next_ss_j, (unsigned int)(ans.second.next_ss_j+1), (unsigned int)(ans.second.after_next_ss_i-1), (unsigned int)ans.second.after_next_ss_i); 
      } else {
	additional_energy_0 = sr_energy(x_2.second.firstStem, x_2.second.firstStem);

	loop_complete_table_energy.set((unsigned int)ans.second.next_ss_j, (unsigned int)(ans.second.next_ss_j+1), (unsigned int)(ans.second.after_next_ss_i-1), (unsigned int)ans.second.after_next_ss_i, additional_energy_0);
      }

      if ((ans.second.next_ss_j - ans.second.next_ss_i) == 0 ) {    //a
	next_ss_dangle_energy_1 = min(dr_energy(x_0.second.firstStem, x_0.second.firstStem), dl_energy(inner_stem, inner_stem));
      } else {
	next_ss_dangle_energy_1 = dr_energy(x_0.second.firstStem, x_0.second.firstStem) + dl_energy(inner_stem, inner_stem);         
      }
      if ((ans.second.after_next_ss_j - ans.second.after_next_ss_i) == 0) {  //d
        //std::cout << "5_b: " << x_0 << x_2 << ans << x_2.second.secondStem << std::endl;
	after_next_ss_dangle_energy_1 = min(dr_energy(inner_stem, inner_stem), dl_energy(x_2.second.secondStem, x_2.second.secondStem));
      } else {
	after_next_ss_dangle_energy_1 = dr_energy(inner_stem, inner_stem) + dl_energy(x_2.second.secondStem, x_2.second.secondStem);
      }

      if ( \
	   ( !_shouldermin && ((next_ss_dangle_energy_1 + after_next_ss_dangle_energy_1 + termau_energy(inner_stem,inner_stem)) <= (next_ss_dangle_energy_0 + after_next_ss_dangle_energy_0 + additional_energy_0 + termau_energy(x_2.second.firstStem,x_2.second.firstStem))) ) \
	   || ( _shouldermin && ((next_ss_dangle_energy_1 + after_next_ss_dangle_energy_1 + termau_energy(inner_stem,inner_stem)) < (next_ss_dangle_energy_0 + after_next_ss_dangle_energy_0 + additional_energy_0 + termau_energy(x_2.second.firstStem,x_2.second.firstStem))) ) \
         ) {
	lmCompliant = false;
      } 
    }
  }
}
}

if (lmCompliant) {
  push_back( answers, ans);
}
                  //push_back( answers, ans);
                }
              }
            }

          erase( a_0);
        }

        erase( a_2);
      }

    }


  if (((t_0_j - t_0_i) >= 8))
  {
    TUSubsequence ret_5 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
    TUSubsequence a_3 = ret_5;
    if (is_not_empty(a_3))
    {
      hhpp_hash_h ret_6 = nt_ml_comps1((t_0_i + 1), t_0_j);
      hhpp_hash_h a_4 = ret_6;
      if (is_not_empty(a_4))
        {
          for (hhpp_hash_h::iterator x_4_itr = a_4.ref().begin(); x_4_itr!=a_4.ref().end(); ++x_4_itr){
            std::pair<Rope, mfeanswer_v4>  x_4 = *x_4_itr;
            std::pair<Rope, mfeanswer_v4>  ans = sadd(a_3, x_4);
            push_back( answers, ans);
          }
        }

      erase( a_4);
    }

    erase( a_3);
  }


  if (((t_0_j - t_0_i) >= 7))
  {
    hhpp_hash_h ret_8 = nt_dangle(t_0_i, t_0_j);
    hhpp_hash_h a_5 = ret_8;
    if (is_not_empty(a_5))
      {
        for (hhpp_hash_h::iterator x_5_itr = a_5.ref().begin(); x_5_itr!=a_5.ref().end(); ++x_5_itr){
          std::pair<Rope, mfeanswer_v4>  x_5 = *x_5_itr;
          std::pair<Rope, mfeanswer_v4>  ans = incl(x_5);
          push_back( answers, ans);
        }
      }

    erase( a_5);
  }


  if (((t_0_j - t_0_i) >= 8))
    {
      for(      unsigned int t_0_k_1 = (t_0_i + 7); (t_0_k_1 <= (t_0_j - 1)); ++t_0_k_1)
      {
        TUSubsequence ret_12 = REGION(t_0_seq, t_0_k_1, t_0_j);
        TUSubsequence a_8 = ret_12;
        if (is_not_empty(a_8))
        {
          hhpp_hash_h ret_10;
          empty(ret_10);
          if (((t_0_k_1 - t_0_i) >= 7))
          {
            hhpp_hash_h ret_11 = nt_dangle(t_0_i, t_0_k_1);
            hhpp_hash_h a_7 = ret_11;
            if (is_not_empty(a_7))
              {
                for (hhpp_hash_h::iterator x_7_itr = a_7.ref().begin(); x_7_itr!=a_7.ref().end(); ++x_7_itr){
                  std::pair<Rope, mfeanswer_v4>  x_7 = *x_7_itr;
                  std::pair<Rope, mfeanswer_v4>  ans = incl(x_7);
                  push_back( ret_10, ans);
                }
              }

            erase( a_7);
          }

          finalize( ret_10);
          hhpp_hash_h a_6 = ret_10;
          if (is_not_empty(a_6))
            {
              for (hhpp_hash_h::iterator x_6_itr = a_6.ref().begin(); x_6_itr!=a_6.ref().end(); ++x_6_itr){
                std::pair<Rope, mfeanswer_v4>  x_6 = *x_6_itr;
                std::pair<Rope, mfeanswer_v4>  ans = addss(x_6, a_8);
                push_back( answers, ans);
              }
            }

          erase( a_6);
        }

        erase( a_8);
      }

    }

  hash_filter( answers);
  finalize( answers);
  ml_comps1_table.set( t_0_i, t_0_j, answers);
  return ml_comps1_table.get(t_0_i, t_0_j);
}

hhpp_hash_h hhpp::nt_multiloop(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 18))
    {
      return LBRope_firstG_mfeanswer_v4_secondG_EMhdecl0x2c432e0_zero;
    }

  hhpp_hash_h answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 18))
    {
      if (stackpairing(t_0_seq, t_0_i, t_0_j))
      {
        TUSubsequence ret_5 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_4 = ret_5;
        if (is_not_empty(a_4))
        {
          TUSubsequence ret_4 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
          TUSubsequence a_3 = ret_4;
          if (is_not_empty(a_3))
          {
            TUSubsequence ret_2 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
            TUSubsequence a_1 = ret_2;
            if (is_not_empty(a_1))
            {
              TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
              TUSubsequence a_0 = ret_1;
              if (is_not_empty(a_0))
              {
                hhpp_hash_h ret_3 = nt_ml_comps((t_0_i + 2), (t_0_j - 2));
                hhpp_hash_h a_2 = ret_3;
                if (is_not_empty(a_2))
                  {
                    for (hhpp_hash_h::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                      std::pair<Rope, mfeanswer_v4>  x_2 = *x_2_itr;
                      std::pair<Rope, mfeanswer_v4>  ans = ml(a_0, a_1, x_2, a_3, a_4);
                      push_back( answers, ans);
                    }
                  }

                erase( a_2);
              }

              erase( a_0);
            }

            erase( a_1);
          }

          erase( a_3);
        }

        erase( a_4);
      }

      else
        {
          empty( answers);
        }

    }


  if (((t_0_j - t_0_i) >= 19))
    {
      if (stackpairing(t_0_seq, t_0_i, t_0_j))
      {
        TUSubsequence ret_12 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_10 = ret_12;
        if (is_not_empty(a_10))
        {
          TUSubsequence ret_11 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
          TUSubsequence a_9 = ret_11;
          if (is_not_empty(a_9))
          {
            TUSubsequence ret_9 = BASE(t_0_seq, (t_0_i + 2), ((t_0_i + 2) + 1));
            TUSubsequence a_7 = ret_9;
            if (is_not_empty(a_7))
            {
              TUSubsequence ret_8 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
              TUSubsequence a_6 = ret_8;
              if (is_not_empty(a_6))
              {
                TUSubsequence ret_7 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
                TUSubsequence a_5 = ret_7;
                if (is_not_empty(a_5))
                {
                  hhpp_hash_h ret_10 = nt_ml_comps((t_0_i + 3), (t_0_j - 2));
                  hhpp_hash_h a_8 = ret_10;
                  if (is_not_empty(a_8))
                    {
                      for (hhpp_hash_h::iterator x_8_itr = a_8.ref().begin(); x_8_itr!=a_8.ref().end(); ++x_8_itr){
                        std::pair<Rope, mfeanswer_v4>  x_8 = *x_8_itr;
                        std::pair<Rope, mfeanswer_v4>  ans = mldl(a_5, a_6, a_7, x_8, a_9, a_10);
                        push_back( answers, ans);
                      }
                    }

                  erase( a_8);
                }

                erase( a_5);
              }

              erase( a_6);
            }

            erase( a_7);
          }

          erase( a_9);
        }

        erase( a_10);
      }

      else
        {
          empty( answers);
        }

    }


  if (((t_0_j - t_0_i) >= 19))
    {
      if (stackpairing(t_0_seq, t_0_i, t_0_j))
      {
        TUSubsequence ret_19 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_16 = ret_19;
        if (is_not_empty(a_16))
        {
          TUSubsequence ret_18 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
          TUSubsequence a_15 = ret_18;
          if (is_not_empty(a_15))
          {
            TUSubsequence ret_17 = BASE(t_0_seq, (t_0_j - 3), (t_0_j - 2));
            TUSubsequence a_14 = ret_17;
            if (is_not_empty(a_14))
            {
              TUSubsequence ret_15 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
              TUSubsequence a_12 = ret_15;
              if (is_not_empty(a_12))
              {
                TUSubsequence ret_14 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
                TUSubsequence a_11 = ret_14;
                if (is_not_empty(a_11))
                {
                  hhpp_hash_h ret_16 = nt_ml_comps((t_0_i + 2), (t_0_j - 3));
                  hhpp_hash_h a_13 = ret_16;
                  if (is_not_empty(a_13))
                    {
                      for (hhpp_hash_h::iterator x_13_itr = a_13.ref().begin(); x_13_itr!=a_13.ref().end(); ++x_13_itr){
                        std::pair<Rope, mfeanswer_v4>  x_13 = *x_13_itr;
                        std::pair<Rope, mfeanswer_v4>  ans = mldr(a_11, a_12, x_13, a_14, a_15, a_16);
                        push_back( answers, ans);
                      }
                    }

                  erase( a_13);
                }

                erase( a_11);
              }

              erase( a_12);
            }

            erase( a_14);
          }

          erase( a_15);
        }

        erase( a_16);
      }

      else
        {
          empty( answers);
        }

    }


  if (((t_0_j - t_0_i) >= 20))
    {
      if (stackpairing(t_0_seq, t_0_i, t_0_j))
      {
        TUSubsequence ret_27 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_23 = ret_27;
        if (is_not_empty(a_23))
        {
          TUSubsequence ret_26 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
          TUSubsequence a_22 = ret_26;
          if (is_not_empty(a_22))
          {
            TUSubsequence ret_25 = BASE(t_0_seq, (t_0_j - 3), (t_0_j - 2));
            TUSubsequence a_21 = ret_25;
            if (is_not_empty(a_21))
            {
              TUSubsequence ret_23 = BASE(t_0_seq, (t_0_i + 2), ((t_0_i + 2) + 1));
              TUSubsequence a_19 = ret_23;
              if (is_not_empty(a_19))
              {
                TUSubsequence ret_22 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
                TUSubsequence a_18 = ret_22;
                if (is_not_empty(a_18))
                {
                  TUSubsequence ret_21 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
                  TUSubsequence a_17 = ret_21;
                  if (is_not_empty(a_17))
                  {
                    hhpp_hash_h ret_24 = nt_ml_comps((t_0_i + 3), (t_0_j - 3));
                    hhpp_hash_h a_20 = ret_24;
                    if (is_not_empty(a_20))
                      {
                        for (hhpp_hash_h::iterator x_20_itr = a_20.ref().begin(); x_20_itr!=a_20.ref().end(); ++x_20_itr){
                          std::pair<Rope, mfeanswer_v4>  x_20 = *x_20_itr;
                          std::pair<Rope, mfeanswer_v4>  ans = mldlr(a_17, a_18, a_19, x_20, a_21, a_22, a_23);
                          push_back( answers, ans);
                        }
                      }

                    erase( a_20);
                  }

                  erase( a_17);
                }

                erase( a_18);
              }

              erase( a_19);
            }

            erase( a_21);
          }

          erase( a_22);
        }

        erase( a_23);
      }

      else
        {
          empty( answers);
        }

    }

  hash_filter( answers);
  finalize( answers);
  return answers;
}

hhpp_hash_h hhpp::nt_rightB(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 12))
    {
      return LBRope_firstG_mfeanswer_v4_secondG_EMhdecl0x2c432e0_zero;
    }

  hhpp_hash_h answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 12))
    {
      if (stackpairing(t_0_seq, t_0_i, t_0_j))
      {
        TUSubsequence ret_7 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_6 = ret_7;
        if (is_not_empty(a_6))
        {
          TUSubsequence ret_6 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
          TUSubsequence a_5 = ret_6;
          if (is_not_empty(a_5))
          {
            TUSubsequence ret_2 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
            TUSubsequence a_1 = ret_2;
            if (is_not_empty(a_1))
            {
              TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
              TUSubsequence a_0 = ret_1;
              if (is_not_empty(a_0))
              {
                hhpp_hash_h ret_3;
                empty(ret_3);
                if ((((t_0_j - 2) - (t_0_i + 2)) >= 8))
                  {
                    for(                    unsigned int t_0_k_0 = ((t_0_i + 2) + 7); (t_0_k_0 <= ((t_0_j - 2) - 1)); ++t_0_k_0)
                    {
                      TUSubsequence ret_5 = REGION(t_0_seq, t_0_k_0, (t_0_j - 2));
                      TUSubsequence a_4 = ret_5;
                      if (is_not_empty(a_4))
                      {
                        hhpp_hash_h ret_4 = nt_closed((t_0_i + 2), t_0_k_0);
                        hhpp_hash_h a_3 = ret_4;
                        if (is_not_empty(a_3))
                          {
                            for (hhpp_hash_h::iterator x_3_itr = a_3.ref().begin(); x_3_itr!=a_3.ref().end(); ++x_3_itr){
                              std::pair<Rope, mfeanswer_v4>  x_3 = *x_3_itr;
                              std::pair<Rope, mfeanswer_v4>  ans = br(x_3, a_4);
                              push_back( ret_3, ans);
                            }
                          }

                        erase( a_3);
                      }

                      erase( a_4);
                    }

                  }

                finalize( ret_3);
                hhpp_hash_h a_2 = ret_3;
                if (is_not_empty(a_2))
                  {
                    for (hhpp_hash_h::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                      std::pair<Rope, mfeanswer_v4>  x_2 = *x_2_itr;
                      std::pair<Rope, mfeanswer_v4>  ans = sp(a_0, a_1, x_2, a_5, a_6);
bool lmCompliant = true;

if (_locallymin) {
//3_a
int rightBE_before_delete = 0;
if (loop_complete_table_energy.is_tabulated(a_1.i, x_2.second.prevSubword.i, x_2.second.prevSubword.j, a_5.j)) {
  rightBE_before_delete = loop_complete_table_energy.get(a_1.i, x_2.second.prevSubword.i, x_2.second.prevSubword.j, a_5.j);
} else {
  rightBE_before_delete = br_energy(REGION(t_0_seq,a_1.i,a_5.j),REGION(t_0_seq,x_2.second.prevSubword.j,a_5.j-1));
  loop_complete_table_energy.set(a_1.i, x_2.second.prevSubword.i, x_2.second.prevSubword.j, a_5.j, rightBE_before_delete);
}

int srE_before_delete = 0;
if (loop_complete_table_energy.is_tabulated(x_2.second.prevSubword.i, x_2.second.prevSubword.i+1, x_2.second.prevSubword.j-1, x_2.second.prevSubword.j)) {
  srE_before_delete = loop_complete_table_energy.get(x_2.second.prevSubword.i, x_2.second.prevSubword.i+1, x_2.second.prevSubword.j-1, x_2.second.prevSubword.j);
} else {
  srE_before_delete = sr_energy(x_2.second.prevSubword, x_2.second.prevSubword);
  loop_complete_table_energy.set(x_2.second.prevSubword.i, x_2.second.prevSubword.i+1, x_2.second.prevSubword.j-1, x_2.second.prevSubword.j, srE_before_delete);
}

int iloopE_after_delete = 0;
if (loop_complete_table_energy.is_tabulated(a_1.i, x_2.second.prevSubword.i+1, x_2.second.prevSubword.j-1, a_5.j)) {
  iloopE_after_delete = loop_complete_table_energy.get(a_1.i, x_2.second.prevSubword.i+1, x_2.second.prevSubword.j-1, a_5.j); 
} else {
  iloopE_after_delete = il_energy(REGION(t_0_seq,a_1.i+1,x_2.second.prevSubword.i+1),REGION(t_0_seq,x_2.second.prevSubword.j-1,a_5.j-1));
  loop_complete_table_energy.set(a_1.i, x_2.second.prevSubword.i+1, x_2.second.prevSubword.j-1, a_5.j, iloopE_after_delete);
}

if ( \
     ( !_shouldermin && (iloopE_after_delete <= (srE_before_delete + rightBE_before_delete)) ) \
     || ( _shouldermin && (iloopE_after_delete < (srE_before_delete + rightBE_before_delete)) ) \
   ) {
  lmCompliant = false;
}     

//3_c
if (lmCompliant) {
  iloopE_after_delete = 0;
  if (loop_complete_table_energy.is_tabulated(a_0.i, x_2.second.prevSubword.i, x_2.second.prevSubword.j, a_6.j)) {
   iloopE_after_delete = loop_complete_table_energy.get(a_0.i, x_2.second.prevSubword.i, x_2.second.prevSubword.j, a_6.j); 
  } else {
    iloopE_after_delete = il_energy(REGION(t_0_seq,a_0.i+1,x_2.second.prevSubword.i),REGION(t_0_seq,x_2.second.prevSubword.j,a_6.j-1));
    loop_complete_table_energy.set(a_0.i, x_2.second.prevSubword.i, x_2.second.prevSubword.j, a_6.j, iloopE_after_delete);
  }

  srE_before_delete = 0;
  if (loop_complete_table_energy.is_tabulated(a_0.i, a_1.i, a_5.j, a_6.j)) {
    srE_before_delete = loop_complete_table_energy.get(a_0.i, a_1.i, a_5.j, a_6.j);
  } else {
    srE_before_delete = sr_energy(ans.second.subword, ans.second.subword);
    loop_complete_table_energy.set(a_0.i, a_1.i, a_5.j, a_6.j, srE_before_delete);
  }

  if ( \
       ( !_shouldermin && (iloopE_after_delete <= (rightBE_before_delete + srE_before_delete)) ) \
       || ( _shouldermin && (iloopE_after_delete < (rightBE_before_delete + srE_before_delete)) ) \
     ) {
    lmCompliant = false;
  } 
}

//3_ss
if (lmCompliant) {

  if ((x_2.second.subword.j - x_2.second.prevSubword.j) >= 5) {  // contains iloop    
    int next_ss_dangle_energy_1 = 0;
    int last_ss_dangle_energy_1 = 0;
    TUSubsequence multi_inner_stem = REGION(t_0_seq,a_1.i,a_5.j);
    TUSubsequence new_stem;
    for (unsigned int t_0_k_0 = x_2.second.prevSubword.j; t_0_k_0 <= (x_2.second.subword.j-5); ++t_0_k_0) {
      if (lmCompliant == false) {
	break; 
      }

      for(unsigned int t_0_k_1 = (t_0_k_0+5); (t_0_k_1 <= x_2.second.subword.j); ++t_0_k_1) {
	if (basepairing(t_0_seq, t_0_k_0, t_0_k_1)) {
	  new_stem = REGION(t_0_seq,t_0_k_0,t_0_k_1);
          if ((t_0_k_0 - x_2.second.prevSubword.j) == 1) {
	    next_ss_dangle_energy_1 = min(dr_energy(x_2.second.prevSubword, x_2.second.prevSubword), dl_energy(new_stem, new_stem));
	  } else if ((t_0_k_0 - x_2.second.prevSubword.j) > 1) {
	    next_ss_dangle_energy_1 = dr_energy(x_2.second.prevSubword, x_2.second.prevSubword) + dl_energy(new_stem, new_stem);
	  } else {
	    next_ss_dangle_energy_1 = 0;
	  }
	  
	  // NOTE: t_0_k_1 has 1 offset, it is j-like index
          if ((x_2.second.subword.j - t_0_k_1) == 1) {
	    last_ss_dangle_energy_1 = min(dr_energy(new_stem, new_stem), dri_energy(multi_inner_stem, multi_inner_stem));
	  } else if ((x_2.second.subword.j - t_0_k_1) > 1) {
	    last_ss_dangle_energy_1 = dr_energy(new_stem, new_stem) + dri_energy(multi_inner_stem, multi_inner_stem);
	  } else {
	    last_ss_dangle_energy_1 = 0;
	  }
	  
	  
	  //ml_energy() + ul_energy() + e.energy + sr_energy(res.firstStem,res.firstStem) + termau_energy(innerstem,innerstem)
	  if ( \
	       ( !_shouldermin && ((ml_energy() + ul_energy() + (2*ul_energy() + x_2.second.prevE + termau_energy(x_2.second.prevSubword, x_2.second.prevSubword) + next_ss_dangle_energy_1 + nt_hairpin_complete(t_0_k_0,t_0_k_1).second.energy + termau_energy(new_stem, new_stem) + last_ss_dangle_energy_1) + sr_energy(ans.second.subword,ans.second.subword) + termau_energy(multi_inner_stem,multi_inner_stem)) <= ans.second.energy) ) \
	       || ( _shouldermin && ((ml_energy() + ul_energy() + (2*ul_energy() + x_2.second.prevE + termau_energy(x_2.second.prevSubword, x_2.second.prevSubword) + next_ss_dangle_energy_1 + nt_hairpin_complete(t_0_k_0,t_0_k_1).second.energy + termau_energy(new_stem, new_stem) + last_ss_dangle_energy_1) + sr_energy(ans.second.subword,ans.second.subword) + termau_energy(multi_inner_stem,multi_inner_stem)) < ans.second.energy) ) \
	     ) {
	    lmCompliant = false;
	    break;
	  }
	  
	}
      }
    }
  }
}

}

if (lmCompliant) {
  push_back( answers, ans);
}
                      //push_back( answers, ans);
                    }
                  }

                erase( a_2);
              }

              erase( a_0);
            }

            erase( a_1);
          }

          erase( a_5);
        }

        erase( a_6);
      }

      else
        {
          empty( answers);
        }

    }

  hash_filter( answers);
  finalize( answers);
  return answers;
}

hhpp_hash_h hhpp::nt_stack(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 9))
    {
      return LBRope_firstG_mfeanswer_v4_secondG_EMhdecl0x2c432e0_zero;
    }

  hhpp_hash_h answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 9))
    {
      if (basepairing(t_0_seq, t_0_i, t_0_j))
      {
        TUSubsequence ret_3 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_2 = ret_3;
        if (is_not_empty(a_2))
        {
          TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
          TUSubsequence a_0 = ret_1;
          if (is_not_empty(a_0))
          {
            hhpp_hash_h ret_2 = nt_closed((t_0_i + 1), (t_0_j - 1));
            hhpp_hash_h a_1 = ret_2;
            if (is_not_empty(a_1))
              {
                for (hhpp_hash_h::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
                  std::pair<Rope, mfeanswer_v4>  x_1 = *x_1_itr;
                  std::pair<Rope, mfeanswer_v4>  ans = sr(a_0, x_1, a_2);
bool lmCompliant = true;

if (_locallymin) {
//4_a=4_c
int iloopE_after_delete = 0;
if (loop_complete_table_energy.is_tabulated(a_0.i, x_1.second.subword.i+1, x_1.second.subword.j-1, a_2.j)) {
  iloopE_after_delete = loop_complete_table_energy.get(a_0.i, x_1.second.subword.i+1, x_1.second.subword.j-1, a_2.j); 
} else {
  iloopE_after_delete = il_energy(REGION(t_0_seq,a_0.i+1,x_1.second.subword.i+1),REGION(t_0_seq,x_1.second.subword.j-1,a_2.j-1));
  //ASSERT_ERROR if (x_1.second.subword.i+1  x_1.second.subword.j-1)
  //ASSERT_ERROR   std::cout << "a=" << x_1.second.subword.i+1 << ", b=" << x_1.second.subword.j-1 << std::endl;
  loop_complete_table_energy.set(a_0.i, x_1.second.subword.i+1, x_1.second.subword.j-1, a_2.j, iloopE_after_delete);
}

int srE_before_delete_x1 = 0;
if (loop_complete_table_energy.is_tabulated(x_1.second.subword.i, x_1.second.subword.i+1, x_1.second.subword.j-1, x_1.second.subword.j)) {
  srE_before_delete_x1 = loop_complete_table_energy.get(x_1.second.subword.i, x_1.second.subword.i+1, x_1.second.subword.j-1, x_1.second.subword.j);
} else {
  srE_before_delete_x1 = sr_energy(x_1.second.subword, x_1.second.subword);
  loop_complete_table_energy.set(x_1.second.subword.i, x_1.second.subword.i+1, x_1.second.subword.j-1, x_1.second.subword.j, srE_before_delete_x1);
}

int srE_before_delete_ans = 0;
if (loop_complete_table_energy.is_tabulated(a_0.i, x_1.second.subword.i, x_1.second.subword.j, a_2.j)) {
  srE_before_delete_ans = loop_complete_table_energy.get(a_0.i, x_1.second.subword.i, x_1.second.subword.j, a_2.j);
} else {
  srE_before_delete_ans = sr_energy(ans.second.subword, ans.second.subword);
  loop_complete_table_energy.set(a_0.i, x_1.second.subword.i, x_1.second.subword.j, a_2.j, srE_before_delete_ans);
}

if ( \
     ( !_shouldermin && (iloopE_after_delete <= (srE_before_delete_x1 + srE_before_delete_ans)) ) \
     || ( _shouldermin && (iloopE_after_delete < (srE_before_delete_x1 + srE_before_delete_ans)) ) \
   ) {
  lmCompliant = false;
}

}

if (lmCompliant) {
  push_back( answers, ans);
}
                  //push_back( answers, ans);
                }
              }

            erase( a_1);
          }

          erase( a_0);
        }

        erase( a_2);
      }

      else
        {
          empty( answers);
        }

    }

  hash_filter( answers);
  finalize( answers);
  return answers;
}

hhpp_hash_h &  hhpp::nt_struct(unsigned int t_0_i)
{
  if (struct_table.is_tabulated(t_0_i))
    {
      return struct_table.get(t_0_i);
    }

  hhpp_hash_h answers;
  empty(answers);
  empty( answers);

  if (((t_0_right_most - t_0_i) >= 7))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 7); (t_0_k_0 <= t_0_right_most); ++t_0_k_0)
      {
        hhpp_hash_h ret_2 = nt_struct(t_0_k_0);
        hhpp_hash_h a_1 = ret_2;
        if (is_not_empty(a_1))
        {
          hhpp_hash_h ret_1 = nt_dangle(t_0_i, t_0_k_0);
          hhpp_hash_h a_0 = ret_1;
          if (is_not_empty(a_0))
            {
              for (hhpp_hash_h::iterator x_0_itr = a_0.ref().begin(); x_0_itr!=a_0.ref().end(); ++x_0_itr){
                std::pair<Rope, mfeanswer_v4>  x_0 = *x_0_itr;
                for (hhpp_hash_h::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
                  std::pair<Rope, mfeanswer_v4>  x_1 = *x_1_itr;
                  std::pair<Rope, mfeanswer_v4>  ans = cadd(x_0, x_1);
bool lmCompliant = true;

// first_ss:       ans.second.subword.i, ans.second.outermost_initstem_i
// next_ss:        ans.second.next_ss_i, ans.second.next_ss_j
// after_next_ss:  ans.second.after_next_ss_i, ans.second.after_next_ss_j
// before_last_ss: ans.second.before_last_ss_i, ans.second.before_last_ss_j
// last_ss:        ans.second.outermost_initstem_j, ans.second.subword.j


if (_locallymin) {
if (x_1.second.next_ss_i != -1) {  // no. of inistem >= 2
  //8_a: for most right initstem
  //  ..((...))...((...)).....  old
  //  ..((...))a(b((...))c)d..  new
  if (ans.second.after_next_ss_j == -1) {  // no. of inistem == 2
    // if dangle bases exist on both sides
    int next_ss_dangle_energy_0 = 0;
    int last_ss_dangle_energy_0 = 0;
    if ((ans.second.next_ss_j - ans.second.next_ss_i) == 1) {
      next_ss_dangle_energy_0 = min(dr_energy(x_0.second.firstStem, x_0.second.firstStem), dl_energy(x_1.second.firstStem, x_1.second.firstStem));
    } else if ((ans.second.next_ss_j - ans.second.next_ss_i) > 1) {
      next_ss_dangle_energy_0 = dr_energy(x_0.second.firstStem, x_0.second.firstStem) + dl_energy(x_1.second.firstStem, x_1.second.firstStem);
    }
    if ((ans.second.subword.j - ans.second.outermost_initstem_j) >= 1) {
      last_ss_dangle_energy_0 = dr_energy(x_1.second.firstStem, x_1.second.firstStem);
    }

    // try to ADD a bp
    int next_ss_dangle_energy_1 = 0;
    int last_ss_dangle_energy_1 = 0;
    int additional_energy_1 = 0;
    TUSubsequence extended_stem;
    for (unsigned int next_ss_pos = ans.second.next_ss_i; next_ss_pos < ans.second.next_ss_j; next_ss_pos++) {
      if (!lmCompliant) {
	break;
      }
      for (unsigned int last_ss_pos = ans.second.outermost_initstem_j; last_ss_pos < ans.second.subword.j; last_ss_pos++) {
	if (basepairing(t_0_seq, next_ss_pos, last_ss_pos+1)) {
	  extended_stem = REGION(t_0_seq,next_ss_pos,last_ss_pos+1);
	  if (loop_complete_table_energy.is_tabulated(next_ss_pos, (unsigned int)ans.second.next_ss_j, (unsigned int)ans.second.outermost_initstem_j, last_ss_pos+1)) {
	    additional_energy_1 = loop_complete_table_energy.get(next_ss_pos, (unsigned int)ans.second.next_ss_j, (unsigned int)ans.second.outermost_initstem_j, last_ss_pos+1); 
	  } else {
	    if ((ans.second.next_ss_j - next_ss_pos) == 1 ) {   //b
	      if ((last_ss_pos - ans.second.outermost_initstem_j) == 0) {       //c
		additional_energy_1 = sr_energy(extended_stem, extended_stem);
	      } else if ((last_ss_pos - ans.second.outermost_initstem_j) > 0) { //c
		additional_energy_1 = br_energy(extended_stem, REGION(t_0_seq,(unsigned int)ans.second.outermost_initstem_j,last_ss_pos));
	      }
	    } else if ((ans.second.next_ss_j - next_ss_pos) > 1 ) {    //b
	      if ((last_ss_pos - ans.second.outermost_initstem_j) == 0) {               //c
		additional_energy_1 = bl_energy(REGION(t_0_seq, next_ss_pos+1, (unsigned int)ans.second.next_ss_j), extended_stem);
	      } else if ((last_ss_pos - ans.second.outermost_initstem_j) > 0) {         //c
		additional_energy_1 = il_energy(REGION(t_0_seq, next_ss_pos+1, (unsigned int)ans.second.next_ss_j), REGION(t_0_seq,(unsigned int)ans.second.outermost_initstem_j,last_ss_pos));
	      }
	    }

	    loop_complete_table_energy.set(next_ss_pos, (unsigned int)ans.second.next_ss_j, (unsigned int)ans.second.outermost_initstem_j, last_ss_pos+1, additional_energy_1);
	  }

	  
	  if ((next_ss_pos - ans.second.next_ss_i) == 1 ) {    //a
	    next_ss_dangle_energy_1 = min(dr_energy(x_0.second.firstStem, x_0.second.firstStem), dl_energy(extended_stem, extended_stem));
	  } else if ((next_ss_pos - ans.second.next_ss_i) > 1) {
	    next_ss_dangle_energy_1 = dr_energy(x_0.second.firstStem, x_0.second.firstStem) + dl_energy(extended_stem, extended_stem);         
	  } else {
	    // because of for-loop, the value are ensured with explicite assignment
	    next_ss_dangle_energy_1 = 0;
	  }
	  if ((ans.second.subword.j - last_ss_pos) >= 2) {  //d
	    last_ss_dangle_energy_1 = dr_energy(extended_stem, extended_stem);
	  } else {
	    last_ss_dangle_energy_1 = 0;
	  }

	  //std::cout << "8_a: " << x_0 << x_1 << ans << next_ss_dangle_energy_1 <<"+"<< last_ss_dangle_energy_1 <<"+"<< additional_energy_1 <<"<>"<< next_ss_dangle_energy_0 <<"+"<< last_ss_dangle_energy_0 << std::endl;
	  if ( \
	       ( !_shouldermin && ((next_ss_dangle_energy_1 + last_ss_dangle_energy_1 + additional_energy_1 + termau_energy(extended_stem,extended_stem)) <= (next_ss_dangle_energy_0 + last_ss_dangle_energy_0 + termau_energy(x_1.second.firstStem,x_1.second.firstStem))) ) \
	       || ( _shouldermin && ((next_ss_dangle_energy_1 + last_ss_dangle_energy_1 + additional_energy_1 + termau_energy(extended_stem,extended_stem)) < (next_ss_dangle_energy_0 + last_ss_dangle_energy_0 + termau_energy(x_1.second.firstStem,x_1.second.firstStem))) ) \
	     ) {
	    lmCompliant = false;
	    break;
	  }
	}
      }
    }
    // try to DEL a bp
    //  ..((...))...((.((...))..)).....  old
    //  ..((...))....(.((...))..)......  new
    if (lmCompliant) {
      int additional_energy_0 = 0;
      TUSubsequence inner_stem = REGION(t_0_seq,(unsigned int)(ans.second.next_ss_j+1),(unsigned int)(ans.second.outermost_initstem_j-1));
      if (loop_complete_table_energy.is_tabulated((unsigned int)ans.second.next_ss_j, (unsigned int)(ans.second.next_ss_j+1), (unsigned int)(ans.second.outermost_initstem_j-1), (unsigned int)ans.second.outermost_initstem_j)) {
	additional_energy_0 = loop_complete_table_energy.get((unsigned int)ans.second.next_ss_j, (unsigned int)(ans.second.next_ss_j+1), (unsigned int)(ans.second.outermost_initstem_j-1), (unsigned int)ans.second.outermost_initstem_j); 
      } else {
	additional_energy_0 = sr_energy(x_1.second.firstStem, x_1.second.firstStem);

	loop_complete_table_energy.set((unsigned int)ans.second.next_ss_j, (unsigned int)(ans.second.next_ss_j+1), (unsigned int)(ans.second.outermost_initstem_j-1), (unsigned int)ans.second.outermost_initstem_j, additional_energy_0);
      }

      if ((ans.second.next_ss_j - ans.second.next_ss_i) == 0 ) {    //a
	next_ss_dangle_energy_1 = min(dr_energy(x_0.second.firstStem, x_0.second.firstStem), dl_energy(inner_stem, inner_stem));
      } else {
	next_ss_dangle_energy_1 = dr_energy(x_0.second.firstStem, x_0.second.firstStem) + dl_energy(inner_stem, inner_stem);         
      }
      //d
      last_ss_dangle_energy_1 = dr_energy(inner_stem, inner_stem);

      if ( \
	   ( !_shouldermin && ((next_ss_dangle_energy_1 + last_ss_dangle_energy_1 + termau_energy(inner_stem,inner_stem)) <= (next_ss_dangle_energy_0 + last_ss_dangle_energy_0 + additional_energy_0 + termau_energy(x_1.second.firstStem,x_1.second.firstStem))) ) \
	   || ( _shouldermin && ((next_ss_dangle_energy_1 + last_ss_dangle_energy_1 + termau_energy(inner_stem,inner_stem)) < (next_ss_dangle_energy_0 + last_ss_dangle_energy_0 + additional_energy_0 + termau_energy(x_1.second.firstStem,x_1.second.firstStem))) ) \
         ) {
	lmCompliant = false;
      } 
    }
    
  }


  //8_b
  // from second initstem
  //  ...         
  //  ...((...))...((...))...((...)).....  old
  //  ...((...))a(b((...))c)d((...)).....  new
  //          next_ss_pos  |
  //                      after_next_ss_pos
  else {  // if (ans.second.after_next_ss_j != -1) ==> no. of inistem > 2   
    // if dangle bases exist on both sides
    int next_ss_dangle_energy_0 = 0;
    int after_next_ss_dangle_energy_0 = 0;
    if ((ans.second.next_ss_j - ans.second.next_ss_i) == 1) {
      next_ss_dangle_energy_0 = min(dr_energy(x_0.second.firstStem, x_0.second.firstStem), dl_energy(x_1.second.firstStem, x_1.second.firstStem));
    } else if ((ans.second.next_ss_j - ans.second.next_ss_i) > 1) {
      next_ss_dangle_energy_0 = dr_energy(x_0.second.firstStem, x_0.second.firstStem) + dl_energy(x_1.second.firstStem, x_1.second.firstStem);
    }
    if ((ans.second.after_next_ss_j - ans.second.after_next_ss_i) == 1) {
      after_next_ss_dangle_energy_0 = min(dr_energy(x_1.second.firstStem, x_1.second.firstStem), dl_energy(x_1.second.secondStem, x_1.second.secondStem));
    } else if ((ans.second.after_next_ss_j - ans.second.after_next_ss_i) > 1) {
      after_next_ss_dangle_energy_0 = dr_energy(x_1.second.firstStem, x_1.second.firstStem) + dl_energy(x_1.second.secondStem, x_1.second.secondStem);
    }

    // try to ADD a bp
    int next_ss_dangle_energy_1 = 0;
    int after_next_ss_dangle_energy_1 = 0;
    int additional_energy_1 = 0;
    TUSubsequence extended_stem;
    for (unsigned int next_ss_pos = ans.second.next_ss_i; next_ss_pos < ans.second.next_ss_j; next_ss_pos++) {
      if (!lmCompliant) {
	break;
      }
      for (unsigned int after_next_ss_pos = ans.second.after_next_ss_i; after_next_ss_pos < ans.second.after_next_ss_j; after_next_ss_pos++) {
	if (basepairing(t_0_seq, next_ss_pos, after_next_ss_pos+1)) {
	  extended_stem = REGION(t_0_seq,next_ss_pos,after_next_ss_pos+1);
	  if (loop_complete_table_energy.is_tabulated(next_ss_pos, (unsigned int)ans.second.next_ss_j, (unsigned int)ans.second.after_next_ss_i, after_next_ss_pos+1)) {
	    additional_energy_1 = loop_complete_table_energy.get(next_ss_pos, (unsigned int)ans.second.next_ss_j, (unsigned int)ans.second.after_next_ss_i, after_next_ss_pos+1); 
	  } else {
	    if ((ans.second.next_ss_j - next_ss_pos) == 1 ) {   //b
	      if ((after_next_ss_pos - ans.second.after_next_ss_i) == 0) {       //c
		additional_energy_1 = sr_energy(extended_stem, extended_stem);
	      } else if ((after_next_ss_pos - ans.second.after_next_ss_i) > 0) { //c
		additional_energy_1 = br_energy(extended_stem, REGION(t_0_seq,(unsigned int)ans.second.after_next_ss_i,after_next_ss_pos));
	      }
	    } else if ((ans.second.next_ss_j - next_ss_pos) > 1 ) {    //b
	      if ((after_next_ss_pos - ans.second.after_next_ss_i) == 0) {               //c
		additional_energy_1 = bl_energy(REGION(t_0_seq, next_ss_pos+1, (unsigned int)ans.second.next_ss_j), extended_stem);
	      } else if ((after_next_ss_pos - ans.second.after_next_ss_i) > 0) {         //c
		additional_energy_1 = il_energy(REGION(t_0_seq, next_ss_pos+1, (unsigned int)ans.second.next_ss_j), REGION(t_0_seq,(unsigned int)ans.second.after_next_ss_i,after_next_ss_pos));
	      }
	    }

	    loop_complete_table_energy.set(next_ss_pos, (unsigned int)ans.second.next_ss_j, (unsigned int)ans.second.after_next_ss_i, after_next_ss_pos+1, additional_energy_1);
	  }

	  
	  if ((next_ss_pos - ans.second.next_ss_i) == 1 ) {    //a
	    next_ss_dangle_energy_1 = min(dr_energy(x_0.second.firstStem, x_0.second.firstStem), dl_energy(extended_stem, extended_stem));
	  } else if ((next_ss_pos - ans.second.next_ss_i) > 1) {
	    next_ss_dangle_energy_1 = dr_energy(x_0.second.firstStem, x_0.second.firstStem) + dl_energy(extended_stem, extended_stem);         
	  } else {
	    next_ss_dangle_energy_1 = 0;
	  }
	  if ((ans.second.after_next_ss_j - after_next_ss_pos) == 2) {  //d
	    after_next_ss_dangle_energy_1 = min(dr_energy(extended_stem, extended_stem), dl_energy(x_1.second.secondStem, x_1.second.secondStem));
	  } else if ((ans.second.after_next_ss_j - after_next_ss_pos) > 2) {
	    after_next_ss_dangle_energy_1 = dr_energy(extended_stem, extended_stem) + dl_energy(x_1.second.secondStem, x_1.second.secondStem);
	  } else {
	    after_next_ss_dangle_energy_1 = 0;
	  }

	  if ( \
	       ( !_shouldermin && ((next_ss_dangle_energy_1 + after_next_ss_dangle_energy_1 + additional_energy_1 + termau_energy(extended_stem,extended_stem)) <= (next_ss_dangle_energy_0 + after_next_ss_dangle_energy_0 + termau_energy(x_1.second.firstStem,x_1.second.firstStem))) ) \
	       || ( _shouldermin && ((next_ss_dangle_energy_1 + after_next_ss_dangle_energy_1 + additional_energy_1 + termau_energy(extended_stem,extended_stem)) < (next_ss_dangle_energy_0 + after_next_ss_dangle_energy_0 + termau_energy(x_1.second.firstStem,x_1.second.firstStem))) ) \
	     ) {
	    lmCompliant = false;
	    break;
	  }
	}
      }
    }
    // try to DEL a bp
    //  ...((...))...((...))...((...)).....  old
    //  ...((...))....(...)....((...)).....  new
    if (lmCompliant) {
      int additional_energy_0 = 0;
      TUSubsequence inner_stem = REGION(t_0_seq,(unsigned int)(ans.second.next_ss_j+1),(unsigned int)(ans.second.after_next_ss_i-1));
      if (loop_complete_table_energy.is_tabulated((unsigned int)ans.second.next_ss_j, (unsigned int)(ans.second.next_ss_j+1), (unsigned int)(ans.second.after_next_ss_i-1), (unsigned int)ans.second.after_next_ss_i)) {
	additional_energy_0 = loop_complete_table_energy.get((unsigned int)ans.second.next_ss_j, (unsigned int)(ans.second.next_ss_j+1), (unsigned int)(ans.second.after_next_ss_i-1), (unsigned int)ans.second.after_next_ss_i); 
      } else {
	additional_energy_0 = sr_energy(x_1.second.firstStem, x_1.second.firstStem);

	loop_complete_table_energy.set((unsigned int)ans.second.next_ss_j, (unsigned int)(ans.second.next_ss_j+1), (unsigned int)(ans.second.after_next_ss_i-1), (unsigned int)ans.second.after_next_ss_i, additional_energy_0);
      }

      if ((ans.second.next_ss_j - ans.second.next_ss_i) == 0 ) {    //a
	next_ss_dangle_energy_1 = min(dr_energy(x_0.second.firstStem, x_0.second.firstStem), dl_energy(inner_stem, inner_stem));
      } else {
	next_ss_dangle_energy_1 = dr_energy(x_0.second.firstStem, x_0.second.firstStem) + dl_energy(inner_stem, inner_stem);         
      }
      if ((ans.second.after_next_ss_j - ans.second.after_next_ss_i) == 0) {  //d
	after_next_ss_dangle_energy_1 = min(dr_energy(inner_stem, inner_stem), dl_energy(x_1.second.secondStem, x_1.second.secondStem));
      } else {
	after_next_ss_dangle_energy_1 = dr_energy(inner_stem, inner_stem) + dl_energy(x_1.second.secondStem, x_1.second.secondStem);
      }

      if ( \
	   ( !_shouldermin && ((next_ss_dangle_energy_1 + after_next_ss_dangle_energy_1 + termau_energy(inner_stem,inner_stem)) <= (next_ss_dangle_energy_0 + after_next_ss_dangle_energy_0 + additional_energy_0 + termau_energy(x_1.second.firstStem,x_1.second.firstStem))) ) \
	   || ( _shouldermin && ((next_ss_dangle_energy_1 + after_next_ss_dangle_energy_1 + termau_energy(inner_stem,inner_stem)) < (next_ss_dangle_energy_0 + after_next_ss_dangle_energy_0 + additional_energy_0 + termau_energy(x_1.second.firstStem,x_1.second.firstStem))) ) \
         ) {
	lmCompliant = false;
      } 
    }
  }
} else {  // no. of inistem == 1
  //8_ss
  //NOTE: RISKY in this case, ans.second.lastStem is not generated yet [==<lastPos, lastPos>], make use of firstStem since ans is an one-stem structure and firstStem==lastStem
  if ((ans.second.subword.j - ans.second.outermost_initstem_j) >= 5) {
    int last_ss_dangle_energy_1 = 0;
    int after_last_ss_dangle_energy_1 = 0;
    TUSubsequence new_stem;
    for (unsigned int t_0_k_0 = ans.second.outermost_initstem_j; t_0_k_0 <= (ans.second.subword.j-5); ++t_0_k_0) {
      if (lmCompliant == false) {
	break; 
      }

      for(unsigned int t_0_k_1 = (t_0_k_0+5); (t_0_k_1 <= ans.second.subword.j); ++t_0_k_1) {
	if (basepairing(t_0_seq, t_0_k_0, t_0_k_1)) {
	  new_stem = REGION(t_0_seq,t_0_k_0,t_0_k_1);
	  if ((t_0_k_0 - ans.second.outermost_initstem_j) == 1) {
	    last_ss_dangle_energy_1 = min(dr_energy(ans.second.firstStem, ans.second.firstStem), dl_energy(new_stem, new_stem));
	  } else if ((t_0_k_0 - ans.second.outermost_initstem_j) > 1) {
	    last_ss_dangle_energy_1 = dr_energy(ans.second.firstStem, ans.second.firstStem) + dl_energy(new_stem, new_stem);
	  } else {
	    last_ss_dangle_energy_1 = 0;
	  }
	  
	  // NOTE: t_0_k_1 has 1 offset, it is j-like index
	  if ((ans.second.subword.j - t_0_k_1) >= 1) {
	    after_last_ss_dangle_energy_1 = dr_energy(new_stem, new_stem);
	  } else {
	    after_last_ss_dangle_energy_1 = 0;
	  }
	  
	  //std::cout <<"8_ss:"<< ans <<"["<< ans.second.firstStem <<"]"<< ans.second.outermost_initstem_j <<","<< ans.second.subword.j <<","<< t_0_k_0 <<","<< t_0_k_1 <<":"<< last_ss_dangle_energy_1 <<"+"<< nt_hairpin_complete(t_0_k_0,t_0_k_1).second.energy <<"+"<< termau_energy(new_stem, new_stem) <<"+"<< after_last_ss_dangle_energy_1 <<"<>"<< dr_energy(ans.second.firstStem,ans.second.firstStem) << std::endl;	  
	  if ( \
	       ( !_shouldermin && ((last_ss_dangle_energy_1 + nt_hairpin_complete(t_0_k_0,t_0_k_1).second.energy + termau_energy(new_stem, new_stem) + after_last_ss_dangle_energy_1) <= dr_energy(ans.second.firstStem,ans.second.firstStem)) ) \
	       || ( _shouldermin && ((last_ss_dangle_energy_1 + nt_hairpin_complete(t_0_k_0,t_0_k_1).second.energy + termau_energy(new_stem, new_stem) + after_last_ss_dangle_energy_1) < dr_energy(ans.second.firstStem,ans.second.firstStem)) ) \
	     ) {
	    lmCompliant = false;
	    break;
	  }
	  
	}
      }
    }
  }
}
  
  
//8_c: additional calculation ==> (8_a + 8_c(or 8_d)) or (8_b + 8_c(or 8_d))
if (lmCompliant) {

  // first_ss_pos vs. next_ss_pos only for last round ending with cadd(..)
  // NOTE: x_0.second.firstStem==ans.second.firstStem and x_1.second.firstStem==ans.second.secondStem
                                       // ans.second.subword.i==x_0.second.subword.i
  if ((ans.second.next_ss_i != -1) && (ans.second.subword.i==0)) {  // (ans.second.next_ss_i != -1) means no. of inistem >= 1
    assert(ans.second.outermost_initstem_i<=1);
    int next_ss_dangle_energy_0 = 0;
    if ((ans.second.next_ss_j - ans.second.next_ss_i) == 1) {
      next_ss_dangle_energy_0 = min(dr_energy(ans.second.firstStem, ans.second.firstStem), dl_energy(ans.second.secondStem, ans.second.secondStem));
    } else if ((ans.second.next_ss_j - ans.second.next_ss_i) > 1) {
      next_ss_dangle_energy_0 = dr_energy(ans.second.firstStem, ans.second.firstStem) + dl_energy(ans.second.secondStem, ans.second.secondStem);
    }
    int next_ss_dangle_energy_1 = 0;
    if (ans.second.outermost_initstem_i==1) { 
      // if dangle bases exist on both sides
      int first_ss_dangle_energy_0 = dl_energy(ans.second.firstStem, ans.second.firstStem);

      // try to ADD a bp
      //     |-x_0-|----x_1------|   cadd
      //     .((...))...((...)).....  old
      //     (((...))c)d((...)).....  new
      
      //std::cout << (unsigned int)0 << std::endl;
      //TODO: define new variable representing (unsigned int)0 and use it in following
      int additional_energy_1 = 0;
      TUSubsequence extended_stem;
      for (unsigned int next_ss_pos = ans.second.next_ss_i; next_ss_pos < ans.second.next_ss_j; next_ss_pos++) {
	if (basepairing(t_0_seq, (unsigned int)0, next_ss_pos+1)) {
	  extended_stem = REGION(t_0_seq,(unsigned int)0,next_ss_pos+1);
	  if (loop_complete_table_energy.is_tabulated(0, 1, ans.second.next_ss_i, next_ss_pos+1)) {
	    additional_energy_1 = loop_complete_table_energy.get(0, 1, ans.second.next_ss_i, next_ss_pos+1); 
	  } else {
	    if ((next_ss_pos - ans.second.next_ss_i) == 0) {       //c
	      additional_energy_1 = sr_energy(extended_stem, extended_stem);
	    } else if ((next_ss_pos - ans.second.next_ss_i) > 0) { //c
	      additional_energy_1 = br_energy(extended_stem, REGION(t_0_seq,(unsigned int)ans.second.next_ss_i,next_ss_pos));
	    }

	    loop_complete_table_energy.set(0, 1, ans.second.next_ss_i, next_ss_pos+1, additional_energy_1);
	  }

	  if ((ans.second.next_ss_j - next_ss_pos) == 2) {  //d
	    next_ss_dangle_energy_1 = min(dr_energy(extended_stem, extended_stem), dl_energy(ans.second.secondStem, ans.second.secondStem));
	  } else if ((ans.second.next_ss_j - next_ss_pos) > 2) {
	    next_ss_dangle_energy_1 = dr_energy(extended_stem, extended_stem) + dl_energy(ans.second.secondStem, ans.second.secondStem);
	  } else {
	    next_ss_dangle_energy_1 = 0;
	  }

	  //std::cout << "8_c(0,"<<next_ss_pos<<"): " << x_0 << x_1 << ans << next_ss_dangle_energy_1 <<"+"<< additional_energy_1 <<"<>"<< first_ss_dangle_energy_0 <<"+"<< next_ss_dangle_energy_0 << std::endl;
	  if ( \
	       ( !_shouldermin && ((next_ss_dangle_energy_1 + additional_energy_1 + termau_energy(extended_stem,extended_stem)) <= (first_ss_dangle_energy_0 + next_ss_dangle_energy_0 + termau_energy(ans.second.firstStem,ans.second.firstStem))) ) \
	       || ( _shouldermin && ((next_ss_dangle_energy_1 + additional_energy_1 + termau_energy(extended_stem,extended_stem)) < (first_ss_dangle_energy_0 + next_ss_dangle_energy_0 + termau_energy(ans.second.firstStem,ans.second.firstStem))) ) \
	     ) {
	    lmCompliant = false;
	    break;
	  }
	}
      }
      // try to DEL a bp
      //     |-x_0--|----x_1------|   cadd
      //     .((...))...((...)).....  old
      //     ..(...)....((...)).....  new
      if (lmCompliant) {
	int additional_energy_0 = 0;
	TUSubsequence inner_stem = REGION(t_0_seq,(unsigned int)2,(unsigned int)(ans.second.next_ss_i-1));
	if (loop_complete_table_energy.is_tabulated((unsigned int)1, (unsigned int)2, (unsigned int)(ans.second.next_ss_i-1), (unsigned int)ans.second.next_ss_i)) {
	  additional_energy_0 = loop_complete_table_energy.get((unsigned int)1, (unsigned int)2, (unsigned int)(ans.second.next_ss_i-1), (unsigned int)ans.second.next_ss_i); 
	} else {
	  additional_energy_0 = sr_energy(ans.second.firstStem, ans.second.firstStem);

	  loop_complete_table_energy.set((unsigned int)1, (unsigned int)2, (unsigned int)(ans.second.next_ss_i-1), (unsigned int)ans.second.next_ss_i, additional_energy_0);
	}

	int first_ss_dangle_energy_1 = dl_energy(inner_stem, inner_stem);  //a       
	if ((ans.second.next_ss_j - ans.second.next_ss_i) == 0) {  //d
	  next_ss_dangle_energy_1 = min(dr_energy(inner_stem, inner_stem), dl_energy(ans.second.secondStem, ans.second.secondStem));
	} else {
	  next_ss_dangle_energy_1 = dr_energy(inner_stem, inner_stem) + dl_energy(ans.second.secondStem, ans.second.secondStem);
	}

	if ( \
	     ( !_shouldermin && ((first_ss_dangle_energy_1 + next_ss_dangle_energy_1 + termau_energy(inner_stem,inner_stem)) <= (first_ss_dangle_energy_0 + next_ss_dangle_energy_0 + additional_energy_0 + termau_energy(ans.second.firstStem,ans.second.firstStem))) ) \
	     || ( _shouldermin && ((first_ss_dangle_energy_1 + next_ss_dangle_energy_1 + termau_energy(inner_stem,inner_stem)) < (first_ss_dangle_energy_0 + next_ss_dangle_energy_0 + additional_energy_0 + termau_energy(ans.second.firstStem,ans.second.firstStem))) ) \
	   ) {
	  lmCompliant = false;
	} 
      }
    } else {  // in case: (ans.second.outermost_initstem_i==0)
      // try to DEL a bp
      //     |-x_0--|----x_1------|   cadd
      //     ((...))..((...)).....  old
      //     .(...)...((...)).....  new
      if (lmCompliant) {
	int additional_energy_0 = 0;
	TUSubsequence inner_stem = REGION(t_0_seq,(unsigned int)1,(unsigned int)(ans.second.next_ss_i-1));
	if (loop_complete_table_energy.is_tabulated((unsigned int)0, (unsigned int)1, (unsigned int)(ans.second.next_ss_i-1), (unsigned int)ans.second.next_ss_i)) {
	  additional_energy_0 = loop_complete_table_energy.get((unsigned int)0, (unsigned int)1, (unsigned int)(ans.second.next_ss_i-1), (unsigned int)ans.second.next_ss_i); 
	} else {
	  additional_energy_0 = sr_energy(ans.second.firstStem, ans.second.firstStem);

	  loop_complete_table_energy.set((unsigned int)0, (unsigned int)1, (unsigned int)(ans.second.next_ss_i-1), (unsigned int)ans.second.next_ss_i, additional_energy_0);
	}

	int first_ss_dangle_energy_1 = dl_energy(inner_stem, inner_stem);  //a       
	if ((ans.second.next_ss_j - ans.second.next_ss_i) == 0) {  //d
	  next_ss_dangle_energy_1 = min(dr_energy(inner_stem, inner_stem), dl_energy(ans.second.secondStem, ans.second.secondStem));
	} else {
	  next_ss_dangle_energy_1 = dr_energy(inner_stem, inner_stem) + dl_energy(ans.second.secondStem, ans.second.secondStem);
	}

	if ( \
	     ( !_shouldermin && ((first_ss_dangle_energy_1 + next_ss_dangle_energy_1 + termau_energy(inner_stem,inner_stem)) <= (next_ss_dangle_energy_0 + additional_energy_0 + termau_energy(ans.second.firstStem,ans.second.firstStem))) ) \
	     || ( _shouldermin && ((first_ss_dangle_energy_1 + next_ss_dangle_energy_1 + termau_energy(inner_stem,inner_stem)) < (next_ss_dangle_energy_0 + additional_energy_0 + termau_energy(ans.second.firstStem,ans.second.firstStem))) ) \
	   ) {
	  lmCompliant = false;
	} 
      }
    }
  } 
}
}

if (lmCompliant) {
  push_back( answers, ans);
}
                  //push_back( answers, ans);
                }
              }
            }

          erase( a_0);
        }

        erase( a_1);
      }

    }


  if (((t_0_right_most - t_0_i) >= 1))
  {
    TUSubsequence ret_4 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
    TUSubsequence a_2 = ret_4;
    if (is_not_empty(a_2))
    {
      hhpp_hash_h ret_5 = nt_struct((t_0_i + 1));
      hhpp_hash_h a_3 = ret_5;
      if (is_not_empty(a_3))
        {
          for (hhpp_hash_h::iterator x_3_itr = a_3.ref().begin(); x_3_itr!=a_3.ref().end(); ++x_3_itr){
            std::pair<Rope, mfeanswer_v4>  x_3 = *x_3_itr;
            std::pair<Rope, mfeanswer_v4>  ans = sadd(a_2, x_3);
bool lmCompliant = true;
//std::cout << "8d:" << a_2 << "+" << x_3 << "=" << ans << std::endl;
if (_locallymin) {
//8_d: additional calculation ==> (8_a + 8_c(or 8_d)) or (8_b + 8_c(or 8_d))
// try to ADD a bp
//     |a_2|-----------x_3--------|   cadd
//     ....((...))...((...)).....  old
//     .a(b((...))c)d((...)).....  new
// including case
//     .......((.......))... old
//     .(.....((.......)).). new


// first_ss_pos vs. next_ss_pos only for last round ending with sadd(..)
     // ans.second.subword.i==a_2.i
if ((ans.second.next_ss_i != -1) && (ans.second.subword.i==0)) {  // (ans.second.next_ss_i != -1) means no. of inistem >= 1
  // if dangle bases exist on both sides
  int first_ss_dangle_energy_0 = 0;
  int next_ss_dangle_energy_0 = 0;
  if (ans.second.outermost_initstem_i >= 1) {
    first_ss_dangle_energy_0 = dl_energy(ans.second.firstStem, ans.second.firstStem);
  }
  if ((ans.second.next_ss_j - ans.second.next_ss_i) == 1) {
    next_ss_dangle_energy_0 = min(dr_energy(ans.second.firstStem, ans.second.firstStem), dl_energy(ans.second.secondStem, ans.second.secondStem));
  } else if ((ans.second.next_ss_j - ans.second.next_ss_i) > 1) {
    next_ss_dangle_energy_0 = dr_energy(ans.second.firstStem, ans.second.firstStem) + dl_energy(ans.second.secondStem, ans.second.secondStem);
  }
  
  int first_ss_dangle_energy_1 = 0;
  int next_ss_dangle_energy_1 = 0;
  int additional_energy_1 = 0;
  TUSubsequence extended_stem;
  for (unsigned int first_ss_pos = 0; first_ss_pos < ans.second.outermost_initstem_i; first_ss_pos++) {
    if (!lmCompliant) {
      break;
    }
    for (unsigned int next_ss_pos = ans.second.next_ss_i; next_ss_pos < ans.second.next_ss_j; next_ss_pos++) {
      if (basepairing(t_0_seq, first_ss_pos, next_ss_pos+1)) {
	extended_stem = REGION(t_0_seq,first_ss_pos,next_ss_pos+1);
	if (loop_complete_table_energy.is_tabulated(first_ss_pos, ans.second.outermost_initstem_i, ans.second.next_ss_i, next_ss_pos+1)) {
	  additional_energy_1 = loop_complete_table_energy.get(first_ss_pos, ans.second.outermost_initstem_i, ans.second.next_ss_i, next_ss_pos+1); 
	} else {
	  
	  if ((ans.second.outermost_initstem_i - first_ss_pos) == 1 ) {   //b
	    if ((next_ss_pos - ans.second.next_ss_i) == 0) {       //c
	      additional_energy_1 = sr_energy(extended_stem, extended_stem);
	    } else if ((next_ss_pos - ans.second.next_ss_i) > 0) { //c
	      additional_energy_1 = br_energy(extended_stem, REGION(t_0_seq,(unsigned int)ans.second.next_ss_i,next_ss_pos));
	    }
	  } else if ((ans.second.outermost_initstem_i - first_ss_pos) > 1 ) {    //b
	    if ((next_ss_pos - ans.second.next_ss_i) == 0) {               //c
	      additional_energy_1 = bl_energy(REGION(t_0_seq, first_ss_pos+1, (unsigned int)ans.second.outermost_initstem_i), REGION(t_0_seq,next_ss_pos,next_ss_pos+1));
	    } else if ((next_ss_pos - ans.second.after_next_ss_i) > 0) {         //c
	      additional_energy_1 = il_energy(REGION(t_0_seq, first_ss_pos+1, (unsigned int)ans.second.outermost_initstem_i), REGION(t_0_seq,(unsigned int)ans.second.next_ss_i,next_ss_pos));
	    }  
	  }

	  loop_complete_table_energy.set(first_ss_pos, ans.second.outermost_initstem_i, ans.second.next_ss_i, next_ss_pos+1, additional_energy_1);
	}

	if (first_ss_pos >= 1 ) {    //a
	  first_ss_dangle_energy_1 = dl_energy(extended_stem, extended_stem);       
	} else {
	  first_ss_dangle_energy_1 = 0;
	}
	if ((ans.second.next_ss_j - next_ss_pos) == 2) {  //d
	  next_ss_dangle_energy_1 = min(dr_energy(extended_stem, extended_stem), dl_energy(ans.second.secondStem, ans.second.secondStem));
	} else if ((ans.second.next_ss_j - next_ss_pos) > 2) {
	  next_ss_dangle_energy_1 = dr_energy(extended_stem, extended_stem) + dl_energy(ans.second.secondStem, ans.second.secondStem);
	} else {
	  next_ss_dangle_energy_1 = 0;
	}

	//std::cout << "8_d("<<first_ss_pos<<","<<next_ss_pos<<"): " << a_2 << x_3 << ans << first_ss_dangle_energy_1 <<"+"<< next_ss_dangle_energy_1 <<"+"<< additional_energy_1 <<"<>"<< first_ss_dangle_energy_0 <<"+"<< next_ss_dangle_energy_0 << std::endl;
	if ( \
	     ( !_shouldermin && ((first_ss_dangle_energy_1 + next_ss_dangle_energy_1 + additional_energy_1 + termau_energy(extended_stem,extended_stem)) <= (first_ss_dangle_energy_0 + next_ss_dangle_energy_0 + termau_energy(ans.second.firstStem,ans.second.firstStem))) ) \
	     || ( _shouldermin && ((first_ss_dangle_energy_1 + next_ss_dangle_energy_1 + additional_energy_1 + termau_energy(extended_stem,extended_stem)) < (first_ss_dangle_energy_0 + next_ss_dangle_energy_0 + termau_energy(ans.second.firstStem,ans.second.firstStem))) ) \
	   ) {
	  lmCompliant = false;
	  break;
	}
      }
    }
  }
  
  // try to DEL a bp
  //     a_2|----------x_3------|   cadd
  //     ..((...))...((...)).....  old
  //     ...(...)....((...)).....  old
  if (lmCompliant) {
    int additional_energy_0 = 0;
    TUSubsequence inner_stem = REGION(t_0_seq,(unsigned int)(ans.second.outermost_initstem_i+1),(unsigned int)(ans.second.next_ss_i-1));
    if (loop_complete_table_energy.is_tabulated((unsigned int)ans.second.outermost_initstem_i, (unsigned int)(ans.second.outermost_initstem_i+1), (unsigned int)(ans.second.next_ss_i-1), (unsigned int)ans.second.next_ss_i)) {
      additional_energy_0 = loop_complete_table_energy.get((unsigned int)ans.second.outermost_initstem_i, (unsigned int)(ans.second.outermost_initstem_i+1), (unsigned int)(ans.second.next_ss_i-1), (unsigned int)ans.second.next_ss_i); 
    } else {
      additional_energy_0 = sr_energy(ans.second.firstStem, ans.second.firstStem);

      loop_complete_table_energy.set((unsigned int)ans.second.outermost_initstem_i, (unsigned int)(ans.second.outermost_initstem_i+1), (unsigned int)(ans.second.next_ss_i-1), (unsigned int)ans.second.next_ss_i, additional_energy_0);
    }

    int first_ss_dangle_energy_1 = dl_energy(inner_stem, inner_stem);  //a       
    if ((ans.second.next_ss_j - ans.second.next_ss_i) == 0) {  //d
      next_ss_dangle_energy_1 = min(dr_energy(inner_stem, inner_stem), dl_energy(ans.second.secondStem, ans.second.secondStem));
    } else {
      next_ss_dangle_energy_1 = dr_energy(inner_stem, inner_stem) + dl_energy(ans.second.secondStem, ans.second.secondStem);
    }

    if ( \
         ( !_shouldermin && ((first_ss_dangle_energy_1 + next_ss_dangle_energy_1 + termau_energy(inner_stem,inner_stem)) <= (first_ss_dangle_energy_0 + next_ss_dangle_energy_0 + additional_energy_0 + termau_energy(ans.second.firstStem,ans.second.firstStem))) ) \
         || ( _shouldermin && ((first_ss_dangle_energy_1 + next_ss_dangle_energy_1 + termau_energy(inner_stem,inner_stem)) < (first_ss_dangle_energy_0 + next_ss_dangle_energy_0 + additional_energy_0 + termau_energy(ans.second.firstStem,ans.second.firstStem))) ) \
       ) {
      lmCompliant = false;
    } 
  }

}
}
  
if (lmCompliant) {
  push_back( answers, ans);
}
            //push_back( answers, ans);
          }
        }

      erase( a_3);
    }

    erase( a_2);
  }

  std::pair<Rope, mfeanswer_v4>  ret_6;
  if ((((t_0_right_most - t_0_i) >= 0) && ((t_0_right_most - t_0_i) <= 0)))
  {
    TUSubsequence ret_7 = LOC(t_0_seq, t_0_i, t_0_i);
    TUSubsequence a_4 = ret_7;
    if (is_not_empty(a_4))
      {
        ret_6 = nil(a_4);
      }

    else
      {
        empty( ret_6);
      }

    erase( a_4);
  }

  else
    {
      empty( ret_6);
    }

  if (is_not_empty(ret_6))
    {
      push_back( answers, ret_6);
    }

  hash_filter( answers);
  finalize( answers);
  struct_table.set( t_0_i, answers);
  return struct_table.get(t_0_i);
}


/////////// -2: add for nt_hairpin_filter /////////////////
///////////////////////////////////////////////////////
std::pair<Rope, mfeanswer_v4>  hhpp::hl(const TUSubsequence & p_lb, const TUSubsequence & p_region, const TUSubsequence & p_rb)
{
  TUSubsequence l_0 = p_lb;
  TUSubsequence l_1 = p_region;
  TUSubsequence l_2 = p_rb;
  TUSubsequence r_0 = p_lb;
  TUSubsequence r_1 = p_region;
  TUSubsequence r_2 = p_rb;
  Rope ret_left = hl_l(l_0, l_1, l_2);
  mfeanswer_v4 ret_right = hl_r(r_0, r_1, r_2);
  std::pair<Rope, mfeanswer_v4>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}
Rope hhpp::hl_l(const TUSubsequence & lb, const TUSubsequence & region, const TUSubsequence & rb)
{
#line 977 "hishapes_lm_d1.gap"
  Rope res;
  int pos;
  pos = ( ( ((lb.i + rb.j) + 1) )  / 2);
  if (((pos * 2) > ((lb.i + rb.j) + 1)))
    {
      pos = (pos - 1);
    }

  append( res, pos);
  if (((pos * 2) != ((lb.i + rb.j) + 1)))
    {
      append( res, ".5", 2);
    }

  append( res, ',');
  return res;
#line 1217 "rope_mfeV4_d1_.cc"
}
mfeanswer_v4 hhpp::hl_r(const TUSubsequence & lb, const TUSubsequence & region, const TUSubsequence & rb)
{
#line 290 "hishapes_lm_d1.gap"
  mfeanswer_v4 res;
  res.firstStem.seq = lb.seq;
  res.firstStem.i = lb.i;
  res.firstStem.j = rb.j;
  res.energy = hl_energy(region);
  res.lastStem = res.firstStem;
  res.subword = res.firstStem;
  res.prevE = 0;
  res.prevIsMl = false;
  return res;
#line 1386 "rope_mfeV4_d1_.cc"
}


std::pair<Rope, mfeanswer_v4>  hhpp::addss(const std::pair<Rope, mfeanswer_v4> & p_e, const TUSubsequence & p_rb)
{
  Rope l_0 = p_e.first;
  TUSubsequence l_1 = p_rb;
  mfeanswer_v4 r_0 = p_e.second;
  TUSubsequence r_1 = p_rb;
  Rope ret_left = addss_l(l_0, l_1);
  mfeanswer_v4 ret_right = addss_r(r_0, r_1);
  std::pair<Rope, mfeanswer_v4>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, mfeanswer_v4>  hhpp::bl(const TUSubsequence & p_lregion, const std::pair<Rope, mfeanswer_v4> & p_e)
{
  TUSubsequence l_0 = p_lregion;
  Rope l_1 = p_e.first;
  TUSubsequence r_0 = p_lregion;
  mfeanswer_v4 r_1 = p_e.second;
  Rope ret_left = bl_l(l_0, l_1);
  mfeanswer_v4 ret_right = bl_r(r_0, r_1);
  std::pair<Rope, mfeanswer_v4>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, mfeanswer_v4>  hhpp::br(const std::pair<Rope, mfeanswer_v4> & p_e, const TUSubsequence & p_rregion)
{
  Rope l_0 = p_e.first;
  TUSubsequence l_1 = p_rregion;
  mfeanswer_v4 r_0 = p_e.second;
  TUSubsequence r_1 = p_rregion;
  Rope ret_left = br_l(l_0, l_1);
  mfeanswer_v4 ret_right = br_r(r_0, r_1);
  std::pair<Rope, mfeanswer_v4>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, mfeanswer_v4>  hhpp::cadd(const std::pair<Rope, mfeanswer_v4> & p_le, const std::pair<Rope, mfeanswer_v4> & p_re)
{
  Rope l_0 = p_le.first;
  Rope l_1 = p_re.first;
  mfeanswer_v4 r_0 = p_le.second;
  mfeanswer_v4 r_1 = p_re.second;
  Rope ret_left = cadd_l(l_0, l_1);
  mfeanswer_v4 ret_right = cadd_r(r_0, r_1);
  std::pair<Rope, mfeanswer_v4>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, mfeanswer_v4>  hhpp::drem(const std::pair<Rope, mfeanswer_v4> & p_e)
{
  Rope l_0 = p_e.first;
  mfeanswer_v4 r_0 = p_e.second;
  Rope ret_left = drem_l(l_0);
  mfeanswer_v4 ret_right = drem_r(r_0);
  std::pair<Rope, mfeanswer_v4>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, mfeanswer_v4>  hhpp::edl(const TUSubsequence & p_lb, const std::pair<Rope, mfeanswer_v4> & p_e)
{
  TUSubsequence l_0 = p_lb;
  Rope l_1 = p_e.first;
  TUSubsequence r_0 = p_lb;
  mfeanswer_v4 r_1 = p_e.second;
  Rope ret_left = edl_l(l_0, l_1);
  mfeanswer_v4 ret_right = edl_r(r_0, r_1);
  std::pair<Rope, mfeanswer_v4>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, mfeanswer_v4>  hhpp::edlr(const TUSubsequence & p_lb, const std::pair<Rope, mfeanswer_v4> & p_e, const TUSubsequence & p_rb)
{
  TUSubsequence l_0 = p_lb;
  Rope l_1 = p_e.first;
  TUSubsequence l_2 = p_rb;
  TUSubsequence r_0 = p_lb;
  mfeanswer_v4 r_1 = p_e.second;
  TUSubsequence r_2 = p_rb;
  Rope ret_left = edlr_l(l_0, l_1, l_2);
  mfeanswer_v4 ret_right = edlr_r(r_0, r_1, r_2);
  std::pair<Rope, mfeanswer_v4>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, mfeanswer_v4>  hhpp::edr(const std::pair<Rope, mfeanswer_v4> & p_e, const TUSubsequence & p_rb)
{
  Rope l_0 = p_e.first;
  TUSubsequence l_1 = p_rb;
  mfeanswer_v4 r_0 = p_e.second;
  TUSubsequence r_1 = p_rb;
  Rope ret_left = edr_l(l_0, l_1);
  mfeanswer_v4 ret_right = edr_r(r_0, r_1);
  std::pair<Rope, mfeanswer_v4>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

template <typename Iterator>
hhpp_hash_h hhpp::h(std::pair<Iterator, Iterator> i)

{
  hhpp_hash_h answers;
  empty(answers);
  append_filter( answers, i);
  finalize( answers);
  return answers;
}

std::pair<Rope, mfeanswer_v4>  hhpp::hl(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const TUSubsequence & p_region, const TUSubsequence & p_rb, const TUSubsequence & p_rrb)
{
  TUSubsequence l_0 = p_llb;
  TUSubsequence l_1 = p_lb;
  TUSubsequence l_2 = p_region;
  TUSubsequence l_3 = p_rb;
  TUSubsequence l_4 = p_rrb;
  TUSubsequence r_0 = p_llb;
  TUSubsequence r_1 = p_lb;
  TUSubsequence r_2 = p_region;
  TUSubsequence r_3 = p_rb;
  TUSubsequence r_4 = p_rrb;
  Rope ret_left = hl_l(l_0, l_1, l_2, l_3, l_4);
  mfeanswer_v4 ret_right = hl_r(r_0, r_1, r_2, r_3, r_4);
  std::pair<Rope, mfeanswer_v4>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, mfeanswer_v4>  hhpp::il(const TUSubsequence & p_lregion, const std::pair<Rope, mfeanswer_v4> & p_e, const TUSubsequence & p_rregion)
{
  TUSubsequence l_0 = p_lregion;
  Rope l_1 = p_e.first;
  TUSubsequence l_2 = p_rregion;
  TUSubsequence r_0 = p_lregion;
  mfeanswer_v4 r_1 = p_e.second;
  TUSubsequence r_2 = p_rregion;
  Rope ret_left = il_l(l_0, l_1, l_2);
  mfeanswer_v4 ret_right = il_r(r_0, r_1, r_2);
  std::pair<Rope, mfeanswer_v4>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, mfeanswer_v4>  hhpp::incl(const std::pair<Rope, mfeanswer_v4> & p_e)
{
  Rope l_0 = p_e.first;
  mfeanswer_v4 r_0 = p_e.second;
  Rope ret_left = incl_l(l_0);
  mfeanswer_v4 ret_right = incl_r(r_0);
  std::pair<Rope, mfeanswer_v4>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, mfeanswer_v4>  hhpp::is(const std::pair<Rope, mfeanswer_v4> & p_e)
{
  Rope l_0 = p_e.first;
  mfeanswer_v4 r_0 = p_e.second;
  Rope ret_left = is_l(l_0);
  mfeanswer_v4 ret_right = is_r(r_0);
  std::pair<Rope, mfeanswer_v4>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, mfeanswer_v4>  hhpp::ml(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const std::pair<Rope, mfeanswer_v4> & p_e, const TUSubsequence & p_rb, const TUSubsequence & p_rrb)
{
  TUSubsequence l_0 = p_llb;
  TUSubsequence l_1 = p_lb;
  Rope l_2 = p_e.first;
  TUSubsequence l_3 = p_rb;
  TUSubsequence l_4 = p_rrb;
  TUSubsequence r_0 = p_llb;
  TUSubsequence r_1 = p_lb;
  mfeanswer_v4 r_2 = p_e.second;
  TUSubsequence r_3 = p_rb;
  TUSubsequence r_4 = p_rrb;
  Rope ret_left = ml_l(l_0, l_1, l_2, l_3, l_4);
  mfeanswer_v4 ret_right = ml_r(r_0, r_1, r_2, r_3, r_4);
  std::pair<Rope, mfeanswer_v4>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, mfeanswer_v4>  hhpp::mldl(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<Rope, mfeanswer_v4> & p_e, const TUSubsequence & p_rb, const TUSubsequence & p_rrb)
{
  TUSubsequence l_0 = p_llb;
  TUSubsequence l_1 = p_lb;
  TUSubsequence l_2 = p_dl;
  Rope l_3 = p_e.first;
  TUSubsequence l_4 = p_rb;
  TUSubsequence l_5 = p_rrb;
  TUSubsequence r_0 = p_llb;
  TUSubsequence r_1 = p_lb;
  TUSubsequence r_2 = p_dl;
  mfeanswer_v4 r_3 = p_e.second;
  TUSubsequence r_4 = p_rb;
  TUSubsequence r_5 = p_rrb;
  Rope ret_left = mldl_l(l_0, l_1, l_2, l_3, l_4, l_5);
  mfeanswer_v4 ret_right = mldl_r(r_0, r_1, r_2, r_3, r_4, r_5);
  std::pair<Rope, mfeanswer_v4>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, mfeanswer_v4>  hhpp::mldlr(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<Rope, mfeanswer_v4> & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb, const TUSubsequence & p_rrb)
{
  TUSubsequence l_0 = p_llb;
  TUSubsequence l_1 = p_lb;
  TUSubsequence l_2 = p_dl;
  Rope l_3 = p_e.first;
  TUSubsequence l_4 = p_dr;
  TUSubsequence l_5 = p_rb;
  TUSubsequence l_6 = p_rrb;
  TUSubsequence r_0 = p_llb;
  TUSubsequence r_1 = p_lb;
  TUSubsequence r_2 = p_dl;
  mfeanswer_v4 r_3 = p_e.second;
  TUSubsequence r_4 = p_dr;
  TUSubsequence r_5 = p_rb;
  TUSubsequence r_6 = p_rrb;
  Rope ret_left = mldlr_l(l_0, l_1, l_2, l_3, l_4, l_5, l_6);
  mfeanswer_v4 ret_right = mldlr_r(r_0, r_1, r_2, r_3, r_4, r_5, r_6);
  std::pair<Rope, mfeanswer_v4>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, mfeanswer_v4>  hhpp::mldr(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const std::pair<Rope, mfeanswer_v4> & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb, const TUSubsequence & p_rrb)
{
  TUSubsequence l_0 = p_llb;
  TUSubsequence l_1 = p_lb;
  Rope l_2 = p_e.first;
  TUSubsequence l_3 = p_dr;
  TUSubsequence l_4 = p_rb;
  TUSubsequence l_5 = p_rrb;
  TUSubsequence r_0 = p_llb;
  TUSubsequence r_1 = p_lb;
  mfeanswer_v4 r_2 = p_e.second;
  TUSubsequence r_3 = p_dr;
  TUSubsequence r_4 = p_rb;
  TUSubsequence r_5 = p_rrb;
  Rope ret_left = mldr_l(l_0, l_1, l_2, l_3, l_4, l_5);
  mfeanswer_v4 ret_right = mldr_r(r_0, r_1, r_2, r_3, r_4, r_5);
  std::pair<Rope, mfeanswer_v4>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, mfeanswer_v4>  hhpp::nil(const TUSubsequence & p_loc)
{
  TUSubsequence l_0 = p_loc;
  TUSubsequence r_0 = p_loc;
  Rope ret_left = nil_l(l_0);
  mfeanswer_v4 ret_right = nil_r(r_0);
  std::pair<Rope, mfeanswer_v4>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, mfeanswer_v4>  hhpp::sadd(const TUSubsequence & p_b, const std::pair<Rope, mfeanswer_v4> & p_e)
{
  TUSubsequence l_0 = p_b;
  Rope l_1 = p_e.first;
  TUSubsequence r_0 = p_b;
  mfeanswer_v4 r_1 = p_e.second;
  Rope ret_left = sadd_l(l_0, l_1);
  mfeanswer_v4 ret_right = sadd_r(r_0, r_1);
  std::pair<Rope, mfeanswer_v4>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, mfeanswer_v4>  hhpp::sp(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const std::pair<Rope, mfeanswer_v4> & p_e, const TUSubsequence & p_rb, const TUSubsequence & p_rrb)
{
  TUSubsequence l_0 = p_llb;
  TUSubsequence l_1 = p_lb;
  Rope l_2 = p_e.first;
  TUSubsequence l_3 = p_rb;
  TUSubsequence l_4 = p_rrb;
  TUSubsequence r_0 = p_llb;
  TUSubsequence r_1 = p_lb;
  mfeanswer_v4 r_2 = p_e.second;
  TUSubsequence r_3 = p_rb;
  TUSubsequence r_4 = p_rrb;
  Rope ret_left = sp_l(l_0, l_1, l_2, l_3, l_4);
  mfeanswer_v4 ret_right = sp_r(r_0, r_1, r_2, r_3, r_4);
  std::pair<Rope, mfeanswer_v4>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, mfeanswer_v4>  hhpp::sr(const TUSubsequence & p_lb, const std::pair<Rope, mfeanswer_v4> & p_e, const TUSubsequence & p_rb)
{
  TUSubsequence l_0 = p_lb;
  Rope l_1 = p_e.first;
  TUSubsequence l_2 = p_rb;
  TUSubsequence r_0 = p_lb;
  mfeanswer_v4 r_1 = p_e.second;
  TUSubsequence r_2 = p_rb;
  Rope ret_left = sr_l(l_0, l_1, l_2);
  mfeanswer_v4 ret_right = sr_r(r_0, r_1, r_2);
  std::pair<Rope, mfeanswer_v4>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}



Rope hhpp::addss_l(const Rope & e, const TUSubsequence & rb)
{
#line 4805 "hishapes_lm_nolp.gap.cc"
  return e;
#line 1644 "hishapeh_mfe_pp.cc"
}

Rope hhpp::bl_l(const TUSubsequence & lregion, const Rope & e)
{
#line 4757 "hishapes_lm_nolp.gap.cc"
  return e;
#line 1651 "hishapeh_mfe_pp.cc"
}

Rope hhpp::br_l(const Rope & e, const TUSubsequence & rregion)
{
#line 4761 "hishapes_lm_nolp.gap.cc"
  return e;
#line 1658 "hishapeh_mfe_pp.cc"
}

Rope hhpp::cadd_l(const Rope & le, const Rope & re)
{
#line 4662 "hishapes_lm_nolp.gap.cc"
  if ((re == "_"))
    {
      return le;
    }

  else
    {
      return (le + re);
    }

#line 1674 "hishapeh_mfe_pp.cc"
}

Rope hhpp::drem_l(const Rope & e)
{
#line 4728 "hishapes_lm_nolp.gap.cc"
  return e;
#line 1681 "hishapeh_mfe_pp.cc"
}

Rope hhpp::edl_l(const TUSubsequence & lb, const Rope & e)
{
#line 4716 "hishapes_lm_nolp.gap.cc"
  return e;
#line 1688 "hishapeh_mfe_pp.cc"
}

Rope hhpp::edlr_l(const TUSubsequence & lb, const Rope & e, const TUSubsequence & rb)
{
#line 4724 "hishapes_lm_nolp.gap.cc"
  return e;
#line 1695 "hishapeh_mfe_pp.cc"
}

Rope hhpp::edr_l(const Rope & e, const TUSubsequence & rb)
{
#line 4720 "hishapes_lm_nolp.gap.cc"
  return e;
#line 1702 "hishapeh_mfe_pp.cc"
}

Rope hhpp::hl_l(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & region, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 4740 "hishapes_lm_nolp.gap.cc"
  Rope res;
  int pos;
  pos = ( ( ((llb.i + rrb.j) + 1) )  / 2);
  if (((pos * 2) > ((llb.i + rrb.j) + 1)))
    {
      pos = (pos - 1);
    }

  append( res, pos);
  if (((pos * 2) != ((llb.i + rrb.j) + 1)))
    {
      append( res, ".5", 2);
    }

  append( res, ',');
  return res;
#line 1724 "hishapeh_mfe_pp.cc"
}

Rope hhpp::il_l(const TUSubsequence & lregion, const Rope & e, const TUSubsequence & rregion)
{
#line 4765 "hishapes_lm_nolp.gap.cc"
  return e;
#line 1731 "hishapeh_mfe_pp.cc"
}

Rope hhpp::incl_l(const Rope & e)
{
#line 4817 "hishapes_lm_nolp.gap.cc"
  return e;
#line 1738 "hishapeh_mfe_pp.cc"
}

Rope hhpp::is_l(const Rope & e)
{
#line 4732 "hishapes_lm_nolp.gap.cc"
  return e;
#line 1745 "hishapeh_mfe_pp.cc"
}

Rope hhpp::ml_l(const TUSubsequence & llb, const TUSubsequence & lb, const Rope & e, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 4769 "hishapes_lm_nolp.gap.cc"
  return e;
#line 1752 "hishapeh_mfe_pp.cc"
}

Rope hhpp::mldl_l(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const Rope & e, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 4797 "hishapes_lm_nolp.gap.cc"
  return e;
#line 1759 "hishapeh_mfe_pp.cc"
}

Rope hhpp::mldlr_l(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const Rope & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 4781 "hishapes_lm_nolp.gap.cc"
  return e;
#line 1766 "hishapeh_mfe_pp.cc"
}

Rope hhpp::mldr_l(const TUSubsequence & llb, const TUSubsequence & lb, const Rope & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 4773 "hishapes_lm_nolp.gap.cc"
  return e;
#line 1773 "hishapeh_mfe_pp.cc"
}

Rope hhpp::nil_l(const TUSubsequence & loc)
{
#line 4706 "hishapes_lm_nolp.gap.cc"
  Rope r;
  return r;
#line 1781 "hishapeh_mfe_pp.cc"
}

Rope hhpp::sadd_l(const TUSubsequence & b, const Rope & e)
{
#line 4649 "hishapes_lm_nolp.gap.cc"
  Rope emptyShape;
  Rope res;
  if ((e == emptyShape))
  {
    append( res, '_');
    append( res, e);
    return res;
  }

  else
    {
      return e;
    }

#line 1801 "hishapeh_mfe_pp.cc"
}

Rope hhpp::sp_l(const TUSubsequence & llb, const TUSubsequence & lb, const Rope & e, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 4753 "hishapes_lm_nolp.gap.cc"
  return e;
#line 1808 "hishapeh_mfe_pp.cc"
}

Rope hhpp::sr_l(const TUSubsequence & lb, const Rope & e, const TUSubsequence & rb)
{
#line 4736 "hishapes_lm_nolp.gap.cc"
  return e;
#line 1815 "hishapeh_mfe_pp.cc"
}



mfeanswer_v4 hhpp::addss_r(const mfeanswer_v4 & e, const TUSubsequence & rb)
{
#line 1264 "hishapes_lm_nolp.gap.cc"
  mfeanswer_v4 res = e;
  res.energy = (e.energy + ss_energy(rb));
  res.subword.j = rb.j;
  res.outermost_initstem_i = e.firstStem.i;
  res.outermost_initstem_j = e.firstStem.j;
  res.next_ss_i = rb.i;
  res.next_ss_j = rb.j;
  res.before_last_ss_i = -1;
  res.before_last_ss_j = -1;
  res.after_next_ss_i = -1;
  res.after_next_ss_j = -1;
  return res;
#line 1835 "hishapeh_mfe_pp.cc"
}

mfeanswer_v4 hhpp::bl_r(const TUSubsequence & lregion, const mfeanswer_v4 & e)
{
#line 699 "hishapes_lm_nolp.gap.cc"
  mfeanswer_v4 res = e;
  TUSubsequence innerstem;
  innerstem.seq = lregion.seq;
  innerstem.i = (lregion.i - 1);
  innerstem.j = (e.firstStem.j + 1);
  res.energy = (e.energy + bl_energy(lregion, innerstem));
  res.subword.i = lregion.i;
  res.prevSubword = e.subword;
  res.prevE = e.energy;
  res.prevIsMl = false;
  return res;
#line 1852 "hishapeh_mfe_pp.cc"
}

mfeanswer_v4 hhpp::br_r(const mfeanswer_v4 & e, const TUSubsequence & rregion)
{
#line 738 "hishapes_lm_nolp.gap.cc"
  mfeanswer_v4 res = e;
  TUSubsequence innerstem;
  innerstem.seq = rregion.seq;
  innerstem.i = (e.firstStem.i - 1);
  innerstem.j = (rregion.j + 1);
  res.energy = (e.energy + br_energy(innerstem, rregion));
  res.subword.j = rregion.j;
  res.prevSubword = e.subword;
  res.prevE = e.energy;
  res.prevIsMl = false;
  return res;
#line 1869 "hishapeh_mfe_pp.cc"
}

mfeanswer_v4 hhpp::cadd_r(const mfeanswer_v4 & le, const mfeanswer_v4 & re)
{
#line 112 "hishapes_lm_nolp.gap.cc"
  mfeanswer_v4 res = le;
  res.energy = (le.energy + re.energy);
  res.secondStem = re.firstStem;
  res.lastStem = re.lastStem;
  res.subword.j = re.subword.j;
  res.outermost_initstem_i = le.outermost_initstem_i;
  res.next_ss_i = le.outermost_initstem_j;
  if ((re.outermost_initstem_j == -1))
  {
    res.outermost_initstem_j = le.outermost_initstem_j;
    res.next_ss_j = re.firstStem.j;
  }

  else
  {
    res.outermost_initstem_j = re.outermost_initstem_j;
    res.next_ss_j = re.outermost_initstem_i;
  }

  if ((re.next_ss_j != res.subword.j))
  {
    res.after_next_ss_i = re.next_ss_i;
    res.after_next_ss_j = re.next_ss_j;
    if ((re.before_last_ss_j == -1))
    {
      res.before_last_ss_i = re.next_ss_i;
      res.before_last_ss_j = re.next_ss_j;
    }

    else
    {
      res.before_last_ss_i = re.before_last_ss_i;
      res.before_last_ss_j = re.before_last_ss_j;
    }

    res.beforeLastStem = re.beforeLastStem;
  }

  else
  {
    res.after_next_ss_i = -1;
    res.after_next_ss_j = -1;
    res.before_last_ss_i = -1;
    res.before_last_ss_j = -1;
    res.beforeLastStem = le.firstStem;
  }

  return res;
#line 1923 "hishapeh_mfe_pp.cc"
}

mfeanswer_v4 hhpp::drem_r(const mfeanswer_v4 & e)
{
#line 522 "hishapes_lm_nolp.gap.cc"
  mfeanswer_v4 res = e;
  return res;
#line 1931 "hishapeh_mfe_pp.cc"
}

mfeanswer_v4 hhpp::edl_r(const TUSubsequence & lb, const mfeanswer_v4 & e)
{
#line 418 "hishapes_lm_nolp.gap.cc"
  mfeanswer_v4 res = e;
  res.energy = (e.energy + dl_energy(e.firstStem, e.firstStem));
  res.subword.i = lb.i;
  return res;
#line 1941 "hishapeh_mfe_pp.cc"
}

mfeanswer_v4 hhpp::edlr_r(const TUSubsequence & lb, const mfeanswer_v4 & e, const TUSubsequence & rb)
{
#line 485 "hishapes_lm_nolp.gap.cc"
  mfeanswer_v4 res = e;
  res.energy = (e.energy + ext_mismatch_energy(e.firstStem, e.firstStem));
  res.subword.i = lb.i;
  res.subword.j = rb.j;
  res.next_ss_j = rb.j;
  return res;
#line 1953 "hishapeh_mfe_pp.cc"
}

mfeanswer_v4 hhpp::edr_r(const mfeanswer_v4 & e, const TUSubsequence & rb)
{
#line 451 "hishapes_lm_nolp.gap.cc"
  mfeanswer_v4 res = e;
  res.energy = (e.energy + dr_energy(e.firstStem, e.firstStem));
  res.subword.j = rb.j;
  res.next_ss_j = rb.j;
  return res;
#line 1964 "hishapeh_mfe_pp.cc"
}

mfeanswer_v4 hhpp::hl_r(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & region, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 624 "hishapes_lm_nolp.gap.cc"
  mfeanswer_v4 res;
  res.firstStem.seq = llb.seq;
  res.firstStem.i = llb.i;
  res.firstStem.j = rrb.j;
  res.energy = (hl_energy(region) + sr_energy(res.firstStem, res.firstStem));
  res.lastStem = res.firstStem;
  res.subword = res.firstStem;
  res.prevE = 0;
  res.prevIsMl = false;
  return res;
#line 1980 "hishapeh_mfe_pp.cc"
}

mfeanswer_v4 hhpp::il_r(const TUSubsequence & lregion, const mfeanswer_v4 & e, const TUSubsequence & rregion)
{
#line 776 "hishapes_lm_nolp.gap.cc"
  mfeanswer_v4 res = e;
  res.energy = (e.energy + il_energy(lregion, rregion));
  res.subword.i = lregion.i;
  res.subword.j = rregion.j;
  res.prevSubword = e.subword;
  res.prevE = e.energy;
  res.prevIsMl = false;
  return res;
#line 1994 "hishapeh_mfe_pp.cc"
}

mfeanswer_v4 hhpp::incl_r(const mfeanswer_v4 & e)
{
#line 1357 "hishapes_lm_nolp.gap.cc"
  mfeanswer_v4 res = e;
  res.energy = (ul_energy() + e.energy);
  return res;
#line 2003 "hishapeh_mfe_pp.cc"
}

mfeanswer_v4 hhpp::is_r(const mfeanswer_v4 & e)
{
#line 550 "hishapes_lm_nolp.gap.cc"
  mfeanswer_v4 res = e;
  res.energy = (e.energy + termau_energy(e.firstStem, e.firstStem));
  res.outermost_initstem_i = e.firstStem.i;
  res.outermost_initstem_j = e.firstStem.j;
  res.next_ss_i = e.firstStem.j;
  res.next_ss_j = e.firstStem.j;
  res.before_last_ss_i = -1;
  res.before_last_ss_j = -1;
  res.after_next_ss_i = -1;
  res.after_next_ss_j = -1;
  return res;
#line 2020 "hishapeh_mfe_pp.cc"
}

mfeanswer_v4 hhpp::ml_r(const TUSubsequence & llb, const TUSubsequence & lb, const mfeanswer_v4 & e, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 811 "hishapes_lm_nolp.gap.cc"
  mfeanswer_v4 res = e;
  res.firstStem.seq = llb.seq;
  res.firstStem.i = llb.i;
  res.firstStem.j = rrb.j;
  TUSubsequence innerstem;
  innerstem.seq = lb.seq;
  innerstem.i = lb.i;
  innerstem.j = rb.j;
  res.energy = ((((ml_energy() + ul_energy()) + e.energy) + sr_energy(res.firstStem, res.firstStem)) + termau_energy(innerstem, innerstem));
  res.lastStem = res.firstStem;
  res.subword = res.firstStem;
  res.prevSubword = e.subword;
  res.prevE = e.energy;
  res.prevIsMl = true;
  return res;
#line 2041 "hishapeh_mfe_pp.cc"
}

mfeanswer_v4 hhpp::mldl_r(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const mfeanswer_v4 & e, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 1177 "hishapes_lm_nolp.gap.cc"
  mfeanswer_v4 res = e;
  res.firstStem.seq = llb.seq;
  res.firstStem.i = llb.i;
  res.firstStem.j = rrb.j;
  TUSubsequence innerstem;
  innerstem.seq = lb.seq;
  innerstem.i = lb.i;
  innerstem.j = rb.j;
  res.energy = (((((ml_energy() + ul_energy()) + e.energy) + dli_energy(innerstem, innerstem)) + sr_energy(res.firstStem, res.firstStem)) + termau_energy(innerstem, innerstem));
  res.lastStem = res.firstStem;
  res.subword = res.firstStem;
  res.prevSubword = e.subword;
  res.prevE = e.energy;
  res.prevIsMl = true;
  return res;
#line 2062 "hishapeh_mfe_pp.cc"
}

mfeanswer_v4 hhpp::mldlr_r(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const mfeanswer_v4 & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 962 "hishapes_lm_nolp.gap.cc"
  mfeanswer_v4 res = e;
  res.firstStem.seq = llb.seq;
  res.firstStem.i = llb.i;
  res.firstStem.j = rrb.j;
  TUSubsequence innerstem;
  innerstem.seq = lb.seq;
  innerstem.i = lb.i;
  innerstem.j = rb.j;
  res.energy = (((((ml_energy() + ul_energy()) + e.energy) + ml_mismatch_energy(innerstem, innerstem)) + sr_energy(res.firstStem, res.firstStem)) + termau_energy(innerstem, innerstem));
  res.lastStem = res.firstStem;
  res.subword = res.firstStem;
  res.prevSubword = e.subword;
  res.prevE = e.energy;
  res.prevIsMl = true;
  return res;
#line 2083 "hishapeh_mfe_pp.cc"
}

mfeanswer_v4 hhpp::mldr_r(const TUSubsequence & llb, const TUSubsequence & lb, const mfeanswer_v4 & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 859 "hishapes_lm_nolp.gap.cc"
  mfeanswer_v4 res = e;
  res.firstStem.seq = llb.seq;
  res.firstStem.i = llb.i;
  res.firstStem.j = rrb.j;
  TUSubsequence innerstem;
  innerstem.seq = lb.seq;
  innerstem.i = lb.i;
  innerstem.j = rb.j;
  res.energy = (((((ml_energy() + ul_energy()) + e.energy) + dri_energy(innerstem, innerstem)) + sr_energy(res.firstStem, res.firstStem)) + termau_energy(innerstem, innerstem));
  res.lastStem = res.firstStem;
  res.subword = res.firstStem;
  res.prevSubword = e.subword;
  res.prevE = e.energy;
  res.prevIsMl = true;
  return res;
#line 2104 "hishapeh_mfe_pp.cc"
}

mfeanswer_v4 hhpp::nil_r(const TUSubsequence & loc)
{
#line 357 "hishapes_lm_nolp.gap.cc"
  mfeanswer_v4 res;
  res.energy = 0;
  res.firstStem = loc;
  res.lastStem = loc;
  res.subword = loc;
  res.outermost_initstem_i = -1;
  res.outermost_initstem_j = -1;
  res.next_ss_i = -1;
  res.next_ss_j = -1;
  res.before_last_ss_i = -1;
  res.before_last_ss_j = -1;
  res.after_next_ss_i = -1;
  res.after_next_ss_j = -1;
  return res;
#line 2124 "hishapeh_mfe_pp.cc"
}

mfeanswer_v4 hhpp::sadd_r(const TUSubsequence & lb, const mfeanswer_v4 & e)
{
#line 86 "hishapes_lm_nolp.gap.cc"
  mfeanswer_v4 res = e;
  res.subword.i = lb.i;
  return res;
#line 2133 "hishapeh_mfe_pp.cc"
}

mfeanswer_v4 hhpp::sp_r(const TUSubsequence & llb, const TUSubsequence & lb, const mfeanswer_v4 & e, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 664 "hishapes_lm_nolp.gap.cc"
  mfeanswer_v4 res = e;
  res.firstStem.seq = llb.seq;
  res.firstStem.i = llb.i;
  res.firstStem.j = rrb.j;
  res.energy = (e.energy + sr_energy(res.firstStem, res.firstStem));
  res.lastStem = res.firstStem;
  res.subword = res.firstStem;
  return res;
#line 2147 "hishapeh_mfe_pp.cc"
}

mfeanswer_v4 hhpp::sr_r(const TUSubsequence & lb, const mfeanswer_v4 & e, const TUSubsequence & rb)
{
#line 585 "hishapes_lm_nolp.gap.cc"
  mfeanswer_v4 res = e;
  res.firstStem.seq = lb.seq;
  res.firstStem.i = lb.i;
  res.firstStem.j = rb.j;
  res.energy = (e.energy + sr_energy(res.firstStem, res.firstStem));
  res.lastStem = res.firstStem;
  res.subword = res.firstStem;
  res.prevSubword = e.subword;
  res.prevE = e.energy;
  res.prevIsMl = false;
  return res;
#line 2164 "hishapeh_mfe_pp.cc"
}


    void hhpp::cyk()
{

}



#ident "$Id: Compiled with gapc bellmansgapc-2012.05.07 $"

List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > hhpp::bt_proxy_nt_struct(unsigned int t_0_i)
{
  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > l;
  empty(l);
  hhpp_hash_h ret = nt_struct(t_0_i);
  if (is_empty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_struct_Back<hhpp, String, unsigned int>  >  bt = new Backtrace_nt_struct_Back<hhpp, String, unsigned int> (this, t_0_i);
  for (hhpp_hash_h::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, mfeanswer_v4>  elem = *elem_itr;
    std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_struct_Front<String, unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > hhpp::bt_proxy_nt_dangle(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > l;
  empty(l);
  hhpp_hash_h ret = nt_dangle(t_0_i, t_0_j);
  if (is_empty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_dangle_Back<hhpp, String, unsigned int>  >  bt = new Backtrace_nt_dangle_Back<hhpp, String, unsigned int> (this, t_0_i, t_0_j);
  for (hhpp_hash_h::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, mfeanswer_v4>  elem = *elem_itr;
    std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_dangle_Front<String, unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > hhpp::bt_proxy_nt_initstem(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > l;
  empty(l);
  hhpp_hash_h ret = nt_initstem(t_0_i, t_0_j);
  if (is_empty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_initstem_Back<hhpp, String, unsigned int>  >  bt = new Backtrace_nt_initstem_Back<hhpp, String, unsigned int> (this, t_0_i, t_0_j);
  for (hhpp_hash_h::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, mfeanswer_v4>  elem = *elem_itr;
    std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_initstem_Front<String, unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > hhpp::bt_proxy_nt_closed(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > l;
  empty(l);
  hhpp_hash_h ret = nt_closed(t_0_i, t_0_j);
  if (is_empty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_closed_Back<hhpp, String, unsigned int>  >  bt = new Backtrace_nt_closed_Back<hhpp, String, unsigned int> (this, t_0_i, t_0_j);
  for (hhpp_hash_h::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, mfeanswer_v4>  elem = *elem_itr;
    std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_closed_Front<String, unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > hhpp::bt_proxy_nt_stack(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > l;
  empty(l);
  hhpp_hash_h ret = nt_stack(t_0_i, t_0_j);
  if (is_empty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_stack_Back<hhpp, String, unsigned int>  >  bt = new Backtrace_nt_stack_Back<hhpp, String, unsigned int> (this, t_0_i, t_0_j);
  for (hhpp_hash_h::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, mfeanswer_v4>  elem = *elem_itr;
    std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_stack_Front<String, unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  hhpp::bt_proxy_nt_hairpin(unsigned int t_0_i, unsigned int t_0_j)
{
  std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  l;
  std::pair<Rope, mfeanswer_v4>  ret = nt_hairpin(t_0_i, t_0_j);
  if (is_empty(ret))
  {
    empty( l);
    return l;
  }

  intrusive_ptr<Backtrace_nt_hairpin_Back<hhpp, String, unsigned int>  >  bt = new Backtrace_nt_hairpin_Back<hhpp, String, unsigned int> (this, t_0_i, t_0_j);
  l.first = ret;
  l.second = new Backtrace_nt_hairpin_Front<String, unsigned int> (bt);
  set_value( l);
  return l;
}

List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > hhpp::bt_proxy_nt_leftB(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > l;
  empty(l);
  hhpp_hash_h ret = nt_leftB(t_0_i, t_0_j);
  if (is_empty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_leftB_Back<hhpp, String, unsigned int>  >  bt = new Backtrace_nt_leftB_Back<hhpp, String, unsigned int> (this, t_0_i, t_0_j);
  for (hhpp_hash_h::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, mfeanswer_v4>  elem = *elem_itr;
    std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_leftB_Front<String, unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > hhpp::bt_proxy_nt_rightB(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > l;
  empty(l);
  hhpp_hash_h ret = nt_rightB(t_0_i, t_0_j);
  if (is_empty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_rightB_Back<hhpp, String, unsigned int>  >  bt = new Backtrace_nt_rightB_Back<hhpp, String, unsigned int> (this, t_0_i, t_0_j);
  for (hhpp_hash_h::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, mfeanswer_v4>  elem = *elem_itr;
    std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_rightB_Front<String, unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > hhpp::bt_proxy_nt_iloop(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > l;
  empty(l);
  hhpp_hash_h ret = nt_iloop(t_0_i, t_0_j);
  if (is_empty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_iloop_Back<hhpp, String, unsigned int>  >  bt = new Backtrace_nt_iloop_Back<hhpp, String, unsigned int> (this, t_0_i, t_0_j);
  for (hhpp_hash_h::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, mfeanswer_v4>  elem = *elem_itr;
    std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_iloop_Front<String, unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > hhpp::bt_proxy_nt_multiloop(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > l;
  empty(l);
  hhpp_hash_h ret = nt_multiloop(t_0_i, t_0_j);
  if (is_empty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_multiloop_Back<hhpp, String, unsigned int>  >  bt = new Backtrace_nt_multiloop_Back<hhpp, String, unsigned int> (this, t_0_i, t_0_j);
  for (hhpp_hash_h::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, mfeanswer_v4>  elem = *elem_itr;
    std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_multiloop_Front<String, unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > hhpp::bt_proxy_nt_ml_comps(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > l;
  empty(l);
  hhpp_hash_h ret = nt_ml_comps(t_0_i, t_0_j);
  if (is_empty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_ml_comps_Back<hhpp, String, unsigned int>  >  bt = new Backtrace_nt_ml_comps_Back<hhpp, String, unsigned int> (this, t_0_i, t_0_j);
  for (hhpp_hash_h::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, mfeanswer_v4>  elem = *elem_itr;
    std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_ml_comps_Front<String, unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > hhpp::bt_proxy_nt_ml_comps1(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > l;
  empty(l);
  hhpp_hash_h ret = nt_ml_comps1(t_0_i, t_0_j);
  if (is_empty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_ml_comps1_Back<hhpp, String, unsigned int>  >  bt = new Backtrace_nt_ml_comps1_Back<hhpp, String, unsigned int> (this, t_0_i, t_0_j);
  for (hhpp_hash_h::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, mfeanswer_v4>  elem = *elem_itr;
    std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_ml_comps1_Front<String, unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hhpp::bt_nt_closed(unsigned int t_0_i, unsigned int t_0_j)
{
  if (!closed_table.is_tabulated(t_0_i, t_0_j))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);
  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_0 = bt_proxy_nt_stack(t_0_i, t_0_j);
  append( answers, ret_0);
  std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ret_1 = bt_proxy_nt_hairpin(t_0_i, t_0_j);
  if (is_not_empty(ret_1))
    {
      push_back( answers, ret_1);
    }

  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_2 = bt_proxy_nt_leftB(t_0_i, t_0_j);
  append( answers, ret_2);
  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_3 = bt_proxy_nt_rightB(t_0_i, t_0_j);
  append( answers, ret_3);
  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_4 = bt_proxy_nt_iloop(t_0_i, t_0_j);
  append( answers, ret_4);
  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_5 = bt_proxy_nt_multiloop(t_0_i, t_0_j);
  append( answers, ret_5);
  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > eval = h_bt(answers, closed_table.get(t_0_i, t_0_j));
  erase( answers);
  intrusive_ptr<Backtrace<String, unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hhpp::bt_nt_dangle(unsigned int t_0_i, unsigned int t_0_j)
{
  if (!dangle_table.is_tabulated(t_0_i, t_0_j))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 8))
  {
    TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
    TUSubsequence a_0 = ret_1;
    if (is_not_empty(a_0))
    {
      List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_2 = bt_proxy_nt_initstem((t_0_i + 1), t_0_j);
      List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > a_1 = ret_2;
      if (is_not_empty(a_1))
        {
          for (List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
            std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  x_1 = *x_1_itr;
            std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = edl_bt(a_0, x_1);
            if (ans.first.second.energy <= _thresh)  // rule1
              {
                push_back( answers, ans);
              }

          }
        }

      erase( a_1);
    }

    erase( a_0);
  }


  if (((t_0_j - t_0_i) >= 8))
  {
    TUSubsequence ret_5 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
    TUSubsequence a_3 = ret_5;
    if (is_not_empty(a_3))
    {
      List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_4 = bt_proxy_nt_initstem(t_0_i, (t_0_j - 1));
      List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > a_2 = ret_4;
      if (is_not_empty(a_2))
        {
          for (List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
            std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  x_2 = *x_2_itr;
            std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = edr_bt(x_2, a_3);
            if (ans.first.second.energy <= _thresh)  // rule1
              {
                push_back( answers, ans);
              }

          }
        }

      erase( a_2);
    }

    erase( a_3);
  }


  if (((t_0_j - t_0_i) >= 9))
  {
    TUSubsequence ret_9 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
    TUSubsequence a_6 = ret_9;
    if (is_not_empty(a_6))
    {
      TUSubsequence ret_7 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
      TUSubsequence a_4 = ret_7;
      if (is_not_empty(a_4))
      {
        List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_8 = bt_proxy_nt_initstem((t_0_i + 1), (t_0_j - 1));
        List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > a_5 = ret_8;
        if (is_not_empty(a_5))
          {
            for (List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_5_itr = a_5.ref().begin(); x_5_itr!=a_5.ref().end(); ++x_5_itr){
              std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  x_5 = *x_5_itr;
              std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = edlr_bt(a_4, x_5, a_6);
              if (ans.first.second.energy <= _thresh)  // rule1
                {
                  push_back( answers, ans);
                }

            }
          }

        erase( a_5);
      }

      erase( a_4);
    }

    erase( a_6);
  }


  if (((t_0_j - t_0_i) >= 7))
  {
    List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_11 = bt_proxy_nt_initstem(t_0_i, t_0_j);
    List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > a_7 = ret_11;
    if (is_not_empty(a_7))
      {
        for (List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_7_itr = a_7.ref().begin(); x_7_itr!=a_7.ref().end(); ++x_7_itr){
          std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  x_7 = *x_7_itr;
          std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = drem_bt(x_7);
          if (ans.first.second.energy <= _thresh)  // rule1
            {
              push_back( answers, ans);
            }

        }
      }

    erase( a_7);
  }

  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > eval = h_bt(answers, dangle_table.get(t_0_i, t_0_j));
  erase( answers);
  intrusive_ptr<Backtrace<String, unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hhpp::bt_nt_hairpin(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 7))
    {
      return 0;
    }

  std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  answers;
  empty( answers);
  std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ret_0;
  if (((t_0_j - t_0_i) >= 7))
    {
      if (((!_exact) && pairing_center_at(t_0_seq, t_0_i, t_0_j, _match_tokens_h, _theta)) || ((_exact) && exact_pairing_center_at(t_0_seq, t_0_i, t_0_j, _match_tokens_h)))  // added
      {                                                                                                                                                               // added
        TUSubsequence ret_5 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_4 = ret_5;
        if (is_not_empty(a_4))
        {
          TUSubsequence ret_4 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
          TUSubsequence a_3 = ret_4;
          if (is_not_empty(a_3))
          {
            TUSubsequence ret_3;
            if (minsize(t_0_seq, (t_0_i + 2), (t_0_j - 2), 3))
              {
                ret_3 = REGION(t_0_seq, (t_0_i + 2), (t_0_j - 2));
              }

            else
              {
                empty( ret_3);
              }

            TUSubsequence a_2 = ret_3;
            if (is_not_empty(a_2))
            {
              TUSubsequence ret_2 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
              TUSubsequence a_1 = ret_2;
              if (is_not_empty(a_1))
              {
                TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
                TUSubsequence a_0 = ret_1;
                if (is_not_empty(a_0))
                  {
                    ret_0 = hl_bt(a_0, a_1, a_2, a_3, a_4);
                  }

                else
                  {
                    empty( ret_0);
                  }

                erase( a_0);
              }

              else
                {
                  empty( ret_0);
                }

              erase( a_1);
            }

            else
              {
                empty( ret_0);
              }

            erase( a_2);
          }

          else
            {
              empty( ret_0);
            }

          erase( a_3);
        }

        else
          {
            empty( ret_0);
          }

        erase( a_4);
      }

      else
      {
        empty( ret_0);
        empty( ret_0);
      }

    }

  else
    {
      empty( ret_0);
    }

  answers = ret_0;
  intrusive_ptr<Backtrace<String, unsigned int> >  bt_list = execute_backtrack_k(answers);
  return bt_list;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hhpp::bt_nt_iloop(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 13))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 13))
    {
      if (stackpairing(t_0_seq, t_0_i, t_0_j))
      {
        TUSubsequence ret_8 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_7 = ret_8;
        if (is_not_empty(a_7))
        {
          TUSubsequence ret_7 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
          TUSubsequence a_6 = ret_7;
          if (is_not_empty(a_6))
          {
            TUSubsequence ret_2 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
            TUSubsequence a_1 = ret_2;
            if (is_not_empty(a_1))
            {
              TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
              TUSubsequence a_0 = ret_1;
              if (is_not_empty(a_0))
              {
                List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_3;
                empty(ret_3);
                if ((((t_0_j - 2) - (t_0_i + 2)) >= 9))
                  {
                    for(                    unsigned int t_0_k_0 = ((t_0_i + 2) + 1); ((t_0_k_0 <= ((t_0_j - 2) - 8)) && (t_0_k_0 <= ((t_0_i + 2) + 30))); ++t_0_k_0)
                    {
                      for(                      unsigned int t_0_k_1 = ((((t_0_j - 2) - (t_0_k_0 + 7)) >= 30)) ? (((t_0_j - 2) - 30)) : ((t_0_k_0 + 7)); (t_0_k_1 <= ((t_0_j - 2) - 1)); ++t_0_k_1)
                      {
                        TUSubsequence ret_6;
                        if (maxsize(t_0_seq, t_0_k_1, (t_0_j - 2), 30))
                          {
                            ret_6 = REGION(t_0_seq, t_0_k_1, (t_0_j - 2));
                          }

                        else
                          {
                            empty( ret_6);
                          }

                        TUSubsequence a_5 = ret_6;
                        if (is_not_empty(a_5))
                        {
                          TUSubsequence ret_4;
                          if (maxsize(t_0_seq, (t_0_i + 2), t_0_k_0, 30))
                            {
                              ret_4 = REGION(t_0_seq, (t_0_i + 2), t_0_k_0);
                            }

                          else
                            {
                              empty( ret_4);
                            }

                          TUSubsequence a_3 = ret_4;
                          if (is_not_empty(a_3))
                          {
                            List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_5 = bt_proxy_nt_closed(t_0_k_0, t_0_k_1);
                            List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > a_4 = ret_5;
                            if (is_not_empty(a_4))
                              {
                                for (List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_4_itr = a_4.ref().begin(); x_4_itr!=a_4.ref().end(); ++x_4_itr){
                                  std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  x_4 = *x_4_itr;
                                  std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = il_bt(a_3, x_4, a_5);
                                  push_back( ret_3, ans);
                                }
                              }

                            erase( a_4);
                          }

                          erase( a_3);
                        }

                        erase( a_5);
                      }

                    }

                  }

                finalize( ret_3);
                List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > a_2 = ret_3;
                if (is_not_empty(a_2))
                  {
                    for (List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                      std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  x_2 = *x_2_itr;
                      std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = sp_bt(a_0, a_1, x_2, a_6, a_7);
                      push_back( answers, ans);
                    }
                  }

                erase( a_2);
              }

              erase( a_0);
            }

            erase( a_1);
          }

          erase( a_6);
        }

        erase( a_7);
      }

      else
        {
          empty( answers);
        }

    }

  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > eval = h_bt(answers);
  erase( answers);
  intrusive_ptr<Backtrace<String, unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hhpp::bt_nt_initstem(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 7))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 7))
  {
    List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_1 = bt_proxy_nt_closed(t_0_i, t_0_j);
    List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > a_0 = ret_1;
    if (is_not_empty(a_0))
      {
        for (List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_0_itr = a_0.ref().begin(); x_0_itr!=a_0.ref().end(); ++x_0_itr){
          std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  x_0 = *x_0_itr;
          std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = is_bt(x_0);
          push_back( answers, ans);
        }
      }

    erase( a_0);
  }

  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > eval = h_bt(answers);
  erase( answers);
  intrusive_ptr<Backtrace<String, unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hhpp::bt_nt_leftB(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 12))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 12))
    {
      if (stackpairing(t_0_seq, t_0_i, t_0_j))
      {
        TUSubsequence ret_7 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_6 = ret_7;
        if (is_not_empty(a_6))
        {
          TUSubsequence ret_6 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
          TUSubsequence a_5 = ret_6;
          if (is_not_empty(a_5))
          {
            TUSubsequence ret_2 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
            TUSubsequence a_1 = ret_2;
            if (is_not_empty(a_1))
            {
              TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
              TUSubsequence a_0 = ret_1;
              if (is_not_empty(a_0))
              {
                List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_3;
                empty(ret_3);
                if ((((t_0_j - 2) - (t_0_i + 2)) >= 8))
                  {
                    for(                    unsigned int t_0_k_0 = ((t_0_i + 2) + 1); (t_0_k_0 <= ((t_0_j - 2) - 7)); ++t_0_k_0)
                    {
                      TUSubsequence ret_4 = REGION(t_0_seq, (t_0_i + 2), t_0_k_0);
                      TUSubsequence a_3 = ret_4;
                      if (is_not_empty(a_3))
                      {
                        List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_5 = bt_proxy_nt_closed(t_0_k_0, (t_0_j - 2));
                        List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > a_4 = ret_5;
                        if (is_not_empty(a_4))
                          {
                            for (List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_4_itr = a_4.ref().begin(); x_4_itr!=a_4.ref().end(); ++x_4_itr){
                              std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  x_4 = *x_4_itr;
                              std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = bl_bt(a_3, x_4);
                              push_back( ret_3, ans);
                            }
                          }

                        erase( a_4);
                      }

                      erase( a_3);
                    }

                  }

                finalize( ret_3);
                List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > a_2 = ret_3;
                if (is_not_empty(a_2))
                  {
                    for (List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                      std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  x_2 = *x_2_itr;
                      std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = sp_bt(a_0, a_1, x_2, a_5, a_6);
                      push_back( answers, ans);
                    }
                  }

                erase( a_2);
              }

              erase( a_0);
            }

            erase( a_1);
          }

          erase( a_5);
        }

        erase( a_6);
      }

      else
        {
          empty( answers);
        }

    }

  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > eval = h_bt(answers);
  erase( answers);
  intrusive_ptr<Backtrace<String, unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hhpp::bt_nt_ml_comps(unsigned int t_0_i, unsigned int t_0_j)
{
  if (!ml_comps_table.is_tabulated(t_0_i, t_0_j))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 14))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 7); (t_0_k_0 <= (t_0_j - 7)); ++t_0_k_0)
      {
        List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_3 = bt_proxy_nt_ml_comps1(t_0_k_0, t_0_j);
        List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > a_2 = ret_3;
        if (is_not_empty(a_2))
        {
          List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_1;
          empty(ret_1);
          if (((t_0_k_0 - t_0_i) >= 7))
          {
            List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_2 = bt_proxy_nt_dangle(t_0_i, t_0_k_0);
            List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > a_1 = ret_2;
            if (is_not_empty(a_1))
              {
                for (List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
                  std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  x_1 = *x_1_itr;
                  std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = incl_bt(x_1);
                  push_back( ret_1, ans);
                }
              }

            erase( a_1);
          }

          finalize( ret_1);
          List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > a_0 = ret_1;
          if (is_not_empty(a_0))
            {
              for (List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_0_itr = a_0.ref().begin(); x_0_itr!=a_0.ref().end(); ++x_0_itr){
                std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  x_0 = *x_0_itr;
                for (List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                  std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  x_2 = *x_2_itr;
                  std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = cadd_bt(x_0, x_2);
                  push_back( answers, ans);
                }
              }
            }

          erase( a_0);
        }

        else
          {
            for (List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator elem_itr = a_2.ref().begin(); elem_itr!=a_2.ref().end(); ++elem_itr){
              std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  elem = *elem_itr;
              erase( elem.second);
            }
          }

        erase( a_2);
      }

    }


  if (((t_0_j - t_0_i) >= 15))
  {
    TUSubsequence ret_5 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
    TUSubsequence a_3 = ret_5;
    if (is_not_empty(a_3))
    {
      List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_6 = bt_proxy_nt_ml_comps((t_0_i + 1), t_0_j);
      List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > a_4 = ret_6;
      if (is_not_empty(a_4))
        {
          for (List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_4_itr = a_4.ref().begin(); x_4_itr!=a_4.ref().end(); ++x_4_itr){
            std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  x_4 = *x_4_itr;
            std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = sadd_bt(a_3, x_4);
            push_back( answers, ans);
          }
        }

      erase( a_4);
    }

    erase( a_3);
  }

  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > eval = h_bt(answers, ml_comps_table.get(t_0_i, t_0_j));
  erase( answers);
  intrusive_ptr<Backtrace<String, unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hhpp::bt_nt_ml_comps1(unsigned int t_0_i, unsigned int t_0_j)
{
  if (!ml_comps1_table.is_tabulated(t_0_i, t_0_j))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 14))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 7); (t_0_k_0 <= (t_0_j - 7)); ++t_0_k_0)
      {
        List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_3 = bt_proxy_nt_ml_comps1(t_0_k_0, t_0_j);
        List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > a_2 = ret_3;
        if (is_not_empty(a_2))
        {
          List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_1;
          empty(ret_1);
          if (((t_0_k_0 - t_0_i) >= 7))
          {
            List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_2 = bt_proxy_nt_dangle(t_0_i, t_0_k_0);
            List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > a_1 = ret_2;
            if (is_not_empty(a_1))
              {
                for (List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
                  std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  x_1 = *x_1_itr;
                  std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = incl_bt(x_1);
                  push_back( ret_1, ans);
                }
              }

            erase( a_1);
          }

          finalize( ret_1);
          List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > a_0 = ret_1;
          if (is_not_empty(a_0))
            {
              for (List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_0_itr = a_0.ref().begin(); x_0_itr!=a_0.ref().end(); ++x_0_itr){
                std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  x_0 = *x_0_itr;
                for (List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                  std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  x_2 = *x_2_itr;
                  std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = cadd_bt(x_0, x_2);
                  push_back( answers, ans);
                }
              }
            }

          erase( a_0);
        }

        else
          {
            for (List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator elem_itr = a_2.ref().begin(); elem_itr!=a_2.ref().end(); ++elem_itr){
              std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  elem = *elem_itr;
              erase( elem.second);
            }
          }

        erase( a_2);
      }

    }


  if (((t_0_j - t_0_i) >= 8))
  {
    TUSubsequence ret_5 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
    TUSubsequence a_3 = ret_5;
    if (is_not_empty(a_3))
    {
      List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_6 = bt_proxy_nt_ml_comps1((t_0_i + 1), t_0_j);
      List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > a_4 = ret_6;
      if (is_not_empty(a_4))
        {
          for (List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_4_itr = a_4.ref().begin(); x_4_itr!=a_4.ref().end(); ++x_4_itr){
            std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  x_4 = *x_4_itr;
            std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = sadd_bt(a_3, x_4);
            push_back( answers, ans);
          }
        }

      erase( a_4);
    }

    erase( a_3);
  }


  if (((t_0_j - t_0_i) >= 7))
  {
    List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_8 = bt_proxy_nt_dangle(t_0_i, t_0_j);
    List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > a_5 = ret_8;
    if (is_not_empty(a_5))
      {
        for (List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_5_itr = a_5.ref().begin(); x_5_itr!=a_5.ref().end(); ++x_5_itr){
          std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  x_5 = *x_5_itr;
          std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = incl_bt(x_5);
          push_back( answers, ans);
        }
      }

    erase( a_5);
  }


  if (((t_0_j - t_0_i) >= 8))
    {
      for(      unsigned int t_0_k_1 = (t_0_i + 7); (t_0_k_1 <= (t_0_j - 1)); ++t_0_k_1)
      {
        TUSubsequence ret_12 = REGION(t_0_seq, t_0_k_1, t_0_j);
        TUSubsequence a_8 = ret_12;
        if (is_not_empty(a_8))
        {
          List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_10;
          empty(ret_10);
          if (((t_0_k_1 - t_0_i) >= 7))
          {
            List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_11 = bt_proxy_nt_dangle(t_0_i, t_0_k_1);
            List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > a_7 = ret_11;
            if (is_not_empty(a_7))
              {
                for (List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_7_itr = a_7.ref().begin(); x_7_itr!=a_7.ref().end(); ++x_7_itr){
                  std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  x_7 = *x_7_itr;
                  std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = incl_bt(x_7);
                  push_back( ret_10, ans);
                }
              }

            erase( a_7);
          }

          finalize( ret_10);
          List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > a_6 = ret_10;
          if (is_not_empty(a_6))
            {
              for (List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_6_itr = a_6.ref().begin(); x_6_itr!=a_6.ref().end(); ++x_6_itr){
                std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  x_6 = *x_6_itr;
                std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = addss_bt(x_6, a_8);
                push_back( answers, ans);
              }
            }

          erase( a_6);
        }

        erase( a_8);
      }

    }

  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > eval = h_bt(answers, ml_comps1_table.get(t_0_i, t_0_j));
  erase( answers);
  intrusive_ptr<Backtrace<String, unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hhpp::bt_nt_multiloop(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 18))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 18))
    {
      if (stackpairing(t_0_seq, t_0_i, t_0_j))
      {
        TUSubsequence ret_5 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_4 = ret_5;
        if (is_not_empty(a_4))
        {
          TUSubsequence ret_4 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
          TUSubsequence a_3 = ret_4;
          if (is_not_empty(a_3))
          {
            TUSubsequence ret_2 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
            TUSubsequence a_1 = ret_2;
            if (is_not_empty(a_1))
            {
              TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
              TUSubsequence a_0 = ret_1;
              if (is_not_empty(a_0))
              {
                List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_3 = bt_proxy_nt_ml_comps((t_0_i + 2), (t_0_j - 2));
                List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > a_2 = ret_3;
                if (is_not_empty(a_2))
                  {
                    for (List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                      std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  x_2 = *x_2_itr;
                      std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = ml_bt(a_0, a_1, x_2, a_3, a_4);
                      push_back( answers, ans);
                    }
                  }

                erase( a_2);
              }

              erase( a_0);
            }

            erase( a_1);
          }

          erase( a_3);
        }

        erase( a_4);
      }

      else
        {
          empty( answers);
        }

    }


  if (((t_0_j - t_0_i) >= 19))
    {
      if (stackpairing(t_0_seq, t_0_i, t_0_j))
      {
        TUSubsequence ret_12 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_10 = ret_12;
        if (is_not_empty(a_10))
        {
          TUSubsequence ret_11 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
          TUSubsequence a_9 = ret_11;
          if (is_not_empty(a_9))
          {
            TUSubsequence ret_9 = BASE(t_0_seq, (t_0_i + 2), ((t_0_i + 2) + 1));
            TUSubsequence a_7 = ret_9;
            if (is_not_empty(a_7))
            {
              TUSubsequence ret_8 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
              TUSubsequence a_6 = ret_8;
              if (is_not_empty(a_6))
              {
                TUSubsequence ret_7 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
                TUSubsequence a_5 = ret_7;
                if (is_not_empty(a_5))
                {
                  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_10 = bt_proxy_nt_ml_comps((t_0_i + 3), (t_0_j - 2));
                  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > a_8 = ret_10;
                  if (is_not_empty(a_8))
                    {
                      for (List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_8_itr = a_8.ref().begin(); x_8_itr!=a_8.ref().end(); ++x_8_itr){
                        std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  x_8 = *x_8_itr;
                        std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = mldl_bt(a_5, a_6, a_7, x_8, a_9, a_10);
                        push_back( answers, ans);
                      }
                    }

                  erase( a_8);
                }

                erase( a_5);
              }

              erase( a_6);
            }

            erase( a_7);
          }

          erase( a_9);
        }

        erase( a_10);
      }

      else
        {
          empty( answers);
        }

    }


  if (((t_0_j - t_0_i) >= 19))
    {
      if (stackpairing(t_0_seq, t_0_i, t_0_j))
      {
        TUSubsequence ret_19 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_16 = ret_19;
        if (is_not_empty(a_16))
        {
          TUSubsequence ret_18 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
          TUSubsequence a_15 = ret_18;
          if (is_not_empty(a_15))
          {
            TUSubsequence ret_17 = BASE(t_0_seq, (t_0_j - 3), (t_0_j - 2));
            TUSubsequence a_14 = ret_17;
            if (is_not_empty(a_14))
            {
              TUSubsequence ret_15 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
              TUSubsequence a_12 = ret_15;
              if (is_not_empty(a_12))
              {
                TUSubsequence ret_14 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
                TUSubsequence a_11 = ret_14;
                if (is_not_empty(a_11))
                {
                  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_16 = bt_proxy_nt_ml_comps((t_0_i + 2), (t_0_j - 3));
                  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > a_13 = ret_16;
                  if (is_not_empty(a_13))
                    {
                      for (List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_13_itr = a_13.ref().begin(); x_13_itr!=a_13.ref().end(); ++x_13_itr){
                        std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  x_13 = *x_13_itr;
                        std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = mldr_bt(a_11, a_12, x_13, a_14, a_15, a_16);
                        push_back( answers, ans);
                      }
                    }

                  erase( a_13);
                }

                erase( a_11);
              }

              erase( a_12);
            }

            erase( a_14);
          }

          erase( a_15);
        }

        erase( a_16);
      }

      else
        {
          empty( answers);
        }

    }


  if (((t_0_j - t_0_i) >= 20))
    {
      if (stackpairing(t_0_seq, t_0_i, t_0_j))
      {
        TUSubsequence ret_27 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_23 = ret_27;
        if (is_not_empty(a_23))
        {
          TUSubsequence ret_26 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
          TUSubsequence a_22 = ret_26;
          if (is_not_empty(a_22))
          {
            TUSubsequence ret_25 = BASE(t_0_seq, (t_0_j - 3), (t_0_j - 2));
            TUSubsequence a_21 = ret_25;
            if (is_not_empty(a_21))
            {
              TUSubsequence ret_23 = BASE(t_0_seq, (t_0_i + 2), ((t_0_i + 2) + 1));
              TUSubsequence a_19 = ret_23;
              if (is_not_empty(a_19))
              {
                TUSubsequence ret_22 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
                TUSubsequence a_18 = ret_22;
                if (is_not_empty(a_18))
                {
                  TUSubsequence ret_21 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
                  TUSubsequence a_17 = ret_21;
                  if (is_not_empty(a_17))
                  {
                    List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_24 = bt_proxy_nt_ml_comps((t_0_i + 3), (t_0_j - 3));
                    List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > a_20 = ret_24;
                    if (is_not_empty(a_20))
                      {
                        for (List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_20_itr = a_20.ref().begin(); x_20_itr!=a_20.ref().end(); ++x_20_itr){
                          std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  x_20 = *x_20_itr;
                          std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = mldlr_bt(a_17, a_18, a_19, x_20, a_21, a_22, a_23);
                          push_back( answers, ans);
                        }
                      }

                    erase( a_20);
                  }

                  erase( a_17);
                }

                erase( a_18);
              }

              erase( a_19);
            }

            erase( a_21);
          }

          erase( a_22);
        }

        erase( a_23);
      }

      else
        {
          empty( answers);
        }

    }

  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > eval = h_bt(answers);
  erase( answers);
  intrusive_ptr<Backtrace<String, unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hhpp::bt_nt_rightB(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 12))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 12))
    {
      if (stackpairing(t_0_seq, t_0_i, t_0_j))
      {
        TUSubsequence ret_7 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_6 = ret_7;
        if (is_not_empty(a_6))
        {
          TUSubsequence ret_6 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
          TUSubsequence a_5 = ret_6;
          if (is_not_empty(a_5))
          {
            TUSubsequence ret_2 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
            TUSubsequence a_1 = ret_2;
            if (is_not_empty(a_1))
            {
              TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
              TUSubsequence a_0 = ret_1;
              if (is_not_empty(a_0))
              {
                List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_3;
                empty(ret_3);
                if ((((t_0_j - 2) - (t_0_i + 2)) >= 8))
                  {
                    for(                    unsigned int t_0_k_0 = ((t_0_i + 2) + 7); (t_0_k_0 <= ((t_0_j - 2) - 1)); ++t_0_k_0)
                    {
                      TUSubsequence ret_5 = REGION(t_0_seq, t_0_k_0, (t_0_j - 2));
                      TUSubsequence a_4 = ret_5;
                      if (is_not_empty(a_4))
                      {
                        List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_4 = bt_proxy_nt_closed((t_0_i + 2), t_0_k_0);
                        List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > a_3 = ret_4;
                        if (is_not_empty(a_3))
                          {
                            for (List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_3_itr = a_3.ref().begin(); x_3_itr!=a_3.ref().end(); ++x_3_itr){
                              std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  x_3 = *x_3_itr;
                              std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = br_bt(x_3, a_4);
                              push_back( ret_3, ans);
                            }
                          }

                        erase( a_3);
                      }

                      erase( a_4);
                    }

                  }

                finalize( ret_3);
                List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > a_2 = ret_3;
                if (is_not_empty(a_2))
                  {
                    for (List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                      std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  x_2 = *x_2_itr;
                      std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = sp_bt(a_0, a_1, x_2, a_5, a_6);
                      push_back( answers, ans);
                    }
                  }

                erase( a_2);
              }

              erase( a_0);
            }

            erase( a_1);
          }

          erase( a_5);
        }

        erase( a_6);
      }

      else
        {
          empty( answers);
        }

    }

  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > eval = h_bt(answers);
  erase( answers);
  intrusive_ptr<Backtrace<String, unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hhpp::bt_nt_stack(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 9))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 9))
    {
      if (basepairing(t_0_seq, t_0_i, t_0_j))
      {
        TUSubsequence ret_3 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_2 = ret_3;
        if (is_not_empty(a_2))
        {
          TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
          TUSubsequence a_0 = ret_1;
          if (is_not_empty(a_0))
          {
            List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_2 = bt_proxy_nt_closed((t_0_i + 1), (t_0_j - 1));
            List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > a_1 = ret_2;
            if (is_not_empty(a_1))
              {
                for (List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
                  std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  x_1 = *x_1_itr;
                  std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = sr_bt(a_0, x_1, a_2);
                  push_back( answers, ans);
                }
              }

            erase( a_1);
          }

          erase( a_0);
        }

        erase( a_2);
      }

      else
        {
          empty( answers);
        }

    }

  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > eval = h_bt(answers);
  erase( answers);
  intrusive_ptr<Backtrace<String, unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hhpp::bt_nt_struct(unsigned int t_0_i)
{
  if (!struct_table.is_tabulated(t_0_i))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);

  if (((t_0_right_most - t_0_i) >= 7))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 7); (t_0_k_0 <= t_0_right_most); ++t_0_k_0)
      {
        List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_2 = bt_proxy_nt_struct(t_0_k_0);
        List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > a_1 = ret_2;
        if (is_not_empty(a_1))
        {
          List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_1 = bt_proxy_nt_dangle(t_0_i, t_0_k_0);
          List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > a_0 = ret_1;
          if (is_not_empty(a_0))
            {
              for (List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_0_itr = a_0.ref().begin(); x_0_itr!=a_0.ref().end(); ++x_0_itr){
                std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  x_0 = *x_0_itr;
                for (List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
                  std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  x_1 = *x_1_itr;
                  std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = cadd_bt(x_0, x_1);
                  push_back( answers, ans);
                }
              }
            }

          erase( a_0);
        }

        else
          {
            for (List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator elem_itr = a_1.ref().begin(); elem_itr!=a_1.ref().end(); ++elem_itr){
              std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  elem = *elem_itr;
              erase( elem.second);
            }
          }

        erase( a_1);
      }

    }


  if (((t_0_right_most - t_0_i) >= 1))
  {
    TUSubsequence ret_4 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
    TUSubsequence a_2 = ret_4;
    if (is_not_empty(a_2))
    {
      List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_5 = bt_proxy_nt_struct((t_0_i + 1));
      List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > a_3 = ret_5;
      if (is_not_empty(a_3))
        {
          for (List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_3_itr = a_3.ref().begin(); x_3_itr!=a_3.ref().end(); ++x_3_itr){
            std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  x_3 = *x_3_itr;
            std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = sadd_bt(a_2, x_3);
            push_back( answers, ans);
          }
        }

      erase( a_3);
    }

    erase( a_2);
  }

  std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ret_6;
  if ((((t_0_right_most - t_0_i) >= 0) && ((t_0_right_most - t_0_i) <= 0)))
  {
    TUSubsequence ret_7 = LOC(t_0_seq, t_0_i, t_0_i);
    TUSubsequence a_4 = ret_7;
    if (is_not_empty(a_4))
      {
        ret_6 = nil_bt(a_4);
      }

    else
      {
        empty( ret_6);
      }

    erase( a_4);
  }

  else
    {
      empty( ret_6);
    }

  if (is_not_empty(ret_6))
    {
      push_back( answers, ret_6);
    }

  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > eval = h_bt(answers, struct_table.get(t_0_i));
  erase( answers);
  intrusive_ptr<Backtrace<String, unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}


intrusive_ptr<Backtrace<String, unsigned int> >  hhpp::addss_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0, const TUSubsequence & param_1)
{
  return new Backtrace_addss<String, unsigned int> (param_0, param_1);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hhpp::bl_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1)
{
  return new Backtrace_bl<String, unsigned int> (param_0, param_1);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hhpp::br_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0, const TUSubsequence & param_1)
{
  return new Backtrace_br<String, unsigned int> (param_0, param_1);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hhpp::cadd_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1)
{
  return new Backtrace_cadd<String, unsigned int> (param_0, param_1);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hhpp::drem_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0)
{
  return new Backtrace_drem<String, unsigned int> (param_0);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hhpp::edl_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1)
{
  return new Backtrace_edl<String, unsigned int> (param_0, param_1);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hhpp::edlr_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1, const TUSubsequence & param_2)
{
  return new Backtrace_edlr<String, unsigned int> (param_0, param_1, param_2);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hhpp::edr_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0, const TUSubsequence & param_1)
{
  return new Backtrace_edr<String, unsigned int> (param_0, param_1);
}

List_Ref<intrusive_ptr<Backtrace<String, unsigned int> > > hhpp::h_bt_r(List_Ref<intrusive_ptr<Backtrace<String, unsigned int> > > param_0)
{
  return param_0;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hhpp::hl_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, const TUSubsequence & param_2, const TUSubsequence & param_3, const TUSubsequence & param_4)
{
  return new Backtrace_hl<String, unsigned int> (param_0, param_1, param_2, param_3, param_4);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hhpp::il_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1, const TUSubsequence & param_2)
{
  return new Backtrace_il<String, unsigned int> (param_0, param_1, param_2);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hhpp::incl_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0)
{
  return new Backtrace_incl<String, unsigned int> (param_0);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hhpp::is_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0)
{
  return new Backtrace_is<String, unsigned int> (param_0);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hhpp::ml_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<String, unsigned int> >  param_2, const TUSubsequence & param_3, const TUSubsequence & param_4)
{
  return new Backtrace_ml<String, unsigned int> (param_0, param_1, param_2, param_3, param_4);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hhpp::mldl_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, const TUSubsequence & param_2, intrusive_ptr<Backtrace<String, unsigned int> >  param_3, const TUSubsequence & param_4, const TUSubsequence & param_5)
{
  return new Backtrace_mldl<String, unsigned int> (param_0, param_1, param_2, param_3, param_4, param_5);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hhpp::mldlr_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, const TUSubsequence & param_2, intrusive_ptr<Backtrace<String, unsigned int> >  param_3, const TUSubsequence & param_4, const TUSubsequence & param_5, const TUSubsequence & param_6)
{
  return new Backtrace_mldlr<String, unsigned int> (param_0, param_1, param_2, param_3, param_4, param_5, param_6);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hhpp::mldr_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<String, unsigned int> >  param_2, const TUSubsequence & param_3, const TUSubsequence & param_4, const TUSubsequence & param_5)
{
  return new Backtrace_mldr<String, unsigned int> (param_0, param_1, param_2, param_3, param_4, param_5);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hhpp::nil_bt_r(const TUSubsequence & param_0)
{
  return new Backtrace_nil<String, unsigned int> (param_0);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hhpp::sadd_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1)
{
  return new Backtrace_sadd<String, unsigned int> (param_0, param_1);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hhpp::sp_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<String, unsigned int> >  param_2, const TUSubsequence & param_3, const TUSubsequence & param_4)
{
  return new Backtrace_sp<String, unsigned int> (param_0, param_1, param_2, param_3, param_4);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hhpp::sr_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1, const TUSubsequence & param_2)
{
  return new Backtrace_sr<String, unsigned int> (param_0, param_1, param_2);
}



std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  hhpp::addss_bt(const std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb)
{
  std::pair<Rope, mfeanswer_v4>  l_0 = p_p_e.first;
  TUSubsequence l_1 = p_p_rb;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_0 = p_p_e.second;
  TUSubsequence r_1 = p_p_rb;
  std::pair<Rope, mfeanswer_v4>  ret_left = addss(l_0, l_1);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = addss_bt_r(r_0, r_1);
  std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  hhpp::bl_bt(const TUSubsequence & p_p_lregion, const std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e)
{
  TUSubsequence l_0 = p_p_lregion;
  std::pair<Rope, mfeanswer_v4>  l_1 = p_p_e.first;
  TUSubsequence r_0 = p_p_lregion;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_1 = p_p_e.second;
  std::pair<Rope, mfeanswer_v4>  ret_left = bl(l_0, l_1);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = bl_bt_r(r_0, r_1);
  std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  hhpp::br_bt(const std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rregion)
{
  std::pair<Rope, mfeanswer_v4>  l_0 = p_p_e.first;
  TUSubsequence l_1 = p_p_rregion;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_0 = p_p_e.second;
  TUSubsequence r_1 = p_p_rregion;
  std::pair<Rope, mfeanswer_v4>  ret_left = br(l_0, l_1);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = br_bt_r(r_0, r_1);
  std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  hhpp::cadd_bt(const std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_le, const std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_re)
{
  std::pair<Rope, mfeanswer_v4>  l_0 = p_p_le.first;
  std::pair<Rope, mfeanswer_v4>  l_1 = p_p_re.first;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_0 = p_p_le.second;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_1 = p_p_re.second;
  std::pair<Rope, mfeanswer_v4>  ret_left = cadd(l_0, l_1);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = cadd_bt_r(r_0, r_1);
  std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  hhpp::drem_bt(const std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e)
{
  std::pair<Rope, mfeanswer_v4>  l_0 = p_p_e.first;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_0 = p_p_e.second;
  std::pair<Rope, mfeanswer_v4>  ret_left = drem(l_0);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = drem_bt_r(r_0);
  std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  hhpp::edl_bt(const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e)
{
  TUSubsequence l_0 = p_p_lb;
  std::pair<Rope, mfeanswer_v4>  l_1 = p_p_e.first;
  TUSubsequence r_0 = p_p_lb;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_1 = p_p_e.second;
  std::pair<Rope, mfeanswer_v4>  ret_left = edl(l_0, l_1);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = edl_bt_r(r_0, r_1);
  std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  hhpp::edlr_bt(const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb)
{
  TUSubsequence l_0 = p_p_lb;
  std::pair<Rope, mfeanswer_v4>  l_1 = p_p_e.first;
  TUSubsequence l_2 = p_p_rb;
  TUSubsequence r_0 = p_p_lb;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_1 = p_p_e.second;
  TUSubsequence r_2 = p_p_rb;
  std::pair<Rope, mfeanswer_v4>  ret_left = edlr(l_0, l_1, l_2);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = edlr_bt_r(r_0, r_1, r_2);
  std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  hhpp::edr_bt(const std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb)
{
  std::pair<Rope, mfeanswer_v4>  l_0 = p_p_e.first;
  TUSubsequence l_1 = p_p_rb;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_0 = p_p_e.second;
  TUSubsequence r_1 = p_p_rb;
  std::pair<Rope, mfeanswer_v4>  ret_left = edr(l_0, l_1);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = edr_bt_r(r_0, r_1);
  std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > hhpp::h_bt(List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > i, hhpp_hash_h &  left_answers)
{
  std::pair<List<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator, List<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator> range = get_range(i);
  return h_bt(range);
}

template <typename Iterator>
List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > hhpp::h_bt(std::pair<Iterator, Iterator> i, hhpp_hash_h &  left_answers)

{
  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);


  if (is_empty(left_answers))
  {
    List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > temp;
    empty(temp);
    empty( temp);
    erase( left_answers);
    return temp;
  }

  for (hhpp_hash_h::iterator elem = left_answers.ref().begin(); elem!=left_answers.ref().end(); ++elem){
    for (Iterator tupel = i.first; tupel != i.second; ++tupel) {
      if (((*tupel).first == (*elem)))
      {
        push_back( answers, (*tupel));
        break;
      }

    }
  }
  return answers;
}

List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > hhpp::h_bt(List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > i)
{
  std::pair<List<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator, List<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator> range = get_range(i);
  return h_bt(range);
}

template <typename Iterator>
List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > hhpp::h_bt(std::pair<Iterator, Iterator> i)

{
  List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);
  std::pair<Proxy::Iterator<Iterator, select1st<typename Iterator::value_type> >  ,Proxy::Iterator<Iterator, select1st<typename Iterator::value_type> > >  left = splice_left(i);
  hhpp_hash_h left_answers = h(left);
  if (is_empty(left_answers))
  {
    List_Ref<std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > > temp;
    empty(temp);
    empty( temp);
    erase( left_answers);
    return temp;
  }

  for (hhpp_hash_h::iterator elem = left_answers.ref().begin(); elem!=left_answers.ref().end(); ++elem){
    for (Iterator tupel = i.first; tupel != i.second; ++tupel) {
      if (((*tupel).first == (*elem)))
      {
        push_back( answers, (*tupel));
        break;
      }

    }
  }
  return answers;
}

std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  hhpp::hl_bt(const TUSubsequence & p_p_llb, const TUSubsequence & p_p_lb, const TUSubsequence & p_p_region, const TUSubsequence & p_p_rb, const TUSubsequence & p_p_rrb)
{
  TUSubsequence l_0 = p_p_llb;
  TUSubsequence l_1 = p_p_lb;
  TUSubsequence l_2 = p_p_region;
  TUSubsequence l_3 = p_p_rb;
  TUSubsequence l_4 = p_p_rrb;
  TUSubsequence r_0 = p_p_llb;
  TUSubsequence r_1 = p_p_lb;
  TUSubsequence r_2 = p_p_region;
  TUSubsequence r_3 = p_p_rb;
  TUSubsequence r_4 = p_p_rrb;
  std::pair<Rope, mfeanswer_v4>  ret_left = hl(l_0, l_1, l_2, l_3, l_4);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = hl_bt_r(r_0, r_1, r_2, r_3, r_4);
  std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  hhpp::il_bt(const TUSubsequence & p_p_lregion, const std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rregion)
{
  TUSubsequence l_0 = p_p_lregion;
  std::pair<Rope, mfeanswer_v4>  l_1 = p_p_e.first;
  TUSubsequence l_2 = p_p_rregion;
  TUSubsequence r_0 = p_p_lregion;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_1 = p_p_e.second;
  TUSubsequence r_2 = p_p_rregion;
  std::pair<Rope, mfeanswer_v4>  ret_left = il(l_0, l_1, l_2);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = il_bt_r(r_0, r_1, r_2);
  std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  hhpp::incl_bt(const std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e)
{
  std::pair<Rope, mfeanswer_v4>  l_0 = p_p_e.first;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_0 = p_p_e.second;
  std::pair<Rope, mfeanswer_v4>  ret_left = incl(l_0);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = incl_bt_r(r_0);
  std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  hhpp::is_bt(const std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e)
{
  std::pair<Rope, mfeanswer_v4>  l_0 = p_p_e.first;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_0 = p_p_e.second;
  std::pair<Rope, mfeanswer_v4>  ret_left = is(l_0);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = is_bt_r(r_0);
  std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  hhpp::ml_bt(const TUSubsequence & p_p_llb, const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb, const TUSubsequence & p_p_rrb)
{
  TUSubsequence l_0 = p_p_llb;
  TUSubsequence l_1 = p_p_lb;
  std::pair<Rope, mfeanswer_v4>  l_2 = p_p_e.first;
  TUSubsequence l_3 = p_p_rb;
  TUSubsequence l_4 = p_p_rrb;
  TUSubsequence r_0 = p_p_llb;
  TUSubsequence r_1 = p_p_lb;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_2 = p_p_e.second;
  TUSubsequence r_3 = p_p_rb;
  TUSubsequence r_4 = p_p_rrb;
  std::pair<Rope, mfeanswer_v4>  ret_left = ml(l_0, l_1, l_2, l_3, l_4);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = ml_bt_r(r_0, r_1, r_2, r_3, r_4);
  std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  hhpp::mldl_bt(const TUSubsequence & p_p_llb, const TUSubsequence & p_p_lb, const TUSubsequence & p_p_dl, const std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb, const TUSubsequence & p_p_rrb)
{
  TUSubsequence l_0 = p_p_llb;
  TUSubsequence l_1 = p_p_lb;
  TUSubsequence l_2 = p_p_dl;
  std::pair<Rope, mfeanswer_v4>  l_3 = p_p_e.first;
  TUSubsequence l_4 = p_p_rb;
  TUSubsequence l_5 = p_p_rrb;
  TUSubsequence r_0 = p_p_llb;
  TUSubsequence r_1 = p_p_lb;
  TUSubsequence r_2 = p_p_dl;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_3 = p_p_e.second;
  TUSubsequence r_4 = p_p_rb;
  TUSubsequence r_5 = p_p_rrb;
  std::pair<Rope, mfeanswer_v4>  ret_left = mldl(l_0, l_1, l_2, l_3, l_4, l_5);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = mldl_bt_r(r_0, r_1, r_2, r_3, r_4, r_5);
  std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  hhpp::mldlr_bt(const TUSubsequence & p_p_llb, const TUSubsequence & p_p_lb, const TUSubsequence & p_p_dl, const std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_dr, const TUSubsequence & p_p_rb, const TUSubsequence & p_p_rrb)
{
  TUSubsequence l_0 = p_p_llb;
  TUSubsequence l_1 = p_p_lb;
  TUSubsequence l_2 = p_p_dl;
  std::pair<Rope, mfeanswer_v4>  l_3 = p_p_e.first;
  TUSubsequence l_4 = p_p_dr;
  TUSubsequence l_5 = p_p_rb;
  TUSubsequence l_6 = p_p_rrb;
  TUSubsequence r_0 = p_p_llb;
  TUSubsequence r_1 = p_p_lb;
  TUSubsequence r_2 = p_p_dl;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_3 = p_p_e.second;
  TUSubsequence r_4 = p_p_dr;
  TUSubsequence r_5 = p_p_rb;
  TUSubsequence r_6 = p_p_rrb;
  std::pair<Rope, mfeanswer_v4>  ret_left = mldlr(l_0, l_1, l_2, l_3, l_4, l_5, l_6);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = mldlr_bt_r(r_0, r_1, r_2, r_3, r_4, r_5, r_6);
  std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  hhpp::mldr_bt(const TUSubsequence & p_p_llb, const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_dr, const TUSubsequence & p_p_rb, const TUSubsequence & p_p_rrb)
{
  TUSubsequence l_0 = p_p_llb;
  TUSubsequence l_1 = p_p_lb;
  std::pair<Rope, mfeanswer_v4>  l_2 = p_p_e.first;
  TUSubsequence l_3 = p_p_dr;
  TUSubsequence l_4 = p_p_rb;
  TUSubsequence l_5 = p_p_rrb;
  TUSubsequence r_0 = p_p_llb;
  TUSubsequence r_1 = p_p_lb;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_2 = p_p_e.second;
  TUSubsequence r_3 = p_p_dr;
  TUSubsequence r_4 = p_p_rb;
  TUSubsequence r_5 = p_p_rrb;
  std::pair<Rope, mfeanswer_v4>  ret_left = mldr(l_0, l_1, l_2, l_3, l_4, l_5);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = mldr_bt_r(r_0, r_1, r_2, r_3, r_4, r_5);
  std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  hhpp::nil_bt(const TUSubsequence & p_p_loc)
{
  TUSubsequence l_0 = p_p_loc;
  TUSubsequence r_0 = p_p_loc;
  std::pair<Rope, mfeanswer_v4>  ret_left = nil(l_0);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = nil_bt_r(r_0);
  std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  hhpp::sadd_bt(const TUSubsequence & p_p_b, const std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e)
{
  TUSubsequence l_0 = p_p_b;
  std::pair<Rope, mfeanswer_v4>  l_1 = p_p_e.first;
  TUSubsequence r_0 = p_p_b;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_1 = p_p_e.second;
  std::pair<Rope, mfeanswer_v4>  ret_left = sadd(l_0, l_1);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = sadd_bt_r(r_0, r_1);
  std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  hhpp::sp_bt(const TUSubsequence & p_p_llb, const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb, const TUSubsequence & p_p_rrb)
{
  TUSubsequence l_0 = p_p_llb;
  TUSubsequence l_1 = p_p_lb;
  std::pair<Rope, mfeanswer_v4>  l_2 = p_p_e.first;
  TUSubsequence l_3 = p_p_rb;
  TUSubsequence l_4 = p_p_rrb;
  TUSubsequence r_0 = p_p_llb;
  TUSubsequence r_1 = p_p_lb;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_2 = p_p_e.second;
  TUSubsequence r_3 = p_p_rb;
  TUSubsequence r_4 = p_p_rrb;
  std::pair<Rope, mfeanswer_v4>  ret_left = sp(l_0, l_1, l_2, l_3, l_4);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = sp_bt_r(r_0, r_1, r_2, r_3, r_4);
  std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  hhpp::sr_bt(const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb)
{
  TUSubsequence l_0 = p_p_lb;
  std::pair<Rope, mfeanswer_v4>  l_1 = p_p_e.first;
  TUSubsequence l_2 = p_p_rb;
  TUSubsequence r_0 = p_p_lb;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_1 = p_p_e.second;
  TUSubsequence r_2 = p_p_rb;
  std::pair<Rope, mfeanswer_v4>  ret_left = sr(l_0, l_1, l_2);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = sr_bt_r(r_0, r_1, r_2);
  std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}


