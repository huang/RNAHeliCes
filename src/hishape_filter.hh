#ifndef HISHAPE_FILTER_HH
#define HISHAPE_FILTER_HH

#include <iostream>
#include <fstream>
#include <map>
#include <list>
#include <vector>
#include <algorithm>
#include <string>
#include <set>
//#include "rtlib/string.hh"
#include "mfe_answer_v4.hh"
//#include "hishape_answer_v4.hh"

//## some additional data structure ##
/*
std::map<Rope,int> dangleMfeMap;
std::map<Rope,int>::iterator dangleMfeMapIt;
std::set<Rope> tabooSubwords; 
std::set<Rope>::iterator tabooSubwordsIt; 
std::set<Rope> potentialTabooSubwords;
std::set<Rope>::iterator potentialTabooSubwordsIt;
 */
 
//std::map<Rope,int> deletedAnswers;
//std::set<Rope> commonSubwordAnswers;  // added
/*
void calculateDangleMfeMap() {
    unsigned int i,j;
    for (i=t_0_left_most; i<=t_0_right_most; i++){
      for (j=i+7; j<=t_0_right_most; j++){
	//?? std::cout << "=============="<<i<<","<<j<<"========================================" << std::endl;
	test_4_hash_h dangle_word = nt_dangle(i,j);
	if (is_not_empty(dangle_word))
	{
	  for (test_4_hash_h::iterator dangle_word_itr = dangle_word.ref().begin(); dangle_word_itr!=dangle_word.ref().end(); ++dangle_word_itr){
	    std::pair<Rope, mfeanswer_v4>  dangle_pair = *dangle_word_itr;
	    //?? std::cout << dangle_pair.first << ":" << dangle_pair.second.energy << ":" << dangle_pair.second.hi_i_j_rope << std::endl;
	    if (dangle_pair.second.energy < dangleMfeMap[dangle_pair.first]){
	      dangleMfeMap[dangle_pair.first] = dangle_pair.second.energy;
	    }
	  }
	}
      }
    }
    //?? std::cout << "==================final result without considering the cadd()====================================" << std::endl;
    // for example, ( ( 8.5,25.5, , -2390 ) , ((((((....)))))).((((((....)))))) ) vs. 8.5,25.5,:-690:8.5%3%14,25.5%20%31,3%14, [0,33]
    //                                          ((((....)))).....((((....)))).. this is generated by ml_comps or ml_comps1
    // show content:
    //?? for ( dangleMfeMapIt=dangleMfeMap.begin() ; dangleMfeMapIt != dangleMfeMap.end(); dangleMfeMapIt++ )
    //??  std::cout << (*dangleMfeMapIt).first << " => " << (*dangleMfeMapIt).second << std::endl;
}
*/
//##############################################################################





// needed for (hishapehV2 * mfeV2) * pretty --backtrack
inline bool operator==(const std::pair<Rope, pfanswer> &a,
                       const std::pair<Rope, pfanswer> &b)
{
  return a.first == b.first;
}

inline bool operator==(const std::pair<Rope, std::pair<mfeanswer, pfanswer> >
    &a, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > &b)
{
  return a.first == b.first && a.second.first == b.second.first;
}






// ## try functions with groups ##
// ###############################
/* a function trying to list all members of a specific hishape */
/*
inline bool operator==(const std::pair<Rope, mfeanswer_v4>
    &a, const std::pair<Rope, mfeanswer_v4> &b)
{
  return a.first == b.first && a.second.energy == b.second.energy;
}*/

// A METHOD for ouput all members of class [27], with -t --kbest --kbacktrace: 
// It doesn't work, since it has only one solution
// needed for (hishapehV2 * mfe) * pretty --backtrack
//inline bool operator==(const std::pair<Rope, mfeanswer_v4> &a,
//                       const std::pair<Rope, mfeanswer_v4> &b)
//{
//  return a.first == b.first && a.second.i1 == b.second.i1 && a.second.j1==b.second.j1;
//}

//inline bool operator==(const std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > &a,
//                       const std::pair<std::pair<Rope, mfeanswer_v4> , intrusive_ptr<Backtrace<String, unsigned int> > > &b)
//{
//  return a.first == b.first && a.second.i1 == b.second.i1 && a.second.j1==b.second.j1;
//}


/*
inline bool operator==(const std::pair<Rope, std::pair<hishapeanswer_4, mfeanswer_4> >
    &a, const std::pair<Rope, std::pair<hishapeanswer_4, mfeanswer_4> > &b)
{
  return a.first == b.first && a.second.first == b.second.first;
}*/

/*
mfeanswer hishapeh_hishapehV2_pp::h_l_l(List_Ref<mfeanswer> i_orig)
{
  List_Ref<mfeanswer> i = mfe_filter(i_orig);
  std::pair<List<mfeanswer>::iterator, List<mfeanswer>::iterator> range = get_range(i);
  return h_l_l(range);
}*/

/*
List_Ref<std::pair<Shape, pfanswer> > out::h(List_Ref<std::pair<Shape, pfanswer> > i_orig)
{
  std::pair<List<std::pair<Shape, pfanswer> >::iterator, List<std::pair<Shape, pfanswer> >::iterator> range = get_range(i_orig);
  List_Ref<std::pair<Shape, pfanswer> > i = h(range);
  return pf_filter(i);
 */



inline
List_Ref<std::pair<Rope, pfanswer> >
pf_filter(List_Ref<std::pair<Rope, pfanswer> > &x)
{
  List<std::pair<Rope, pfanswer> > &l = x.ref();
  List_Ref<std::pair<Rope, pfanswer> > ret;
  List<std::pair<Rope, pfanswer> > &r = ret.ref();
  double sum = 0;
  for (List<std::pair<Rope, pfanswer> >::iterator i = l.begin();
       i != l.end(); ++i)
    sum += (*i).second.pf.q1;
  double thresh = 0.000001 * sum;
  for (List<std::pair<Rope, pfanswer> >::iterator i = l.begin();
       i != l.end(); ++i)
    if ((*i).second.pf.q1 > thresh)
      //push_back_class_syn(ret, *i);
      r.push_back(*i);

  // WTF?!? this way around the adpf_nonamp shape5*pf
  // rna200, tab-all, unger needs
  // 1/2 ram:
  // rss   683304 kb vs.
  // rss  1326996 kb
  
  List_Ref<std::pair<Rope, pfanswer> > foo;
  append_class_syn(foo, ret);
  return foo;
  
  //return ret;
}


// #### FILTER METHOD 1 ####
// avoid use of hashtable: because of filterering #classes is
// relatively small -> constant factor of hashtable is
// significant in this usecase

inline
List_Ref<std::pair<Rope, pfanswer> >
hishape_filter_1(List_Ref<std::pair<Rope, pfanswer> > &x)
{
  List<std::pair<Rope, pfanswer> > &l = x.ref();
  List_Ref<std::pair<Rope, pfanswer> > ret;
  List<std::pair<Rope, pfanswer> > &r = ret.ref();
  double sum = 0;
  for (List<std::pair<Rope, pfanswer> >::iterator i = l.begin();
       i != l.end(); ++i)
    sum += (*i).second.pf.q1;
  double thresh = 0.000001 * sum;
  for (List<std::pair<Rope, pfanswer> >::iterator i = l.begin();
       i != l.end(); ++i)
    if ((*i).second.pf.q1 > thresh)
      //push_back_class_syn(ret, *i);
      r.push_back(*i);

  // WTF?!? this way around the adpf_nonamp shape5*pf
  // rna200, tab-all, unger needs
  // 1/2 ram:
  // rss   683304 kb vs.
  // rss  1326996 kb
  
  List_Ref<std::pair<Rope, pfanswer> > foo;
  append_class_syn(foo, ret);
  return foo;
  
  //return ret;
}


inline
List_Ref<std::pair<Rope, pfanswer> >
hishape_filter_2(List_Ref<std::pair<Rope, pfanswer> > &x)
{
  List<std::pair<Rope, pfanswer> > &l = x.ref();
  List_Ref<std::pair<Rope, pfanswer> > ret;
  List<std::pair<Rope, pfanswer> > &r = ret.ref();
  double sum = 0;
  
  // update
  for (List<std::pair<Rope, pfanswer> >::iterator i = l.begin();
       i != l.end(); ++i)
    sum += (*i).second.pf.q1;
  
  // ok part
  double thresh = 0.000001 * sum;
  for (List<std::pair<Rope, pfanswer> >::iterator i = l.begin();
       i != l.end(); ++i)
    if ((*i).second.pf.q1 > thresh)
      //push_back_class_syn(ret, *i);
      r.push_back(*i);

  // WTF?!? this way around the adpf_nonamp shape5*pf
  // rna200, tab-all, unger needs
  // 1/2 ram:
  // rss   683304 kb vs.
  // rss  1326996 kb
  
  List_Ref<std::pair<Rope, pfanswer> > foo;
  append_class_syn(foo, ret);
  return foo;
  
  //return ret;
}


/*
  template <typename T, typename U = uint32_t>
  struct PfInspector {
    double sum;
    PfInspector() : sum(0) {}
    U hash(const T &x) const
    {
      return hashable_value(x.first);
    }
    void update(T &dst, const T &src)
    {
      if (src.second.first < dst.second.first)
        dst.second.first = src.second.first;
      dst.second.second += src.second.second;
      sum += src.second.second.pf.q1;
    }
    bool equal(const T &a, const T &b) const
    {
      return a.first == b.first;
    }
    bool filter() const { return true; }
    bool filter(const T &x) const
    {
      double thresh = 0.000001 * sum;
      return x.second.second.pf.q1 <= thresh;
    }
  };
*/



// #### FILTER METHOD 2 ####
/*
template <typename T>
struct mfe_filter
{

  static int cutoff_mfe;

  int sum;
  mfe_filter(){}
    : sum(0) {}
  void update(const T &src)
  {
    // std::pair<rope::Ref<rope::Ref_Count>=>first, std::pair<mfeanswer, pfanswer>=>second >
    //sum += src.second.first.energy;
  }
  bool ok(const T &x) const
  {
    int thresh = cutoff_mfe;// * sum;
    return true;
      //x.second.energy     // rope: first.??  if energy of partial loops < 2 kcal/mol, will be processed further 
      //< thresh;
  }
};*/






inline
void tokenize(const std::string& str,
                      std::vector<std::string>& tokens,
                      const std::string& delimiters = ",")
{
    // Skip delimiters at beginning.
    std::string::size_type lastPos = str.find_first_not_of(delimiters, 0);
    // Find first "non-delimiter".
    std::string::size_type pos     = str.find_first_of(delimiters, lastPos);

    while (std::string::npos != pos || std::string::npos != lastPos)
    {
        // Found a token, add it to the vector.
        tokens.push_back(str.substr(lastPos, pos - lastPos));
        // Skip delimiters.  Note the "not_of"
        lastPos = str.find_first_not_of(delimiters, pos);
        // Find next "non-delimiter"
        pos = str.find_first_of(delimiters, lastPos);
    }
}

//http://stackoverflow.com/questions/6906521/how-to-check-whether-a-vector-is-a-subset-of-another-in-c
// if A includes B
template <typename T>
inline
bool is_subset(std::vector<T> A, std::vector<T> B)
{
    std::sort(A.begin(), A.end());
    std::sort(B.begin(), B.end());
    return std::includes(A.begin(), A.end(), B.begin(), B.end());
}


template <typename T>
struct hishape_filter
{  
  std::vector<std::vector<std::string> > hi_i_j_list;  // list is vector of vector
  std::vector<int> energy_list;
  hishape_filter()//: hi_i_j_list(NULL), energy_list(NULL)
  {
  }
  
  void update(const T &src)  // this method can modify sth. of src?
  {          
      ///if (src.second.before_is) {
	  // do nothing
      ///}
      ///else
      ///{
	  // save all records expect for no-empty into a list
	  //////if ( (src.second.hi_rope != "_" || src.second.hi_rope != "") )
	  //////{
	      std::cout << src.second << std::endl; 
	      
	      /*std::vector<std::string> hi_i_j;
	      std::ostringstream stream;
	      stream << src.second.hi_i_j_rope;
	      std::string str = stream.str();
	      tokenize(str, hi_i_j, "|"); 
	      //hishape_energy[hi_i_j_vector] = src.second.energy;
	      hi_i_j_list.push_back(hi_i_j);
	      energy_list.push_back(src.second.energy);*/
	  //////}
      ///}
  }
  bool ok(const T &x) const
  {
      std::cout << "------------------------------" << std::endl; 
      return true;
  }
  
  void finalize(T &src) const
  {
  }
};



/*
inline
List_Ref<std::pair<hishapeanswer_4, mfeanswer_4> >
hishape_filter_4(List_Ref<std::pair<hishapeanswer_4, mfeanswer_4> > &x)
{

  
  List<std::pair<hishapeanswer_4, mfeanswer_4> > &l = x.ref();
  List_Ref<std::pair<hishapeanswer_4, mfeanswer_4> > ret;
  List<std::pair<hishapeanswer_4, mfeanswer_4> > &r = ret.ref();
  
  std::vector<std::vector<std::string> > hi_i_j_list;  // list is vector of vector
  std::vector<int> energy_list;
  
  // update
  for (List<std::pair<hishapeanswer_4, mfeanswer_4> >::iterator i = l.begin();i != l.end(); ++i)
  {
      if ((*i).second.before_is) {
	  // do nothing
      }
      else
      {
	  // save all records expect for no-empty into a list
	  if ( ((*i).second.hi_rope != "_" || (*i).second.hi_rope != "") )
	  {
	      ////std::cout << (*i).second << std::endl; 
	      
	      std::vector<std::string> hi_i_j;
	      std::ostringstream stream;
	      stream << (*i).second.hi_i_j_rope;
	      std::string str = stream.str();
	      tokenize(str, hi_i_j, "|"); 
	      //hishape_energy[hi_i_j_vector] = (*i).second.energy;
	      hi_i_j_list.push_back(hi_i_j);
	      energy_list.push_back((*i).second.energy);
	  }
      }    
  }
    //sum += (*i).second.pf.q1;
  
  
  // ok part
  //double thresh = 0.000001 * sum;
  for (List<std::pair<hishapeanswer_4, mfeanswer_4> >::iterator i = l.begin();i != l.end(); ++i)
  {
      bool return_value = true;
      unsigned int list_size = hi_i_j_list.size();
      if (list_size != 0)
      {
	
	  //////std::cout << "------------------------- list_size=" << list_size << "--------------------------------------" << std::endl;
	  //////for ( unsigned int i=0; i<list_size; i++ )
	  //////{
	  //////    for ( unsigned int j=0; j<hi_i_j_list.at(i).size(); j++ )
	  //////    {
	  //////        std::cout << hi_i_j_list.at(i).at(j) << "%"; 
	  //////    }
	  //////    std::cout << ":" << energy_list.at(i) << std::endl;
	  //////}
          //////std::cout << "---------------------------------------------------------------" << std::endl;

	  //std::map<std::vector<std::string>,int>::iterator it;
	  //bool return_value = true;
	  //for ( it=hishape_energy.begin() ; it != hishape_energy.end(); it++ )
	  for ( unsigned int i=0; i<list_size; i++ )
	  {
	      if ((*i).second.hi_rope == "_" || (*i).second.hi_rope == "")
	      {
		  return_value = true;
		  break;
	      }
	      
	      std::vector<std::string> hi_i_j;
	      std::ostringstream stream;
	      stream << (*i).second.hi_i_j_rope;
	      std::string str = stream.str();
	      tokenize(str, hi_i_j, "|"); 
	      if ( (is_subset(hi_i_j, hi_i_j_list.at(i)) || is_subset(hi_i_j_list.at(i), hi_i_j)) && ((*i).second.energy > energy_list.at(i)) )
	      {
		  //////std::cout << str << ":" << (*i).second.energy << " is subset or superset of (energy > ) ";
		  //////for ( unsigned int j=0; j<hi_i_j_list.at(i).size(); j++ )
		  //////{
		  //////    std::cout << hi_i_j_list.at(i).at(j) << "|"; 
		  //////}
		  //////std::cout << ":" << energy_list.at(i) << std::endl;
	          return_value = false;
		  break;
	      }
          }
          // check record (*i), if the energy of (*i) <= all records, it will be retained
          //return true;
      }
      
      if (return_value)
	  r.push_back(*i);
  }
  //  if ((*i).second.pf.q1 > thresh)
      //push_back_class_syn(ret, *i);
  //    r.push_back(*i);

  // WTF?!? this way around the adpf_nonamp shape5*pf
  // rna200, tab-all, unger needs
  // 1/2 ram:
  // rss   683304 kb vs.
  // rss  1326996 kb
  
  List_Ref<std::pair<hishapeanswer_4, mfeanswer_4> > foo;
  append_class_syn(foo, ret);
  return foo;
  
  //return ret;
}
*/

template <typename T>
struct false_hishrep_filter
{

  static int cutoff_mfe;

  double current_energy;
  false_hishrep_filter()
    : current_energy(0) {}
  void update(const T &src)
  {
    //current_energy += src.second.energy;
    current_energy = cutoff_mfe;
  }
  bool ok(const T &x) const
  {
    double thresh = current_energy;
    return x.second.energy > thresh;
  }
  bool ok(std::pair<Rope, mfeanswer_v4>  &x) const  // hishapeanswer_v4 ==> Rope, mfeanswer_v4 => mfeanswer
  {
    // std::cout << x.first << ":" << x.second.energy << std::endl;
    return true;
  }
};


template <typename T>
struct mfe_2items_filter
{

  static int cutoff_mfe;

  double current_energy;
  mfe_2items_filter()
    : current_energy(0) {}
  void update(const T &src)
  {
    //current_energy += src.second.energy;
    current_energy = cutoff_mfe;
  }
  bool ok(const T &x) const
  {
    double thresh = current_energy;
    return x.second.energy > thresh;
  }
};


template <typename T>
struct mfe_filter
{

  static int cutoff_mfe;

  double current_energy;
  mfe_filter()
    : current_energy(0) {}
  void update(const T &src)
  {
    //current_energy += src.second.energy;
    std::cout << "src.first=" << src.first << ", ";
    std::cout << "src.second=" << src.second << std::endl;
    current_energy = cutoff_mfe;
  }
  bool ok(const T &x) const
  {
    //double thresh = current_energy;
    //return x.second.energy > cutoff_mfe;
    return true;
  }
};


#ifdef GAPC_MOD_TRANSLATION_UNIT

//int mfe_3items_filter<T>::cutoff_mfe = 20;
//int mfe_2items_filter<T>::cutoff_mfe = 2;
template <typename T>
int mfe_filter<T>::cutoff_mfe = -1000;

template <typename T>
int false_hishrep_filter<T>::cutoff_mfe = -1000;

////3 template <typename T>
////3 std::string hishape_filter<T>::reference_hishape_("38.5,49.5,");  //  ("46,")

//append(hishape""),

#endif


#endif
