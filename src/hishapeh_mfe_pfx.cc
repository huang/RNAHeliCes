
// A dynamic programming evaluator generated by GAP-C.
// 
//   GAP-C version:
//     bellmansgapc-2012.05.07
// 
//   GAP-C call:
//     /home/jhuang/gapc/bin/gapc hishapes.gap -i hishapeh_mfe_pfx -o hishapeh_mfe_pfx.cc -t --kbacktrack --kbest --no-coopt-class 
// 
// 


#define GAPC_MOD_TRANSLATION_UNIT
#include "hishapeh_mfe_pfx.hh"

uint32_t hishapeh_mfe_pfx_insp_hash_h_h_pfx::k_ = 3;
#include <rtlib/subopt.hh>
#include "rna.hh"
#include "filter_add.hh"
#include "mfe_answer.hh"

#include <rtlib/generic_opts.hh>

hishapeh_mfe_pfx_hash_h_h_pfx &  hishapeh_mfe_pfx::nt_block_dl(unsigned int t_0_i, unsigned int t_0_j)
{
  if (block_dl_table.is_tabulated(t_0_i, t_0_j))
    {
      return block_dl_table.get(t_0_i, t_0_j);
    }

  hishapeh_mfe_pfx_hash_h_h_pfx answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 9))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 1); (t_0_k_0 <= (t_0_j - 8)); ++t_0_k_0)
      {
        TUSubsequence ret_1 = REGION(t_0_seq, t_0_i, t_0_k_0);
        TUSubsequence a_0 = ret_1;
        if (is_not_empty(a_0))
        {
          hishapeh_mfe_pfx_hash_h_h_pfx ret_2 = nt_edanglel_ml(t_0_k_0, t_0_j);
          hishapeh_mfe_pfx_hash_h_h_pfx a_1 = ret_2;
          if (is_not_empty(a_1))
            {
              for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
                std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_1 = *x_1_itr;
                std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = ssadd(a_0, x_1);
                push_back( answers, ans);
              }
            }

          erase( a_1);
        }

        erase( a_0);
      }

    }


  if (((t_0_j - t_0_i) >= 8))
  {
    hishapeh_mfe_pfx_hash_h_h_pfx ret_4 = nt_edanglel_ml(t_0_i, t_0_j);
    hishapeh_mfe_pfx_hash_h_h_pfx a_2 = ret_4;
    if (is_not_empty(a_2))
      {
        for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
          std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_2 = *x_2_itr;
          std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = incl(x_2);
          push_back( answers, ans);
        }
      }

    erase( a_2);
  }

  hash_filter( answers);
  finalize( answers);
  block_dl_table.set( t_0_i, t_0_j, answers);
  return block_dl_table.get(t_0_i, t_0_j);
}

hishapeh_mfe_pfx_hash_h_h_pfx &  hishapeh_mfe_pfx::nt_block_dlr(unsigned int t_0_i, unsigned int t_0_j)
{
  if (block_dlr_table.is_tabulated(t_0_i, t_0_j))
    {
      return block_dlr_table.get(t_0_i, t_0_j);
    }

  hishapeh_mfe_pfx_hash_h_h_pfx answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 10))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 1); (t_0_k_0 <= (t_0_j - 9)); ++t_0_k_0)
      {
        TUSubsequence ret_1 = REGION(t_0_seq, t_0_i, t_0_k_0);
        TUSubsequence a_0 = ret_1;
        if (is_not_empty(a_0))
        {
          hishapeh_mfe_pfx_hash_h_h_pfx ret_2 = nt_edanglelr_ml(t_0_k_0, t_0_j);
          hishapeh_mfe_pfx_hash_h_h_pfx a_1 = ret_2;
          if (is_not_empty(a_1))
            {
              for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
                std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_1 = *x_1_itr;
                std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = ssadd(a_0, x_1);
                push_back( answers, ans);
              }
            }

          erase( a_1);
        }

        erase( a_0);
      }

    }


  if (((t_0_j - t_0_i) >= 9))
  {
    hishapeh_mfe_pfx_hash_h_h_pfx ret_4 = nt_edanglelr_ml(t_0_i, t_0_j);
    hishapeh_mfe_pfx_hash_h_h_pfx a_2 = ret_4;
    if (is_not_empty(a_2))
      {
        for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
          std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_2 = *x_2_itr;
          std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = incl(x_2);
          push_back( answers, ans);
        }
      }

    erase( a_2);
  }

  hash_filter( answers);
  finalize( answers);
  block_dlr_table.set( t_0_i, t_0_j, answers);
  return block_dlr_table.get(t_0_i, t_0_j);
}

hishapeh_mfe_pfx_hash_h_h_pfx &  hishapeh_mfe_pfx::nt_closed(unsigned int t_0_i, unsigned int t_0_j)
{
  if (closed_table.is_tabulated(t_0_i, t_0_j))
    {
      return closed_table.get(t_0_i, t_0_j);
    }

  hishapeh_mfe_pfx_hash_h_h_pfx answers;
  empty(answers);
  empty( answers);
  hishapeh_mfe_pfx_hash_h_h_pfx ret_0 = nt_stack(t_0_i, t_0_j);
  append( answers, ret_0);
  hishapeh_mfe_pfx_hash_h_h_pfx ret_1 = nt_hairpin(t_0_i, t_0_j);
  append( answers, ret_1);
  hishapeh_mfe_pfx_hash_h_h_pfx ret_2 = nt_multiloop(t_0_i, t_0_j);
  append( answers, ret_2);
  hishapeh_mfe_pfx_hash_h_h_pfx ret_3 = nt_leftB(t_0_i, t_0_j);
  append( answers, ret_3);
  hishapeh_mfe_pfx_hash_h_h_pfx ret_4 = nt_rightB(t_0_i, t_0_j);
  append( answers, ret_4);
  hishapeh_mfe_pfx_hash_h_h_pfx ret_5 = nt_iloop(t_0_i, t_0_j);
  append( answers, ret_5);
  hash_filter( answers);
  finalize( answers);
  closed_table.set( t_0_i, t_0_j, answers);
  return closed_table.get(t_0_i, t_0_j);
}

hishapeh_mfe_pfx_hash_h_h_pfx hishapeh_mfe_pfx::nt_dl_or_ss_left_no_ss_end(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 8))
    {
      return LBRope_firstG_Bmfeanswer_firstG_pfanswer_secondG_E_secondG_EMhdecl0x2ddb270_zero;
    }

  hishapeh_mfe_pfx_hash_h_h_pfx answers;
  empty(answers);
  empty( answers);
  hishapeh_mfe_pfx_hash_h_h_pfx ret_0 = nt_ml_comps1(t_0_i, t_0_j);
  append( answers, ret_0);
  hishapeh_mfe_pfx_hash_h_h_pfx ret_1 = nt_block_dl(t_0_i, t_0_j);
  append( answers, ret_1);
  hash_filter( answers);
  finalize( answers);
  return answers;
}

hishapeh_mfe_pfx_hash_h_h_pfx &  hishapeh_mfe_pfx::nt_dl_or_ss_left_ss_end(unsigned int t_0_i, unsigned int t_0_j)
{
  if (dl_or_ss_left_ss_end_table.is_tabulated(t_0_i, t_0_j))
    {
      return dl_or_ss_left_ss_end_table.get(t_0_i, t_0_j);
    }

  hishapeh_mfe_pfx_hash_h_h_pfx answers;
  empty(answers);
  empty( answers);
  hishapeh_mfe_pfx_hash_h_h_pfx ret_0 = nt_ml_comps4(t_0_i, t_0_j);
  append( answers, ret_0);
  hishapeh_mfe_pfx_hash_h_h_pfx ret_1 = nt_block_dlr(t_0_i, t_0_j);
  append( answers, ret_1);

  if (((t_0_j - t_0_i) >= 10))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 9); (t_0_k_0 <= (t_0_j - 1)); ++t_0_k_0)
      {
        TUSubsequence ret_4 = REGION(t_0_seq, t_0_k_0, t_0_j);
        TUSubsequence a_1 = ret_4;
        if (is_not_empty(a_1))
        {
          hishapeh_mfe_pfx_hash_h_h_pfx ret_3 = nt_block_dlr(t_0_i, t_0_k_0);
          hishapeh_mfe_pfx_hash_h_h_pfx a_0 = ret_3;
          if (is_not_empty(a_0))
            {
              for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_0_itr = a_0.ref().begin(); x_0_itr!=a_0.ref().end(); ++x_0_itr){
                std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_0 = *x_0_itr;
                std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = addss(x_0, a_1);
                push_back( answers, ans);
              }
            }

          erase( a_0);
        }

        erase( a_1);
      }

    }

  hash_filter( answers);
  finalize( answers);
  dl_or_ss_left_ss_end_table.set( t_0_i, t_0_j, answers);
  return dl_or_ss_left_ss_end_table.get(t_0_i, t_0_j);
}

hishapeh_mfe_pfx_hash_h_h_pfx hishapeh_mfe_pfx::nt_edanglel_ml(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 8))
    {
      return LBRope_firstG_Bmfeanswer_firstG_pfanswer_secondG_E_secondG_EMhdecl0x2ddb270_zero;
    }

  hishapeh_mfe_pfx_hash_h_h_pfx answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 8))
  {
    TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
    TUSubsequence a_0 = ret_1;
    if (is_not_empty(a_0))
    {
      hishapeh_mfe_pfx_hash_h_h_pfx ret_2 = nt_initstem((t_0_i + 1), t_0_j);
      hishapeh_mfe_pfx_hash_h_h_pfx a_1 = ret_2;
      if (is_not_empty(a_1))
        {
          for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
            std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_1 = *x_1_itr;
            std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = edl(a_0, x_1);
            push_back( answers, ans);
          }
        }

      erase( a_1);
    }

    erase( a_0);
  }

  hash_filter( answers);
  finalize( answers);
  return answers;
}

hishapeh_mfe_pfx_hash_h_h_pfx hishapeh_mfe_pfx::nt_edanglel_struct(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 8))
    {
      return LBRope_firstG_Bmfeanswer_firstG_pfanswer_secondG_E_secondG_EMhdecl0x2ddb270_zero;
    }

  hishapeh_mfe_pfx_hash_h_h_pfx answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 8))
  {
    TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
    TUSubsequence a_0 = ret_1;
    if (is_not_empty(a_0))
    {
      hishapeh_mfe_pfx_hash_h_h_pfx ret_2 = nt_initstem((t_0_i + 1), t_0_j);
      hishapeh_mfe_pfx_hash_h_h_pfx a_1 = ret_2;
      if (is_not_empty(a_1))
        {
          for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
            std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_1 = *x_1_itr;
            std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = edl(a_0, x_1);
            push_back( answers, ans);
          }
        }

      erase( a_1);
    }

    erase( a_0);
  }

  hash_filter( answers);
  finalize( answers);
  return answers;
}

hishapeh_mfe_pfx_hash_h_h_pfx hishapeh_mfe_pfx::nt_edanglelr_ml(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 9))
    {
      return LBRope_firstG_Bmfeanswer_firstG_pfanswer_secondG_E_secondG_EMhdecl0x2ddb270_zero;
    }

  hishapeh_mfe_pfx_hash_h_h_pfx answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 9))
  {
    TUSubsequence ret_3 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
    TUSubsequence a_2 = ret_3;
    if (is_not_empty(a_2))
    {
      TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
      TUSubsequence a_0 = ret_1;
      if (is_not_empty(a_0))
      {
        hishapeh_mfe_pfx_hash_h_h_pfx ret_2 = nt_initstem((t_0_i + 1), (t_0_j - 1));
        hishapeh_mfe_pfx_hash_h_h_pfx a_1 = ret_2;
        if (is_not_empty(a_1))
          {
            for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
              std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_1 = *x_1_itr;
              std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = edlr(a_0, x_1, a_2);
              push_back( answers, ans);
            }
          }

        erase( a_1);
      }

      erase( a_0);
    }

    erase( a_2);
  }

  hash_filter( answers);
  finalize( answers);
  return answers;
}

hishapeh_mfe_pfx_hash_h_h_pfx hishapeh_mfe_pfx::nt_edanglelr_struct(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 9))
    {
      return LBRope_firstG_Bmfeanswer_firstG_pfanswer_secondG_E_secondG_EMhdecl0x2ddb270_zero;
    }

  hishapeh_mfe_pfx_hash_h_h_pfx answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 9))
  {
    TUSubsequence ret_3 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
    TUSubsequence a_2 = ret_3;
    if (is_not_empty(a_2))
    {
      TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
      TUSubsequence a_0 = ret_1;
      if (is_not_empty(a_0))
      {
        hishapeh_mfe_pfx_hash_h_h_pfx ret_2 = nt_initstem((t_0_i + 1), (t_0_j - 1));
        hishapeh_mfe_pfx_hash_h_h_pfx a_1 = ret_2;
        if (is_not_empty(a_1))
          {
            for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
              std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_1 = *x_1_itr;
              std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = edlr(a_0, x_1, a_2);
              push_back( answers, ans);
            }
          }

        erase( a_1);
      }

      erase( a_0);
    }

    erase( a_2);
  }

  hash_filter( answers);
  finalize( answers);
  return answers;
}

hishapeh_mfe_pfx_hash_h_h_pfx &  hishapeh_mfe_pfx::nt_edangler_ml(unsigned int t_0_i, unsigned int t_0_j)
{
  if (edangler_ml_table.is_tabulated(t_0_i, t_0_j))
    {
      return edangler_ml_table.get(t_0_i, t_0_j);
    }

  hishapeh_mfe_pfx_hash_h_h_pfx answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 8))
  {
    TUSubsequence ret_2 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
    TUSubsequence a_1 = ret_2;
    if (is_not_empty(a_1))
    {
      hishapeh_mfe_pfx_hash_h_h_pfx ret_1 = nt_initstem(t_0_i, (t_0_j - 1));
      hishapeh_mfe_pfx_hash_h_h_pfx a_0 = ret_1;
      if (is_not_empty(a_0))
        {
          for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_0_itr = a_0.ref().begin(); x_0_itr!=a_0.ref().end(); ++x_0_itr){
            std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_0 = *x_0_itr;
            std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = edr(x_0, a_1);
            push_back( answers, ans);
          }
        }

      erase( a_0);
    }

    erase( a_1);
  }

  hash_filter( answers);
  finalize( answers);
  edangler_ml_table.set( t_0_i, t_0_j, answers);
  return edangler_ml_table.get(t_0_i, t_0_j);
}

hishapeh_mfe_pfx_hash_h_h_pfx hishapeh_mfe_pfx::nt_edangler_struct(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 8))
    {
      return LBRope_firstG_Bmfeanswer_firstG_pfanswer_secondG_E_secondG_EMhdecl0x2ddb270_zero;
    }

  hishapeh_mfe_pfx_hash_h_h_pfx answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 8))
  {
    TUSubsequence ret_2 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
    TUSubsequence a_1 = ret_2;
    if (is_not_empty(a_1))
    {
      hishapeh_mfe_pfx_hash_h_h_pfx ret_1 = nt_initstem(t_0_i, (t_0_j - 1));
      hishapeh_mfe_pfx_hash_h_h_pfx a_0 = ret_1;
      if (is_not_empty(a_0))
        {
          for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_0_itr = a_0.ref().begin(); x_0_itr!=a_0.ref().end(); ++x_0_itr){
            std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_0 = *x_0_itr;
            std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = edr(x_0, a_1);
            push_back( answers, ans);
          }
        }

      erase( a_0);
    }

    erase( a_1);
  }

  hash_filter( answers);
  finalize( answers);
  return answers;
}

hishapeh_mfe_pfx_hash_h_h_pfx hishapeh_mfe_pfx::nt_hairpin(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 7))
    {
      return LBRope_firstG_Bmfeanswer_firstG_pfanswer_secondG_E_secondG_EMhdecl0x2ddb270_zero;
    }

  hishapeh_mfe_pfx_hash_h_h_pfx answers;
  empty(answers);
  empty( answers);
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret_0;
  if (((t_0_j - t_0_i) >= 7))
    {
      if (((!_exact) && pairing_center_at(t_0_seq, t_0_i, t_0_j, _match_tokens_h, _theta)) || ((_exact) && exact_pairing_center_at(t_0_seq, t_0_i, t_0_j, _match_tokens_h)))  // added
      {                                                                                                                                                               // added
        TUSubsequence ret_5 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_4 = ret_5;
        if (is_not_empty(a_4))
        {
          TUSubsequence ret_4 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
          TUSubsequence a_3 = ret_4;
          if (is_not_empty(a_3))
          {
            TUSubsequence ret_3;
            if (minsize(t_0_seq, (t_0_i + 2), (t_0_j - 2), 3))
              {
                ret_3 = REGION(t_0_seq, (t_0_i + 2), (t_0_j - 2));
              }

            else
              {
                empty( ret_3);
              }

            TUSubsequence a_2 = ret_3;
            if (is_not_empty(a_2))
            {
              TUSubsequence ret_2 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
              TUSubsequence a_1 = ret_2;
              if (is_not_empty(a_1))
              {
                TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
                TUSubsequence a_0 = ret_1;
                if (is_not_empty(a_0))
                  {
                    ret_0 = hl(a_0, a_1, a_2, a_3, a_4);
                  }

                else
                  {
                    empty( ret_0);
                  }

                erase( a_0);
              }

              else
                {
                  empty( ret_0);
                }

              erase( a_1);
            }

            else
              {
                empty( ret_0);
              }

            erase( a_2);
          }

          else
            {
              empty( ret_0);
            }

          erase( a_3);
        }

        else
          {
            empty( ret_0);
          }

        erase( a_4);
      }

      else
      {
        empty( ret_0);
        empty( ret_0);
      }

    }

  else
    {
      empty( ret_0);
    }

  if (is_not_empty(ret_0))
    {
      push_back( answers, ret_0);
    }

  hash_filter( answers);
  finalize( answers);
  return answers;
}

hishapeh_mfe_pfx_hash_h_h_pfx hishapeh_mfe_pfx::nt_iloop(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 13))
    {
      return LBRope_firstG_Bmfeanswer_firstG_pfanswer_secondG_E_secondG_EMhdecl0x2ddb270_zero;
    }

  hishapeh_mfe_pfx_hash_h_h_pfx answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 13))
    {
      if (stackpairing(t_0_seq, t_0_i, t_0_j))
      {
        TUSubsequence ret_8 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_7 = ret_8;
        if (is_not_empty(a_7))
        {
          TUSubsequence ret_7 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
          TUSubsequence a_6 = ret_7;
          if (is_not_empty(a_6))
          {
            TUSubsequence ret_2 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
            TUSubsequence a_1 = ret_2;
            if (is_not_empty(a_1))
            {
              TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
              TUSubsequence a_0 = ret_1;
              if (is_not_empty(a_0))
              {
                hishapeh_mfe_pfx_hash_h_h_pfx ret_3;
                empty(ret_3);
                if ((((t_0_j - 2) - (t_0_i + 2)) >= 9))
                  {
                    for(                    unsigned int t_0_k_0 = ((t_0_i + 2) + 1); ((t_0_k_0 <= ((t_0_j - 2) - 8)) && (t_0_k_0 <= ((t_0_i + 2) + 30))); ++t_0_k_0)
                    {
                      for(                      unsigned int t_0_k_1 = ((((t_0_j - 2) - (t_0_k_0 + 7)) >= 30)) ? (((t_0_j - 2) - 30)) : ((t_0_k_0 + 7)); (t_0_k_1 <= ((t_0_j - 2) - 1)); ++t_0_k_1)
                      {
                        TUSubsequence ret_6;
                        if (maxsize(t_0_seq, t_0_k_1, (t_0_j - 2), 30))
                          {
                            ret_6 = REGION(t_0_seq, t_0_k_1, (t_0_j - 2));
                          }

                        else
                          {
                            empty( ret_6);
                          }

                        TUSubsequence a_5 = ret_6;
                        if (is_not_empty(a_5))
                        {
                          TUSubsequence ret_4;
                          if (maxsize(t_0_seq, (t_0_i + 2), t_0_k_0, 30))
                            {
                              ret_4 = REGION(t_0_seq, (t_0_i + 2), t_0_k_0);
                            }

                          else
                            {
                              empty( ret_4);
                            }

                          TUSubsequence a_3 = ret_4;
                          if (is_not_empty(a_3))
                          {
                            hishapeh_mfe_pfx_hash_h_h_pfx ret_5 = nt_closed(t_0_k_0, t_0_k_1);
                            hishapeh_mfe_pfx_hash_h_h_pfx a_4 = ret_5;
                            if (is_not_empty(a_4))
                              {
                                for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_4_itr = a_4.ref().begin(); x_4_itr!=a_4.ref().end(); ++x_4_itr){
                                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_4 = *x_4_itr;
                                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = il(a_3, x_4, a_5);
                                  push_back( ret_3, ans);
                                }
                              }

                            erase( a_4);
                          }

                          erase( a_3);
                        }

                        erase( a_5);
                      }

                    }

                  }

                finalize( ret_3);
                hishapeh_mfe_pfx_hash_h_h_pfx a_2 = ret_3;
                if (is_not_empty(a_2))
                  {
                    for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                      std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_2 = *x_2_itr;
                      std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = sp(a_0, a_1, x_2, a_6, a_7);
                      push_back( answers, ans);
                    }
                  }

                erase( a_2);
              }

              erase( a_0);
            }

            erase( a_1);
          }

          erase( a_6);
        }

        erase( a_7);
      }

      else
        {
          empty( answers);
        }

    }

  hash_filter( answers);
  finalize( answers);
  return answers;
}

hishapeh_mfe_pfx_hash_h_h_pfx hishapeh_mfe_pfx::nt_initstem(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 7))
    {
      return LBRope_firstG_Bmfeanswer_firstG_pfanswer_secondG_E_secondG_EMhdecl0x2ddb270_zero;
    }

  hishapeh_mfe_pfx_hash_h_h_pfx answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 7))
  {
    hishapeh_mfe_pfx_hash_h_h_pfx ret_1 = nt_closed(t_0_i, t_0_j);
    hishapeh_mfe_pfx_hash_h_h_pfx a_0 = ret_1;
    if (is_not_empty(a_0))
      {
        for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_0_itr = a_0.ref().begin(); x_0_itr!=a_0.ref().end(); ++x_0_itr){
          std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_0 = *x_0_itr;
          std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = is(x_0);
          push_back( answers, ans);
        }
      }

    erase( a_0);
  }

  hash_filter( answers);
  finalize( answers);
  return answers;
}

hishapeh_mfe_pfx_hash_h_h_pfx hishapeh_mfe_pfx::nt_leftB(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 12))
    {
      return LBRope_firstG_Bmfeanswer_firstG_pfanswer_secondG_E_secondG_EMhdecl0x2ddb270_zero;
    }

  hishapeh_mfe_pfx_hash_h_h_pfx answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 12))
    {
      if (stackpairing(t_0_seq, t_0_i, t_0_j))
      {
        TUSubsequence ret_7 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_6 = ret_7;
        if (is_not_empty(a_6))
        {
          TUSubsequence ret_6 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
          TUSubsequence a_5 = ret_6;
          if (is_not_empty(a_5))
          {
            TUSubsequence ret_2 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
            TUSubsequence a_1 = ret_2;
            if (is_not_empty(a_1))
            {
              TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
              TUSubsequence a_0 = ret_1;
              if (is_not_empty(a_0))
              {
                hishapeh_mfe_pfx_hash_h_h_pfx ret_3;
                empty(ret_3);
                if ((((t_0_j - 2) - (t_0_i + 2)) >= 8))
                  {
                    for(                    unsigned int t_0_k_0 = ((t_0_i + 2) + 1); (t_0_k_0 <= ((t_0_j - 2) - 7)); ++t_0_k_0)
                    {
                      TUSubsequence ret_4 = REGION(t_0_seq, (t_0_i + 2), t_0_k_0);
                      TUSubsequence a_3 = ret_4;
                      if (is_not_empty(a_3))
                      {
                        hishapeh_mfe_pfx_hash_h_h_pfx ret_5 = nt_closed(t_0_k_0, (t_0_j - 2));
                        hishapeh_mfe_pfx_hash_h_h_pfx a_4 = ret_5;
                        if (is_not_empty(a_4))
                          {
                            for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_4_itr = a_4.ref().begin(); x_4_itr!=a_4.ref().end(); ++x_4_itr){
                              std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_4 = *x_4_itr;
                              std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = bl(a_3, x_4);
                              push_back( ret_3, ans);
                            }
                          }

                        erase( a_4);
                      }

                      erase( a_3);
                    }

                  }

                finalize( ret_3);
                hishapeh_mfe_pfx_hash_h_h_pfx a_2 = ret_3;
                if (is_not_empty(a_2))
                  {
                    for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                      std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_2 = *x_2_itr;
                      std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = sp(a_0, a_1, x_2, a_5, a_6);
                      push_back( answers, ans);
                    }
                  }

                erase( a_2);
              }

              erase( a_0);
            }

            erase( a_1);
          }

          erase( a_5);
        }

        erase( a_6);
      }

      else
        {
          empty( answers);
        }

    }

  hash_filter( answers);
  finalize( answers);
  return answers;
}

hishapeh_mfe_pfx_hash_h_h_pfx &  hishapeh_mfe_pfx::nt_left_dangle(unsigned int t_0_i)
{
  if (left_dangle_table.is_tabulated(t_0_i))
    {
      return left_dangle_table.get(t_0_i);
    }

  hishapeh_mfe_pfx_hash_h_h_pfx answers;
  empty(answers);
  empty( answers);

  if (((t_0_right_most - t_0_i) >= 16))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 8); (t_0_k_0 <= (t_0_right_most - 8)); ++t_0_k_0)
      {
        TUSubsequence ret_2 = BASE(t_0_seq, t_0_k_0, (t_0_k_0 + 1));
        TUSubsequence a_1 = ret_2;
        if (is_not_empty(a_1))
        {
          hishapeh_mfe_pfx_hash_h_h_pfx ret_3 = nt_noleft_dangle((t_0_k_0 + 1));
          hishapeh_mfe_pfx_hash_h_h_pfx a_2 = ret_3;
          if (is_not_empty(a_2))
          {
            hishapeh_mfe_pfx_hash_h_h_pfx ret_1 = nt_edanglel_struct(t_0_i, t_0_k_0);
            hishapeh_mfe_pfx_hash_h_h_pfx a_0 = ret_1;
            if (is_not_empty(a_0))
              {
                for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_0_itr = a_0.ref().begin(); x_0_itr!=a_0.ref().end(); ++x_0_itr){
                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_0 = *x_0_itr;
                  for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_2 = *x_2_itr;
                    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = ambd(x_0, a_1, x_2);
                    push_back( answers, ans);
                  }
                }
              }

            erase( a_0);
          }

          erase( a_2);
        }

        erase( a_1);
      }

    }


  if (((t_0_right_most - t_0_i) >= 8))
    {
      for(      unsigned int t_0_k_1 = (t_0_i + 8); (t_0_k_1 <= t_0_right_most); ++t_0_k_1)
      {
        hishapeh_mfe_pfx_hash_h_h_pfx ret_6;
        empty(ret_6);
        empty( ret_6);
        hishapeh_mfe_pfx_hash_h_h_pfx ret_7 = nt_noleft_dangle(t_0_k_1);
        append( ret_6, ret_7);
        std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret_8;
        if ((((t_0_right_most - t_0_k_1) >= 0) && ((t_0_right_most - t_0_k_1) <= 0)))
        {
          TUSubsequence ret_9 = LOC(t_0_seq, t_0_k_1, t_0_k_1);
          TUSubsequence a_5 = ret_9;
          if (is_not_empty(a_5))
            {
              ret_8 = nil_Pr(a_5);
            }

          else
            {
              empty( ret_8);
            }

          erase( a_5);
        }

        else
          {
            empty( ret_8);
          }

        if (is_not_empty(ret_8))
          {
            push_back( ret_6, ret_8);
          }

        finalize( ret_6);
        hishapeh_mfe_pfx_hash_h_h_pfx a_4 = ret_6;
        if (is_not_empty(a_4))
        {
          hishapeh_mfe_pfx_hash_h_h_pfx ret_5 = nt_edanglel_struct(t_0_i, t_0_k_1);
          hishapeh_mfe_pfx_hash_h_h_pfx a_3 = ret_5;
          if (is_not_empty(a_3))
            {
              for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_3_itr = a_3.ref().begin(); x_3_itr!=a_3.ref().end(); ++x_3_itr){
                std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_3 = *x_3_itr;
                for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_4_itr = a_4.ref().begin(); x_4_itr!=a_4.ref().end(); ++x_4_itr){
                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_4 = *x_4_itr;
                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = cadd_Pr(x_3, x_4);
                  push_back( answers, ans);
                }
              }
            }

          erase( a_3);
        }

        erase( a_4);
      }

    }


  if (((t_0_right_most - t_0_i) >= 9))
    {
      for(      unsigned int t_0_k_2 = (t_0_i + 9); (t_0_k_2 <= t_0_right_most); ++t_0_k_2)
      {
        hishapeh_mfe_pfx_hash_h_h_pfx ret_12;
        empty(ret_12);
        empty( ret_12);
        hishapeh_mfe_pfx_hash_h_h_pfx ret_13 = nt_left_dangle(t_0_k_2);
        append( ret_12, ret_13);
        hishapeh_mfe_pfx_hash_h_h_pfx ret_14 = nt_left_unpaired(t_0_k_2);
        append( ret_12, ret_14);
        finalize( ret_12);
        hishapeh_mfe_pfx_hash_h_h_pfx a_7 = ret_12;
        if (is_not_empty(a_7))
        {
          hishapeh_mfe_pfx_hash_h_h_pfx ret_11 = nt_edanglelr_struct(t_0_i, t_0_k_2);
          hishapeh_mfe_pfx_hash_h_h_pfx a_6 = ret_11;
          if (is_not_empty(a_6))
            {
              for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_6_itr = a_6.ref().begin(); x_6_itr!=a_6.ref().end(); ++x_6_itr){
                std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_6 = *x_6_itr;
                for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_7_itr = a_7.ref().begin(); x_7_itr!=a_7.ref().end(); ++x_7_itr){
                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_7 = *x_7_itr;
                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = cadd(x_6, x_7);
                  push_back( answers, ans);
                }
              }
            }

          erase( a_6);
        }

        erase( a_7);
      }

    }

  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret_15;
  if ((((t_0_right_most - t_0_i) >= 0) && ((t_0_right_most - t_0_i) <= 0)))
  {
    TUSubsequence ret_16 = LOC(t_0_seq, t_0_i, t_0_i);
    TUSubsequence a_8 = ret_16;
    if (is_not_empty(a_8))
      {
        ret_15 = nil(a_8);
      }

    else
      {
        empty( ret_15);
      }

    erase( a_8);
  }

  else
    {
      empty( ret_15);
    }

  if (is_not_empty(ret_15))
    {
      push_back( answers, ret_15);
    }

  hash_filter( answers);
  finalize( answers);
  left_dangle_table.set( t_0_i, answers);
  return left_dangle_table.get(t_0_i);
}

hishapeh_mfe_pfx_hash_h_h_pfx &  hishapeh_mfe_pfx::nt_left_unpaired(unsigned int t_0_i)
{
  if (left_unpaired_table.is_tabulated(t_0_i))
    {
      return left_unpaired_table.get(t_0_i);
    }

  hishapeh_mfe_pfx_hash_h_h_pfx answers;
  empty(answers);
  empty( answers);

  if (((t_0_right_most - t_0_i) >= 2))
  {
    TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
    TUSubsequence a_0 = ret_1;
    if (is_not_empty(a_0))
    {
      hishapeh_mfe_pfx_hash_h_h_pfx ret_2 = nt_left_unpaired((t_0_i + 1));
      hishapeh_mfe_pfx_hash_h_h_pfx a_1 = ret_2;
      if (is_not_empty(a_1))
        {
          for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
            std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_1 = *x_1_itr;
            std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = sadd(a_0, x_1);
            push_back( answers, ans);
          }
        }

      erase( a_1);
    }

    erase( a_0);
  }


  if (((t_0_right_most - t_0_i) >= 1))
  {
    TUSubsequence ret_4 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
    TUSubsequence a_2 = ret_4;
    if (is_not_empty(a_2))
    {
      hishapeh_mfe_pfx_hash_h_h_pfx ret_5 = nt_left_dangle((t_0_i + 1));
      hishapeh_mfe_pfx_hash_h_h_pfx a_3 = ret_5;
      if (is_not_empty(a_3))
        {
          for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_3_itr = a_3.ref().begin(); x_3_itr!=a_3.ref().end(); ++x_3_itr){
            std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_3 = *x_3_itr;
            std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = sadd(a_2, x_3);
            push_back( answers, ans);
          }
        }

      erase( a_3);
    }

    erase( a_2);
  }

  hash_filter( answers);
  finalize( answers);
  left_unpaired_table.set( t_0_i, answers);
  return left_unpaired_table.get(t_0_i);
}

hishapeh_mfe_pfx_hash_h_h_pfx &  hishapeh_mfe_pfx::nt_ml_comps1(unsigned int t_0_i, unsigned int t_0_j)
{
  if (ml_comps1_table.is_tabulated(t_0_i, t_0_j))
    {
      return ml_comps1_table.get(t_0_i, t_0_j);
    }

  hishapeh_mfe_pfx_hash_h_h_pfx answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 15))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 8); (t_0_k_0 <= (t_0_j - 7)); ++t_0_k_0)
      {
        hishapeh_mfe_pfx_hash_h_h_pfx ret_2 = nt_no_dl_no_ss_end(t_0_k_0, t_0_j);
        hishapeh_mfe_pfx_hash_h_h_pfx a_1 = ret_2;
        if (is_not_empty(a_1))
        {
          hishapeh_mfe_pfx_hash_h_h_pfx ret_1 = nt_block_dl(t_0_i, t_0_k_0);
          hishapeh_mfe_pfx_hash_h_h_pfx a_0 = ret_1;
          if (is_not_empty(a_0))
            {
              for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_0_itr = a_0.ref().begin(); x_0_itr!=a_0.ref().end(); ++x_0_itr){
                std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_0 = *x_0_itr;
                for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_1 = *x_1_itr;
                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = combine(x_0, x_1);
                  push_back( answers, ans);
                }
              }
            }

          erase( a_0);
        }

        erase( a_1);
      }

    }


  if (((t_0_j - t_0_i) >= 17))
    {
      for(      unsigned int t_0_k_1 = (t_0_i + 9); (t_0_k_1 <= (t_0_j - 8)); ++t_0_k_1)
      {
        hishapeh_mfe_pfx_hash_h_h_pfx ret_5 = nt_dl_or_ss_left_no_ss_end(t_0_k_1, t_0_j);
        hishapeh_mfe_pfx_hash_h_h_pfx a_3 = ret_5;
        if (is_not_empty(a_3))
        {
          hishapeh_mfe_pfx_hash_h_h_pfx ret_4 = nt_block_dlr(t_0_i, t_0_k_1);
          hishapeh_mfe_pfx_hash_h_h_pfx a_2 = ret_4;
          if (is_not_empty(a_2))
            {
              for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_2 = *x_2_itr;
                for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_3_itr = a_3.ref().begin(); x_3_itr!=a_3.ref().end(); ++x_3_itr){
                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_3 = *x_3_itr;
                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = combine(x_2, x_3);
                  push_back( answers, ans);
                }
              }
            }

          erase( a_2);
        }

        erase( a_3);
      }

    }


  if (((t_0_j - t_0_i) >= 16))
    {
      for(      unsigned int t_0_k_2 = (t_0_i + 8); (t_0_k_2 <= (t_0_j - 8)); ++t_0_k_2)
      {
        TUSubsequence ret_8 = BASE(t_0_seq, t_0_k_2, (t_0_k_2 + 1));
        TUSubsequence a_5 = ret_8;
        if (is_not_empty(a_5))
        {
          hishapeh_mfe_pfx_hash_h_h_pfx ret_9 = nt_no_dl_no_ss_end((t_0_k_2 + 1), t_0_j);
          hishapeh_mfe_pfx_hash_h_h_pfx a_6 = ret_9;
          if (is_not_empty(a_6))
          {
            hishapeh_mfe_pfx_hash_h_h_pfx ret_7 = nt_block_dl(t_0_i, t_0_k_2);
            hishapeh_mfe_pfx_hash_h_h_pfx a_4 = ret_7;
            if (is_not_empty(a_4))
              {
                for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_4_itr = a_4.ref().begin(); x_4_itr!=a_4.ref().end(); ++x_4_itr){
                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_4 = *x_4_itr;
                  for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_6_itr = a_6.ref().begin(); x_6_itr!=a_6.ref().end(); ++x_6_itr){
                    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_6 = *x_6_itr;
                    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = acomb(x_4, a_5, x_6);
                    push_back( answers, ans);
                  }
                }
              }

            erase( a_4);
          }

          erase( a_6);
        }

        erase( a_5);
      }

    }

  hash_filter( answers);
  finalize( answers);
  ml_comps1_table.set( t_0_i, t_0_j, answers);
  return ml_comps1_table.get(t_0_i, t_0_j);
}

hishapeh_mfe_pfx_hash_h_h_pfx &  hishapeh_mfe_pfx::nt_ml_comps2(unsigned int t_0_i, unsigned int t_0_j)
{
  if (ml_comps2_table.is_tabulated(t_0_i, t_0_j))
    {
      return ml_comps2_table.get(t_0_i, t_0_j);
    }

  hishapeh_mfe_pfx_hash_h_h_pfx answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 14))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 7); (t_0_k_0 <= (t_0_j - 7)); ++t_0_k_0)
      {
        hishapeh_mfe_pfx_hash_h_h_pfx ret_3 = nt_no_dl_no_ss_end(t_0_k_0, t_0_j);
        hishapeh_mfe_pfx_hash_h_h_pfx a_2 = ret_3;
        if (is_not_empty(a_2))
        {
          hishapeh_mfe_pfx_hash_h_h_pfx ret_1;
          empty(ret_1);
          if (((t_0_k_0 - t_0_i) >= 7))
          {
            hishapeh_mfe_pfx_hash_h_h_pfx ret_2 = nt_nodangle_ml(t_0_i, t_0_k_0);
            hishapeh_mfe_pfx_hash_h_h_pfx a_1 = ret_2;
            if (is_not_empty(a_1))
              {
                for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_1 = *x_1_itr;
                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = incl(x_1);
                  push_back( ret_1, ans);
                }
              }

            erase( a_1);
          }

          finalize( ret_1);
          hishapeh_mfe_pfx_hash_h_h_pfx a_0 = ret_1;
          if (is_not_empty(a_0))
            {
              for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_0_itr = a_0.ref().begin(); x_0_itr!=a_0.ref().end(); ++x_0_itr){
                std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_0 = *x_0_itr;
                for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_2 = *x_2_itr;
                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = combine(x_0, x_2);
                  push_back( answers, ans);
                }
              }
            }

          erase( a_0);
        }

        erase( a_2);
      }

    }


  if (((t_0_j - t_0_i) >= 16))
    {
      for(      unsigned int t_0_k_1 = (t_0_i + 8); (t_0_k_1 <= (t_0_j - 8)); ++t_0_k_1)
      {
        hishapeh_mfe_pfx_hash_h_h_pfx ret_7 = nt_dl_or_ss_left_no_ss_end(t_0_k_1, t_0_j);
        hishapeh_mfe_pfx_hash_h_h_pfx a_5 = ret_7;
        if (is_not_empty(a_5))
        {
          hishapeh_mfe_pfx_hash_h_h_pfx ret_5;
          empty(ret_5);
          if (((t_0_k_1 - t_0_i) >= 8))
          {
            hishapeh_mfe_pfx_hash_h_h_pfx ret_6 = nt_edangler_ml(t_0_i, t_0_k_1);
            hishapeh_mfe_pfx_hash_h_h_pfx a_4 = ret_6;
            if (is_not_empty(a_4))
              {
                for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_4_itr = a_4.ref().begin(); x_4_itr!=a_4.ref().end(); ++x_4_itr){
                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_4 = *x_4_itr;
                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = incl(x_4);
                  push_back( ret_5, ans);
                }
              }

            erase( a_4);
          }

          finalize( ret_5);
          hishapeh_mfe_pfx_hash_h_h_pfx a_3 = ret_5;
          if (is_not_empty(a_3))
            {
              for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_3_itr = a_3.ref().begin(); x_3_itr!=a_3.ref().end(); ++x_3_itr){
                std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_3 = *x_3_itr;
                for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_5_itr = a_5.ref().begin(); x_5_itr!=a_5.ref().end(); ++x_5_itr){
                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_5 = *x_5_itr;
                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = combine(x_3, x_5);
                  push_back( answers, ans);
                }
              }
            }

          erase( a_3);
        }

        erase( a_5);
      }

    }


  if (((t_0_j - t_0_i) >= 15))
    {
      for(      unsigned int t_0_k_2 = (t_0_i + 7); (t_0_k_2 <= (t_0_j - 8)); ++t_0_k_2)
      {
        TUSubsequence ret_11 = BASE(t_0_seq, t_0_k_2, (t_0_k_2 + 1));
        TUSubsequence a_8 = ret_11;
        if (is_not_empty(a_8))
        {
          hishapeh_mfe_pfx_hash_h_h_pfx ret_12 = nt_no_dl_no_ss_end((t_0_k_2 + 1), t_0_j);
          hishapeh_mfe_pfx_hash_h_h_pfx a_9 = ret_12;
          if (is_not_empty(a_9))
          {
            hishapeh_mfe_pfx_hash_h_h_pfx ret_9;
            empty(ret_9);
            if (((t_0_k_2 - t_0_i) >= 7))
            {
              hishapeh_mfe_pfx_hash_h_h_pfx ret_10 = nt_nodangle_ml(t_0_i, t_0_k_2);
              hishapeh_mfe_pfx_hash_h_h_pfx a_7 = ret_10;
              if (is_not_empty(a_7))
                {
                  for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_7_itr = a_7.ref().begin(); x_7_itr!=a_7.ref().end(); ++x_7_itr){
                    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_7 = *x_7_itr;
                    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = incl(x_7);
                    push_back( ret_9, ans);
                  }
                }

              erase( a_7);
            }

            finalize( ret_9);
            hishapeh_mfe_pfx_hash_h_h_pfx a_6 = ret_9;
            if (is_not_empty(a_6))
              {
                for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_6_itr = a_6.ref().begin(); x_6_itr!=a_6.ref().end(); ++x_6_itr){
                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_6 = *x_6_itr;
                  for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_9_itr = a_9.ref().begin(); x_9_itr!=a_9.ref().end(); ++x_9_itr){
                    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_9 = *x_9_itr;
                    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = acomb(x_6, a_8, x_9);
                    push_back( answers, ans);
                  }
                }
              }

            erase( a_6);
          }

          erase( a_9);
        }

        erase( a_8);
      }

    }

  hash_filter( answers);
  finalize( answers);
  ml_comps2_table.set( t_0_i, t_0_j, answers);
  return ml_comps2_table.get(t_0_i, t_0_j);
}

hishapeh_mfe_pfx_hash_h_h_pfx &  hishapeh_mfe_pfx::nt_ml_comps3(unsigned int t_0_i, unsigned int t_0_j)
{
  if (ml_comps3_table.is_tabulated(t_0_i, t_0_j))
    {
      return ml_comps3_table.get(t_0_i, t_0_j);
    }

  hishapeh_mfe_pfx_hash_h_h_pfx answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 17))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 8); (t_0_k_0 <= (t_0_j - 9)); ++t_0_k_0)
      {
        hishapeh_mfe_pfx_hash_h_h_pfx ret_3 = nt_dl_or_ss_left_ss_end(t_0_k_0, t_0_j);
        hishapeh_mfe_pfx_hash_h_h_pfx a_2 = ret_3;
        if (is_not_empty(a_2))
        {
          hishapeh_mfe_pfx_hash_h_h_pfx ret_1;
          empty(ret_1);
          if (((t_0_k_0 - t_0_i) >= 8))
          {
            hishapeh_mfe_pfx_hash_h_h_pfx ret_2 = nt_edangler_ml(t_0_i, t_0_k_0);
            hishapeh_mfe_pfx_hash_h_h_pfx a_1 = ret_2;
            if (is_not_empty(a_1))
              {
                for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_1 = *x_1_itr;
                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = incl(x_1);
                  push_back( ret_1, ans);
                }
              }

            erase( a_1);
          }

          finalize( ret_1);
          hishapeh_mfe_pfx_hash_h_h_pfx a_0 = ret_1;
          if (is_not_empty(a_0))
            {
              for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_0_itr = a_0.ref().begin(); x_0_itr!=a_0.ref().end(); ++x_0_itr){
                std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_0 = *x_0_itr;
                for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_2 = *x_2_itr;
                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = combine(x_0, x_2);
                  push_back( answers, ans);
                }
              }
            }

          erase( a_0);
        }

        erase( a_2);
      }

    }


  if (((t_0_j - t_0_i) >= 15))
    {
      for(      unsigned int t_0_k_1 = (t_0_i + 7); (t_0_k_1 <= (t_0_j - 8)); ++t_0_k_1)
      {
        hishapeh_mfe_pfx_hash_h_h_pfx ret_7 = nt_no_dl_ss_end(t_0_k_1, t_0_j);
        hishapeh_mfe_pfx_hash_h_h_pfx a_5 = ret_7;
        if (is_not_empty(a_5))
        {
          hishapeh_mfe_pfx_hash_h_h_pfx ret_5;
          empty(ret_5);
          if (((t_0_k_1 - t_0_i) >= 7))
          {
            hishapeh_mfe_pfx_hash_h_h_pfx ret_6 = nt_nodangle_ml(t_0_i, t_0_k_1);
            hishapeh_mfe_pfx_hash_h_h_pfx a_4 = ret_6;
            if (is_not_empty(a_4))
              {
                for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_4_itr = a_4.ref().begin(); x_4_itr!=a_4.ref().end(); ++x_4_itr){
                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_4 = *x_4_itr;
                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = incl(x_4);
                  push_back( ret_5, ans);
                }
              }

            erase( a_4);
          }

          finalize( ret_5);
          hishapeh_mfe_pfx_hash_h_h_pfx a_3 = ret_5;
          if (is_not_empty(a_3))
            {
              for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_3_itr = a_3.ref().begin(); x_3_itr!=a_3.ref().end(); ++x_3_itr){
                std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_3 = *x_3_itr;
                for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_5_itr = a_5.ref().begin(); x_5_itr!=a_5.ref().end(); ++x_5_itr){
                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_5 = *x_5_itr;
                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = combine(x_3, x_5);
                  push_back( answers, ans);
                }
              }
            }

          erase( a_3);
        }

        erase( a_5);
      }

    }


  if (((t_0_j - t_0_i) >= 16))
    {
      for(      unsigned int t_0_k_2 = (t_0_i + 7); (t_0_k_2 <= (t_0_j - 9)); ++t_0_k_2)
      {
        TUSubsequence ret_11 = BASE(t_0_seq, t_0_k_2, (t_0_k_2 + 1));
        TUSubsequence a_8 = ret_11;
        if (is_not_empty(a_8))
        {
          hishapeh_mfe_pfx_hash_h_h_pfx ret_12 = nt_no_dl_ss_end((t_0_k_2 + 1), t_0_j);
          hishapeh_mfe_pfx_hash_h_h_pfx a_9 = ret_12;
          if (is_not_empty(a_9))
          {
            hishapeh_mfe_pfx_hash_h_h_pfx ret_9;
            empty(ret_9);
            if (((t_0_k_2 - t_0_i) >= 7))
            {
              hishapeh_mfe_pfx_hash_h_h_pfx ret_10 = nt_nodangle_ml(t_0_i, t_0_k_2);
              hishapeh_mfe_pfx_hash_h_h_pfx a_7 = ret_10;
              if (is_not_empty(a_7))
                {
                  for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_7_itr = a_7.ref().begin(); x_7_itr!=a_7.ref().end(); ++x_7_itr){
                    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_7 = *x_7_itr;
                    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = incl(x_7);
                    push_back( ret_9, ans);
                  }
                }

              erase( a_7);
            }

            finalize( ret_9);
            hishapeh_mfe_pfx_hash_h_h_pfx a_6 = ret_9;
            if (is_not_empty(a_6))
              {
                for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_6_itr = a_6.ref().begin(); x_6_itr!=a_6.ref().end(); ++x_6_itr){
                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_6 = *x_6_itr;
                  for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_9_itr = a_9.ref().begin(); x_9_itr!=a_9.ref().end(); ++x_9_itr){
                    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_9 = *x_9_itr;
                    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = acomb(x_6, a_8, x_9);
                    push_back( answers, ans);
                  }
                }
              }

            erase( a_6);
          }

          erase( a_9);
        }

        erase( a_8);
      }

    }

  hash_filter( answers);
  finalize( answers);
  ml_comps3_table.set( t_0_i, t_0_j, answers);
  return ml_comps3_table.get(t_0_i, t_0_j);
}

hishapeh_mfe_pfx_hash_h_h_pfx &  hishapeh_mfe_pfx::nt_ml_comps4(unsigned int t_0_i, unsigned int t_0_j)
{
  if (ml_comps4_table.is_tabulated(t_0_i, t_0_j))
    {
      return ml_comps4_table.get(t_0_i, t_0_j);
    }

  hishapeh_mfe_pfx_hash_h_h_pfx answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 16))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 8); (t_0_k_0 <= (t_0_j - 8)); ++t_0_k_0)
      {
        hishapeh_mfe_pfx_hash_h_h_pfx ret_2 = nt_no_dl_ss_end(t_0_k_0, t_0_j);
        hishapeh_mfe_pfx_hash_h_h_pfx a_1 = ret_2;
        if (is_not_empty(a_1))
        {
          hishapeh_mfe_pfx_hash_h_h_pfx ret_1 = nt_block_dl(t_0_i, t_0_k_0);
          hishapeh_mfe_pfx_hash_h_h_pfx a_0 = ret_1;
          if (is_not_empty(a_0))
            {
              for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_0_itr = a_0.ref().begin(); x_0_itr!=a_0.ref().end(); ++x_0_itr){
                std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_0 = *x_0_itr;
                for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_1 = *x_1_itr;
                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = combine(x_0, x_1);
                  push_back( answers, ans);
                }
              }
            }

          erase( a_0);
        }

        erase( a_1);
      }

    }


  if (((t_0_j - t_0_i) >= 18))
    {
      for(      unsigned int t_0_k_1 = (t_0_i + 9); (t_0_k_1 <= (t_0_j - 9)); ++t_0_k_1)
      {
        hishapeh_mfe_pfx_hash_h_h_pfx ret_5 = nt_dl_or_ss_left_ss_end(t_0_k_1, t_0_j);
        hishapeh_mfe_pfx_hash_h_h_pfx a_3 = ret_5;
        if (is_not_empty(a_3))
        {
          hishapeh_mfe_pfx_hash_h_h_pfx ret_4 = nt_block_dlr(t_0_i, t_0_k_1);
          hishapeh_mfe_pfx_hash_h_h_pfx a_2 = ret_4;
          if (is_not_empty(a_2))
            {
              for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_2 = *x_2_itr;
                for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_3_itr = a_3.ref().begin(); x_3_itr!=a_3.ref().end(); ++x_3_itr){
                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_3 = *x_3_itr;
                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = combine(x_2, x_3);
                  push_back( answers, ans);
                }
              }
            }

          erase( a_2);
        }

        erase( a_3);
      }

    }


  if (((t_0_j - t_0_i) >= 17))
    {
      for(      unsigned int t_0_k_2 = (t_0_i + 8); (t_0_k_2 <= (t_0_j - 9)); ++t_0_k_2)
      {
        TUSubsequence ret_8 = BASE(t_0_seq, t_0_k_2, (t_0_k_2 + 1));
        TUSubsequence a_5 = ret_8;
        if (is_not_empty(a_5))
        {
          hishapeh_mfe_pfx_hash_h_h_pfx ret_9 = nt_no_dl_ss_end((t_0_k_2 + 1), t_0_j);
          hishapeh_mfe_pfx_hash_h_h_pfx a_6 = ret_9;
          if (is_not_empty(a_6))
          {
            hishapeh_mfe_pfx_hash_h_h_pfx ret_7 = nt_block_dl(t_0_i, t_0_k_2);
            hishapeh_mfe_pfx_hash_h_h_pfx a_4 = ret_7;
            if (is_not_empty(a_4))
              {
                for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_4_itr = a_4.ref().begin(); x_4_itr!=a_4.ref().end(); ++x_4_itr){
                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_4 = *x_4_itr;
                  for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_6_itr = a_6.ref().begin(); x_6_itr!=a_6.ref().end(); ++x_6_itr){
                    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_6 = *x_6_itr;
                    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = acomb(x_4, a_5, x_6);
                    push_back( answers, ans);
                  }
                }
              }

            erase( a_4);
          }

          erase( a_6);
        }

        erase( a_5);
      }

    }

  hash_filter( answers);
  finalize( answers);
  ml_comps4_table.set( t_0_i, t_0_j, answers);
  return ml_comps4_table.get(t_0_i, t_0_j);
}

hishapeh_mfe_pfx_hash_h_h_pfx hishapeh_mfe_pfx::nt_multiloop(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 18))
    {
      return LBRope_firstG_Bmfeanswer_firstG_pfanswer_secondG_E_secondG_EMhdecl0x2ddb270_zero;
    }

  hishapeh_mfe_pfx_hash_h_h_pfx answers;
  empty(answers);
  empty( answers);


  if (stackpairing(t_0_seq, t_0_i, t_0_j))
  {
    hishapeh_mfe_pfx_hash_h_h_pfx ret_1;
    empty(ret_1);
    if (((t_0_j - t_0_i) >= 20))
    {
      TUSubsequence ret_7 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
      TUSubsequence a_5 = ret_7;
      if (is_not_empty(a_5))
      {
        TUSubsequence ret_6 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
        TUSubsequence a_4 = ret_6;
        if (is_not_empty(a_4))
        {
          TUSubsequence ret_4 = BASE(t_0_seq, (t_0_i + 2), ((t_0_i + 2) + 1));
          TUSubsequence a_2 = ret_4;
          if (is_not_empty(a_2))
          {
            TUSubsequence ret_3 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
            TUSubsequence a_1 = ret_3;
            if (is_not_empty(a_1))
            {
              TUSubsequence ret_2 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
              TUSubsequence a_0 = ret_2;
              if (is_not_empty(a_0))
              {
                hishapeh_mfe_pfx_hash_h_h_pfx ret_5 = nt_ml_comps1((t_0_i + 3), (t_0_j - 2));
                hishapeh_mfe_pfx_hash_h_h_pfx a_3 = ret_5;
                if (is_not_empty(a_3))
                  {
                    for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_3_itr = a_3.ref().begin(); x_3_itr!=a_3.ref().end(); ++x_3_itr){
                      std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_3 = *x_3_itr;
                      std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = mldl(a_0, a_1, a_2, x_3, a_4, a_5);
                      push_back( ret_1, ans);
                    }
                  }

                erase( a_3);
              }

              erase( a_0);
            }

            erase( a_1);
          }

          erase( a_2);
        }

        erase( a_4);
      }

      erase( a_5);
    }

    finalize( ret_1);
    append( answers, ret_1);
    hishapeh_mfe_pfx_hash_h_h_pfx ret_8;
    empty(ret_8);
    if (((t_0_j - t_0_i) >= 19))
    {
      TUSubsequence ret_14 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
      TUSubsequence a_11 = ret_14;
      if (is_not_empty(a_11))
      {
        TUSubsequence ret_13 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
        TUSubsequence a_10 = ret_13;
        if (is_not_empty(a_10))
        {
          TUSubsequence ret_11 = BASE(t_0_seq, (t_0_i + 2), ((t_0_i + 2) + 1));
          TUSubsequence a_8 = ret_11;
          if (is_not_empty(a_8))
          {
            TUSubsequence ret_10 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
            TUSubsequence a_7 = ret_10;
            if (is_not_empty(a_7))
            {
              TUSubsequence ret_9 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
              TUSubsequence a_6 = ret_9;
              if (is_not_empty(a_6))
              {
                hishapeh_mfe_pfx_hash_h_h_pfx ret_12 = nt_ml_comps2((t_0_i + 3), (t_0_j - 2));
                hishapeh_mfe_pfx_hash_h_h_pfx a_9 = ret_12;
                if (is_not_empty(a_9))
                  {
                    for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_9_itr = a_9.ref().begin(); x_9_itr!=a_9.ref().end(); ++x_9_itr){
                      std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_9 = *x_9_itr;
                      std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = mladl(a_6, a_7, a_8, x_9, a_10, a_11);
                      push_back( ret_8, ans);
                    }
                  }

                erase( a_9);
              }

              erase( a_6);
            }

            erase( a_7);
          }

          erase( a_8);
        }

        erase( a_10);
      }

      erase( a_11);
    }

    finalize( ret_8);
    append( answers, ret_8);
    hishapeh_mfe_pfx_hash_h_h_pfx ret_15;
    empty(ret_15);
    if (((t_0_j - t_0_i) >= 20))
    {
      TUSubsequence ret_21 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
      TUSubsequence a_17 = ret_21;
      if (is_not_empty(a_17))
      {
        TUSubsequence ret_20 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
        TUSubsequence a_16 = ret_20;
        if (is_not_empty(a_16))
        {
          TUSubsequence ret_19 = BASE(t_0_seq, (t_0_j - 3), (t_0_j - 2));
          TUSubsequence a_15 = ret_19;
          if (is_not_empty(a_15))
          {
            TUSubsequence ret_17 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
            TUSubsequence a_13 = ret_17;
            if (is_not_empty(a_13))
            {
              TUSubsequence ret_16 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
              TUSubsequence a_12 = ret_16;
              if (is_not_empty(a_12))
              {
                hishapeh_mfe_pfx_hash_h_h_pfx ret_18 = nt_ml_comps3((t_0_i + 2), (t_0_j - 3));
                hishapeh_mfe_pfx_hash_h_h_pfx a_14 = ret_18;
                if (is_not_empty(a_14))
                  {
                    for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_14_itr = a_14.ref().begin(); x_14_itr!=a_14.ref().end(); ++x_14_itr){
                      std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_14 = *x_14_itr;
                      std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = mldr(a_12, a_13, x_14, a_15, a_16, a_17);
                      push_back( ret_15, ans);
                    }
                  }

                erase( a_14);
              }

              erase( a_12);
            }

            erase( a_13);
          }

          erase( a_15);
        }

        erase( a_16);
      }

      erase( a_17);
    }

    finalize( ret_15);
    append( answers, ret_15);
    hishapeh_mfe_pfx_hash_h_h_pfx ret_22;
    empty(ret_22);
    if (((t_0_j - t_0_i) >= 19))
    {
      TUSubsequence ret_28 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
      TUSubsequence a_23 = ret_28;
      if (is_not_empty(a_23))
      {
        TUSubsequence ret_27 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
        TUSubsequence a_22 = ret_27;
        if (is_not_empty(a_22))
        {
          TUSubsequence ret_26 = BASE(t_0_seq, (t_0_j - 3), (t_0_j - 2));
          TUSubsequence a_21 = ret_26;
          if (is_not_empty(a_21))
          {
            TUSubsequence ret_24 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
            TUSubsequence a_19 = ret_24;
            if (is_not_empty(a_19))
            {
              TUSubsequence ret_23 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
              TUSubsequence a_18 = ret_23;
              if (is_not_empty(a_18))
              {
                hishapeh_mfe_pfx_hash_h_h_pfx ret_25 = nt_ml_comps2((t_0_i + 2), (t_0_j - 3));
                hishapeh_mfe_pfx_hash_h_h_pfx a_20 = ret_25;
                if (is_not_empty(a_20))
                  {
                    for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_20_itr = a_20.ref().begin(); x_20_itr!=a_20.ref().end(); ++x_20_itr){
                      std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_20 = *x_20_itr;
                      std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = mladr(a_18, a_19, x_20, a_21, a_22, a_23);
                      push_back( ret_22, ans);
                    }
                  }

                erase( a_20);
              }

              erase( a_18);
            }

            erase( a_19);
          }

          erase( a_21);
        }

        erase( a_22);
      }

      erase( a_23);
    }

    finalize( ret_22);
    append( answers, ret_22);
    hishapeh_mfe_pfx_hash_h_h_pfx ret_29;
    empty(ret_29);
    if (((t_0_j - t_0_i) >= 22))
    {
      TUSubsequence ret_36 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
      TUSubsequence a_30 = ret_36;
      if (is_not_empty(a_30))
      {
        TUSubsequence ret_35 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
        TUSubsequence a_29 = ret_35;
        if (is_not_empty(a_29))
        {
          TUSubsequence ret_34 = BASE(t_0_seq, (t_0_j - 3), (t_0_j - 2));
          TUSubsequence a_28 = ret_34;
          if (is_not_empty(a_28))
          {
            TUSubsequence ret_32 = BASE(t_0_seq, (t_0_i + 2), ((t_0_i + 2) + 1));
            TUSubsequence a_26 = ret_32;
            if (is_not_empty(a_26))
            {
              TUSubsequence ret_31 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
              TUSubsequence a_25 = ret_31;
              if (is_not_empty(a_25))
              {
                TUSubsequence ret_30 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
                TUSubsequence a_24 = ret_30;
                if (is_not_empty(a_24))
                {
                  hishapeh_mfe_pfx_hash_h_h_pfx ret_33 = nt_ml_comps4((t_0_i + 3), (t_0_j - 3));
                  hishapeh_mfe_pfx_hash_h_h_pfx a_27 = ret_33;
                  if (is_not_empty(a_27))
                    {
                      for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_27_itr = a_27.ref().begin(); x_27_itr!=a_27.ref().end(); ++x_27_itr){
                        std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_27 = *x_27_itr;
                        std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = mldlr(a_24, a_25, a_26, x_27, a_28, a_29, a_30);
                        push_back( ret_29, ans);
                      }
                    }

                  erase( a_27);
                }

                erase( a_24);
              }

              erase( a_25);
            }

            erase( a_26);
          }

          erase( a_28);
        }

        erase( a_29);
      }

      erase( a_30);
    }

    finalize( ret_29);
    append( answers, ret_29);
    hishapeh_mfe_pfx_hash_h_h_pfx ret_37;
    empty(ret_37);
    if (((t_0_j - t_0_i) >= 20))
    {
      TUSubsequence ret_44 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
      TUSubsequence a_37 = ret_44;
      if (is_not_empty(a_37))
      {
        TUSubsequence ret_43 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
        TUSubsequence a_36 = ret_43;
        if (is_not_empty(a_36))
        {
          TUSubsequence ret_42 = BASE(t_0_seq, (t_0_j - 3), (t_0_j - 2));
          TUSubsequence a_35 = ret_42;
          if (is_not_empty(a_35))
          {
            TUSubsequence ret_40 = BASE(t_0_seq, (t_0_i + 2), ((t_0_i + 2) + 1));
            TUSubsequence a_33 = ret_40;
            if (is_not_empty(a_33))
            {
              TUSubsequence ret_39 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
              TUSubsequence a_32 = ret_39;
              if (is_not_empty(a_32))
              {
                TUSubsequence ret_38 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
                TUSubsequence a_31 = ret_38;
                if (is_not_empty(a_31))
                {
                  hishapeh_mfe_pfx_hash_h_h_pfx ret_41 = nt_ml_comps2((t_0_i + 3), (t_0_j - 3));
                  hishapeh_mfe_pfx_hash_h_h_pfx a_34 = ret_41;
                  if (is_not_empty(a_34))
                    {
                      for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_34_itr = a_34.ref().begin(); x_34_itr!=a_34.ref().end(); ++x_34_itr){
                        std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_34 = *x_34_itr;
                        std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = mladlr(a_31, a_32, a_33, x_34, a_35, a_36, a_37);
                        push_back( ret_37, ans);
                      }
                    }

                  erase( a_34);
                }

                erase( a_31);
              }

              erase( a_32);
            }

            erase( a_33);
          }

          erase( a_35);
        }

        erase( a_36);
      }

      erase( a_37);
    }

    finalize( ret_37);
    append( answers, ret_37);
    hishapeh_mfe_pfx_hash_h_h_pfx ret_45;
    empty(ret_45);
    if (((t_0_j - t_0_i) >= 21))
    {
      TUSubsequence ret_52 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
      TUSubsequence a_44 = ret_52;
      if (is_not_empty(a_44))
      {
        TUSubsequence ret_51 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
        TUSubsequence a_43 = ret_51;
        if (is_not_empty(a_43))
        {
          TUSubsequence ret_50 = BASE(t_0_seq, (t_0_j - 3), (t_0_j - 2));
          TUSubsequence a_42 = ret_50;
          if (is_not_empty(a_42))
          {
            TUSubsequence ret_48 = BASE(t_0_seq, (t_0_i + 2), ((t_0_i + 2) + 1));
            TUSubsequence a_40 = ret_48;
            if (is_not_empty(a_40))
            {
              TUSubsequence ret_47 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
              TUSubsequence a_39 = ret_47;
              if (is_not_empty(a_39))
              {
                TUSubsequence ret_46 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
                TUSubsequence a_38 = ret_46;
                if (is_not_empty(a_38))
                {
                  hishapeh_mfe_pfx_hash_h_h_pfx ret_49 = nt_ml_comps1((t_0_i + 3), (t_0_j - 3));
                  hishapeh_mfe_pfx_hash_h_h_pfx a_41 = ret_49;
                  if (is_not_empty(a_41))
                    {
                      for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_41_itr = a_41.ref().begin(); x_41_itr!=a_41.ref().end(); ++x_41_itr){
                        std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_41 = *x_41_itr;
                        std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = mldladr(a_38, a_39, a_40, x_41, a_42, a_43, a_44);
                        push_back( ret_45, ans);
                      }
                    }

                  erase( a_41);
                }

                erase( a_38);
              }

              erase( a_39);
            }

            erase( a_40);
          }

          erase( a_42);
        }

        erase( a_43);
      }

      erase( a_44);
    }

    finalize( ret_45);
    append( answers, ret_45);
    hishapeh_mfe_pfx_hash_h_h_pfx ret_53;
    empty(ret_53);
    if (((t_0_j - t_0_i) >= 21))
    {
      TUSubsequence ret_60 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
      TUSubsequence a_51 = ret_60;
      if (is_not_empty(a_51))
      {
        TUSubsequence ret_59 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
        TUSubsequence a_50 = ret_59;
        if (is_not_empty(a_50))
        {
          TUSubsequence ret_58 = BASE(t_0_seq, (t_0_j - 3), (t_0_j - 2));
          TUSubsequence a_49 = ret_58;
          if (is_not_empty(a_49))
          {
            TUSubsequence ret_56 = BASE(t_0_seq, (t_0_i + 2), ((t_0_i + 2) + 1));
            TUSubsequence a_47 = ret_56;
            if (is_not_empty(a_47))
            {
              TUSubsequence ret_55 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
              TUSubsequence a_46 = ret_55;
              if (is_not_empty(a_46))
              {
                TUSubsequence ret_54 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
                TUSubsequence a_45 = ret_54;
                if (is_not_empty(a_45))
                {
                  hishapeh_mfe_pfx_hash_h_h_pfx ret_57 = nt_ml_comps3((t_0_i + 3), (t_0_j - 3));
                  hishapeh_mfe_pfx_hash_h_h_pfx a_48 = ret_57;
                  if (is_not_empty(a_48))
                    {
                      for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_48_itr = a_48.ref().begin(); x_48_itr!=a_48.ref().end(); ++x_48_itr){
                        std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_48 = *x_48_itr;
                        std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = mladldr(a_45, a_46, a_47, x_48, a_49, a_50, a_51);
                        push_back( ret_53, ans);
                      }
                    }

                  erase( a_48);
                }

                erase( a_45);
              }

              erase( a_46);
            }

            erase( a_47);
          }

          erase( a_49);
        }

        erase( a_50);
      }

      erase( a_51);
    }

    finalize( ret_53);
    append( answers, ret_53);
    hishapeh_mfe_pfx_hash_h_h_pfx ret_61;
    empty(ret_61);
    if (((t_0_j - t_0_i) >= 18))
    {
      TUSubsequence ret_66 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
      TUSubsequence a_56 = ret_66;
      if (is_not_empty(a_56))
      {
        TUSubsequence ret_65 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
        TUSubsequence a_55 = ret_65;
        if (is_not_empty(a_55))
        {
          TUSubsequence ret_63 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
          TUSubsequence a_53 = ret_63;
          if (is_not_empty(a_53))
          {
            TUSubsequence ret_62 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
            TUSubsequence a_52 = ret_62;
            if (is_not_empty(a_52))
            {
              hishapeh_mfe_pfx_hash_h_h_pfx ret_64 = nt_ml_comps2((t_0_i + 2), (t_0_j - 2));
              hishapeh_mfe_pfx_hash_h_h_pfx a_54 = ret_64;
              if (is_not_empty(a_54))
                {
                  for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_54_itr = a_54.ref().begin(); x_54_itr!=a_54.ref().end(); ++x_54_itr){
                    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_54 = *x_54_itr;
                    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = ml(a_52, a_53, x_54, a_55, a_56);
                    push_back( ret_61, ans);
                  }
                }

              erase( a_54);
            }

            erase( a_52);
          }

          erase( a_53);
        }

        erase( a_55);
      }

      erase( a_56);
    }

    finalize( ret_61);
    append( answers, ret_61);
  }

  hash_filter( answers);
  finalize( answers);
  return answers;
}

hishapeh_mfe_pfx_hash_h_h_pfx &  hishapeh_mfe_pfx::nt_no_dl_no_ss_end(unsigned int t_0_i, unsigned int t_0_j)
{
  if (no_dl_no_ss_end_table.is_tabulated(t_0_i, t_0_j))
    {
      return no_dl_no_ss_end_table.get(t_0_i, t_0_j);
    }

  hishapeh_mfe_pfx_hash_h_h_pfx answers;
  empty(answers);
  empty( answers);
  hishapeh_mfe_pfx_hash_h_h_pfx ret_0 = nt_ml_comps2(t_0_i, t_0_j);
  append( answers, ret_0);

  if (((t_0_j - t_0_i) >= 7))
  {
    hishapeh_mfe_pfx_hash_h_h_pfx ret_2 = nt_nodangle_ml(t_0_i, t_0_j);
    hishapeh_mfe_pfx_hash_h_h_pfx a_0 = ret_2;
    if (is_not_empty(a_0))
      {
        for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_0_itr = a_0.ref().begin(); x_0_itr!=a_0.ref().end(); ++x_0_itr){
          std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_0 = *x_0_itr;
          std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = incl(x_0);
          push_back( answers, ans);
        }
      }

    erase( a_0);
  }

  hash_filter( answers);
  finalize( answers);
  no_dl_no_ss_end_table.set( t_0_i, t_0_j, answers);
  return no_dl_no_ss_end_table.get(t_0_i, t_0_j);
}

hishapeh_mfe_pfx_hash_h_h_pfx &  hishapeh_mfe_pfx::nt_no_dl_ss_end(unsigned int t_0_i, unsigned int t_0_j)
{
  if (no_dl_ss_end_table.is_tabulated(t_0_i, t_0_j))
    {
      return no_dl_ss_end_table.get(t_0_i, t_0_j);
    }

  hishapeh_mfe_pfx_hash_h_h_pfx answers;
  empty(answers);
  empty( answers);
  hishapeh_mfe_pfx_hash_h_h_pfx ret_0 = nt_ml_comps3(t_0_i, t_0_j);
  append( answers, ret_0);

  if (((t_0_j - t_0_i) >= 8))
  {
    hishapeh_mfe_pfx_hash_h_h_pfx ret_2 = nt_edangler_ml(t_0_i, t_0_j);
    hishapeh_mfe_pfx_hash_h_h_pfx a_0 = ret_2;
    if (is_not_empty(a_0))
      {
        for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_0_itr = a_0.ref().begin(); x_0_itr!=a_0.ref().end(); ++x_0_itr){
          std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_0 = *x_0_itr;
          std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = incl(x_0);
          push_back( answers, ans);
        }
      }

    erase( a_0);
  }


  if (((t_0_j - t_0_i) >= 9))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 8); (t_0_k_0 <= (t_0_j - 1)); ++t_0_k_0)
      {
        TUSubsequence ret_6 = REGION(t_0_seq, t_0_k_0, t_0_j);
        TUSubsequence a_3 = ret_6;
        if (is_not_empty(a_3))
        {
          hishapeh_mfe_pfx_hash_h_h_pfx ret_4;
          empty(ret_4);
          if (((t_0_k_0 - t_0_i) >= 8))
          {
            hishapeh_mfe_pfx_hash_h_h_pfx ret_5 = nt_edangler_ml(t_0_i, t_0_k_0);
            hishapeh_mfe_pfx_hash_h_h_pfx a_2 = ret_5;
            if (is_not_empty(a_2))
              {
                for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_2 = *x_2_itr;
                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = incl(x_2);
                  push_back( ret_4, ans);
                }
              }

            erase( a_2);
          }

          finalize( ret_4);
          hishapeh_mfe_pfx_hash_h_h_pfx a_1 = ret_4;
          if (is_not_empty(a_1))
            {
              for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
                std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_1 = *x_1_itr;
                std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = addss(x_1, a_3);
                push_back( answers, ans);
              }
            }

          erase( a_1);
        }

        erase( a_3);
      }

    }

  hash_filter( answers);
  finalize( answers);
  no_dl_ss_end_table.set( t_0_i, t_0_j, answers);
  return no_dl_ss_end_table.get(t_0_i, t_0_j);
}

hishapeh_mfe_pfx_hash_h_h_pfx &  hishapeh_mfe_pfx::nt_nodangle_ml(unsigned int t_0_i, unsigned int t_0_j)
{
  if (nodangle_ml_table.is_tabulated(t_0_i, t_0_j))
    {
      return nodangle_ml_table.get(t_0_i, t_0_j);
    }

  hishapeh_mfe_pfx_hash_h_h_pfx answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 7))
  {
    hishapeh_mfe_pfx_hash_h_h_pfx ret_1 = nt_initstem(t_0_i, t_0_j);
    hishapeh_mfe_pfx_hash_h_h_pfx a_0 = ret_1;
    if (is_not_empty(a_0))
      {
        for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_0_itr = a_0.ref().begin(); x_0_itr!=a_0.ref().end(); ++x_0_itr){
          std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_0 = *x_0_itr;
          std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = drem(x_0);
          push_back( answers, ans);
        }
      }

    erase( a_0);
  }

  hash_filter( answers);
  finalize( answers);
  nodangle_ml_table.set( t_0_i, t_0_j, answers);
  return nodangle_ml_table.get(t_0_i, t_0_j);
}

hishapeh_mfe_pfx_hash_h_h_pfx hishapeh_mfe_pfx::nt_nodangle_struct(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 7))
    {
      return LBRope_firstG_Bmfeanswer_firstG_pfanswer_secondG_E_secondG_EMhdecl0x2ddb270_zero;
    }

  hishapeh_mfe_pfx_hash_h_h_pfx answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 7))
  {
    hishapeh_mfe_pfx_hash_h_h_pfx ret_1 = nt_initstem(t_0_i, t_0_j);
    hishapeh_mfe_pfx_hash_h_h_pfx a_0 = ret_1;
    if (is_not_empty(a_0))
      {
        for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_0_itr = a_0.ref().begin(); x_0_itr!=a_0.ref().end(); ++x_0_itr){
          std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_0 = *x_0_itr;
          std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = drem(x_0);
          push_back( answers, ans);
        }
      }

    erase( a_0);
  }

  hash_filter( answers);
  finalize( answers);
  return answers;
}

hishapeh_mfe_pfx_hash_h_h_pfx &  hishapeh_mfe_pfx::nt_noleft_dangle(unsigned int t_0_i)
{
  if (noleft_dangle_table.is_tabulated(t_0_i))
    {
      return noleft_dangle_table.get(t_0_i);
    }

  hishapeh_mfe_pfx_hash_h_h_pfx answers;
  empty(answers);
  empty( answers);

  if (((t_0_right_most - t_0_i) >= 8))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 8); (t_0_k_0 <= t_0_right_most); ++t_0_k_0)
      {
        hishapeh_mfe_pfx_hash_h_h_pfx ret_2;
        empty(ret_2);
        empty( ret_2);
        hishapeh_mfe_pfx_hash_h_h_pfx ret_3 = nt_left_dangle(t_0_k_0);
        append( ret_2, ret_3);
        hishapeh_mfe_pfx_hash_h_h_pfx ret_4 = nt_left_unpaired(t_0_k_0);
        append( ret_2, ret_4);
        finalize( ret_2);
        hishapeh_mfe_pfx_hash_h_h_pfx a_1 = ret_2;
        if (is_not_empty(a_1))
        {
          hishapeh_mfe_pfx_hash_h_h_pfx ret_1 = nt_edangler_struct(t_0_i, t_0_k_0);
          hishapeh_mfe_pfx_hash_h_h_pfx a_0 = ret_1;
          if (is_not_empty(a_0))
            {
              for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_0_itr = a_0.ref().begin(); x_0_itr!=a_0.ref().end(); ++x_0_itr){
                std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_0 = *x_0_itr;
                for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_1 = *x_1_itr;
                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = cadd_Pr_Pr(x_0, x_1);
                  push_back( answers, ans);
                }
              }
            }

          erase( a_0);
        }

        erase( a_1);
      }

    }


  if (((t_0_right_most - t_0_i) >= 7))
    {
      for(      unsigned int t_0_k_1 = (t_0_i + 7); (t_0_k_1 <= t_0_right_most); ++t_0_k_1)
      {
        hishapeh_mfe_pfx_hash_h_h_pfx ret_7;
        empty(ret_7);
        empty( ret_7);
        hishapeh_mfe_pfx_hash_h_h_pfx ret_8 = nt_noleft_dangle(t_0_k_1);
        append( ret_7, ret_8);
        std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret_9;
        if ((((t_0_right_most - t_0_k_1) >= 0) && ((t_0_right_most - t_0_k_1) <= 0)))
        {
          TUSubsequence ret_10 = LOC(t_0_seq, t_0_k_1, t_0_k_1);
          TUSubsequence a_4 = ret_10;
          if (is_not_empty(a_4))
            {
              ret_9 = nil_Pr(a_4);
            }

          else
            {
              empty( ret_9);
            }

          erase( a_4);
        }

        else
          {
            empty( ret_9);
          }

        if (is_not_empty(ret_9))
          {
            push_back( ret_7, ret_9);
          }

        finalize( ret_7);
        hishapeh_mfe_pfx_hash_h_h_pfx a_3 = ret_7;
        if (is_not_empty(a_3))
        {
          hishapeh_mfe_pfx_hash_h_h_pfx ret_6 = nt_nodangle_struct(t_0_i, t_0_k_1);
          hishapeh_mfe_pfx_hash_h_h_pfx a_2 = ret_6;
          if (is_not_empty(a_2))
            {
              for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_2 = *x_2_itr;
                for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_3_itr = a_3.ref().begin(); x_3_itr!=a_3.ref().end(); ++x_3_itr){
                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_3 = *x_3_itr;
                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = cadd_Pr_Pr_Pr(x_2, x_3);
                  push_back( answers, ans);
                }
              }
            }

          erase( a_2);
        }

        erase( a_3);
      }

    }


  if (((t_0_right_most - t_0_i) >= 15))
    {
      for(      unsigned int t_0_k_2 = (t_0_i + 7); (t_0_k_2 <= (t_0_right_most - 8)); ++t_0_k_2)
      {
        TUSubsequence ret_13 = BASE(t_0_seq, t_0_k_2, (t_0_k_2 + 1));
        TUSubsequence a_6 = ret_13;
        if (is_not_empty(a_6))
        {
          hishapeh_mfe_pfx_hash_h_h_pfx ret_14 = nt_noleft_dangle((t_0_k_2 + 1));
          hishapeh_mfe_pfx_hash_h_h_pfx a_7 = ret_14;
          if (is_not_empty(a_7))
          {
            hishapeh_mfe_pfx_hash_h_h_pfx ret_12 = nt_nodangle_struct(t_0_i, t_0_k_2);
            hishapeh_mfe_pfx_hash_h_h_pfx a_5 = ret_12;
            if (is_not_empty(a_5))
              {
                for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_5_itr = a_5.ref().begin(); x_5_itr!=a_5.ref().end(); ++x_5_itr){
                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_5 = *x_5_itr;
                  for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_7_itr = a_7.ref().begin(); x_7_itr!=a_7.ref().end(); ++x_7_itr){
                    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_7 = *x_7_itr;
                    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = ambd_Pr(x_5, a_6, x_7);
                    push_back( answers, ans);
                  }
                }
              }

            erase( a_5);
          }

          erase( a_7);
        }

        erase( a_6);
      }

    }

  hash_filter( answers);
  finalize( answers);
  noleft_dangle_table.set( t_0_i, answers);
  return noleft_dangle_table.get(t_0_i);
}

hishapeh_mfe_pfx_hash_h_h_pfx hishapeh_mfe_pfx::nt_rightB(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 12))
    {
      return LBRope_firstG_Bmfeanswer_firstG_pfanswer_secondG_E_secondG_EMhdecl0x2ddb270_zero;
    }

  hishapeh_mfe_pfx_hash_h_h_pfx answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 12))
    {
      if (stackpairing(t_0_seq, t_0_i, t_0_j))
      {
        TUSubsequence ret_7 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_6 = ret_7;
        if (is_not_empty(a_6))
        {
          TUSubsequence ret_6 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
          TUSubsequence a_5 = ret_6;
          if (is_not_empty(a_5))
          {
            TUSubsequence ret_2 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
            TUSubsequence a_1 = ret_2;
            if (is_not_empty(a_1))
            {
              TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
              TUSubsequence a_0 = ret_1;
              if (is_not_empty(a_0))
              {
                hishapeh_mfe_pfx_hash_h_h_pfx ret_3;
                empty(ret_3);
                if ((((t_0_j - 2) - (t_0_i + 2)) >= 8))
                  {
                    for(                    unsigned int t_0_k_0 = ((t_0_i + 2) + 7); (t_0_k_0 <= ((t_0_j - 2) - 1)); ++t_0_k_0)
                    {
                      TUSubsequence ret_5 = REGION(t_0_seq, t_0_k_0, (t_0_j - 2));
                      TUSubsequence a_4 = ret_5;
                      if (is_not_empty(a_4))
                      {
                        hishapeh_mfe_pfx_hash_h_h_pfx ret_4 = nt_closed((t_0_i + 2), t_0_k_0);
                        hishapeh_mfe_pfx_hash_h_h_pfx a_3 = ret_4;
                        if (is_not_empty(a_3))
                          {
                            for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_3_itr = a_3.ref().begin(); x_3_itr!=a_3.ref().end(); ++x_3_itr){
                              std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_3 = *x_3_itr;
                              std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = br(x_3, a_4);
                              push_back( ret_3, ans);
                            }
                          }

                        erase( a_3);
                      }

                      erase( a_4);
                    }

                  }

                finalize( ret_3);
                hishapeh_mfe_pfx_hash_h_h_pfx a_2 = ret_3;
                if (is_not_empty(a_2))
                  {
                    for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                      std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_2 = *x_2_itr;
                      std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = sp(a_0, a_1, x_2, a_5, a_6);
                      push_back( answers, ans);
                    }
                  }

                erase( a_2);
              }

              erase( a_0);
            }

            erase( a_1);
          }

          erase( a_5);
        }

        erase( a_6);
      }

      else
        {
          empty( answers);
        }

    }

  hash_filter( answers);
  finalize( answers);
  return answers;
}

hishapeh_mfe_pfx_hash_h_h_pfx hishapeh_mfe_pfx::nt_stack(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 9))
    {
      return LBRope_firstG_Bmfeanswer_firstG_pfanswer_secondG_E_secondG_EMhdecl0x2ddb270_zero;
    }

  hishapeh_mfe_pfx_hash_h_h_pfx answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 9))
    {
      if (basepairing(t_0_seq, t_0_i, t_0_j))
      {
        TUSubsequence ret_3 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_2 = ret_3;
        if (is_not_empty(a_2))
        {
          TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
          TUSubsequence a_0 = ret_1;
          if (is_not_empty(a_0))
          {
            hishapeh_mfe_pfx_hash_h_h_pfx ret_2 = nt_closed((t_0_i + 1), (t_0_j - 1));
            hishapeh_mfe_pfx_hash_h_h_pfx a_1 = ret_2;
            if (is_not_empty(a_1))
              {
                for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_1 = *x_1_itr;
                  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = sr(a_0, x_1, a_2);
                  push_back( answers, ans);
                }
              }

            erase( a_1);
          }

          erase( a_0);
        }

        erase( a_2);
      }

      else
        {
          empty( answers);
        }

    }

  hash_filter( answers);
  finalize( answers);
  return answers;
}

hishapeh_mfe_pfx_hash_h_h_pfx hishapeh_mfe_pfx::nt_struct()
{
  hishapeh_mfe_pfx_hash_h_h_pfx answers;
  empty(answers);
  empty( answers);
  hishapeh_mfe_pfx_hash_h_h_pfx ret_0 = nt_left_dangle(t_0_left_most);
  append( answers, ret_0);

  if (((t_0_right_most - t_0_left_most) >= 7))
  {
    hishapeh_mfe_pfx_hash_h_h_pfx ret_2 = nt_noleft_dangle(t_0_left_most);
    hishapeh_mfe_pfx_hash_h_h_pfx a_0 = ret_2;
    if (is_not_empty(a_0))
      {
        for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator x_0_itr = a_0.ref().begin(); x_0_itr!=a_0.ref().end(); ++x_0_itr){
          std::pair<Rope, std::pair<mfeanswer, pfanswer> >  x_0 = *x_0_itr;
          std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ans = trafo(x_0);
          push_back( answers, ans);
        }
      }

    erase( a_0);
  }

  hishapeh_mfe_pfx_hash_h_h_pfx ret_3 = nt_left_unpaired(t_0_left_most);
  append( answers, ret_3);
  hash_filter( answers);
  finalize( answers);
  return answers;
}


std::pair<Rope, std::pair<mfeanswer, pfanswer> >  hishapeh_mfe_pfx::acomb(const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_le, const TUSubsequence & p_b, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_re)
{
  Rope l_0 = p_le.first;
  TUSubsequence l_1 = p_b;
  Rope l_2 = p_re.first;
  std::pair<mfeanswer, pfanswer>  r_0 = p_le.second;
  TUSubsequence r_1 = p_b;
  std::pair<mfeanswer, pfanswer>  r_2 = p_re.second;
  Rope ret_left = acomb_l(l_0, l_1, l_2);
  std::pair<mfeanswer, pfanswer>  ret_right = acomb_r(r_0, r_1, r_2);
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfeanswer, pfanswer> >  hishapeh_mfe_pfx::addss(const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e, const TUSubsequence & p_rb)
{
  Rope l_0 = p_e.first;
  TUSubsequence l_1 = p_rb;
  std::pair<mfeanswer, pfanswer>  r_0 = p_e.second;
  TUSubsequence r_1 = p_rb;
  Rope ret_left = addss_l(l_0, l_1);
  std::pair<mfeanswer, pfanswer>  ret_right = addss_r(r_0, r_1);
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfeanswer, pfanswer> >  hishapeh_mfe_pfx::ambd(const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_le, const TUSubsequence & p_b, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_re)
{
  Rope l_0 = p_le.first;
  TUSubsequence l_1 = p_b;
  Rope l_2 = p_re.first;
  std::pair<mfeanswer, pfanswer>  r_0 = p_le.second;
  TUSubsequence r_1 = p_b;
  std::pair<mfeanswer, pfanswer>  r_2 = p_re.second;
  Rope ret_left = ambd_l(l_0, l_1, l_2);
  std::pair<mfeanswer, pfanswer>  ret_right = ambd_r(r_0, r_1, r_2);
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfeanswer, pfanswer> >  hishapeh_mfe_pfx::ambd_Pr(const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_le, const TUSubsequence & p_b, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_re)
{
  Rope l_0 = p_le.first;
  TUSubsequence l_1 = p_b;
  Rope l_2 = p_re.first;
  std::pair<mfeanswer, pfanswer>  r_0 = p_le.second;
  TUSubsequence r_1 = p_b;
  std::pair<mfeanswer, pfanswer>  r_2 = p_re.second;
  Rope ret_left = ambd_Pr_l(l_0, l_1, l_2);
  std::pair<mfeanswer, pfanswer>  ret_right = ambd_Pr_r(r_0, r_1, r_2);
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfeanswer, pfanswer> >  hishapeh_mfe_pfx::bl(const TUSubsequence & p_lregion, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e)
{
  TUSubsequence l_0 = p_lregion;
  Rope l_1 = p_e.first;
  TUSubsequence r_0 = p_lregion;
  std::pair<mfeanswer, pfanswer>  r_1 = p_e.second;
  Rope ret_left = bl_l(l_0, l_1);
  std::pair<mfeanswer, pfanswer>  ret_right = bl_r(r_0, r_1);
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfeanswer, pfanswer> >  hishapeh_mfe_pfx::br(const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e, const TUSubsequence & p_rregion)
{
  Rope l_0 = p_e.first;
  TUSubsequence l_1 = p_rregion;
  std::pair<mfeanswer, pfanswer>  r_0 = p_e.second;
  TUSubsequence r_1 = p_rregion;
  Rope ret_left = br_l(l_0, l_1);
  std::pair<mfeanswer, pfanswer>  ret_right = br_r(r_0, r_1);
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfeanswer, pfanswer> >  hishapeh_mfe_pfx::cadd(const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_le, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_re)
{
  Rope l_0 = p_le.first;
  Rope l_1 = p_re.first;
  std::pair<mfeanswer, pfanswer>  r_0 = p_le.second;
  std::pair<mfeanswer, pfanswer>  r_1 = p_re.second;
  Rope ret_left = cadd_l(l_0, l_1);
  std::pair<mfeanswer, pfanswer>  ret_right = cadd_r(r_0, r_1);
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfeanswer, pfanswer> >  hishapeh_mfe_pfx::cadd_Pr(const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_le, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_re)
{
  Rope l_0 = p_le.first;
  Rope l_1 = p_re.first;
  std::pair<mfeanswer, pfanswer>  r_0 = p_le.second;
  std::pair<mfeanswer, pfanswer>  r_1 = p_re.second;
  Rope ret_left = cadd_Pr_l(l_0, l_1);
  std::pair<mfeanswer, pfanswer>  ret_right = cadd_Pr_r(r_0, r_1);
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfeanswer, pfanswer> >  hishapeh_mfe_pfx::cadd_Pr_Pr(const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_le, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_re)
{
  Rope l_0 = p_le.first;
  Rope l_1 = p_re.first;
  std::pair<mfeanswer, pfanswer>  r_0 = p_le.second;
  std::pair<mfeanswer, pfanswer>  r_1 = p_re.second;
  Rope ret_left = cadd_Pr_Pr_l(l_0, l_1);
  std::pair<mfeanswer, pfanswer>  ret_right = cadd_Pr_Pr_r(r_0, r_1);
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfeanswer, pfanswer> >  hishapeh_mfe_pfx::cadd_Pr_Pr_Pr(const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_le, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_re)
{
  Rope l_0 = p_le.first;
  Rope l_1 = p_re.first;
  std::pair<mfeanswer, pfanswer>  r_0 = p_le.second;
  std::pair<mfeanswer, pfanswer>  r_1 = p_re.second;
  Rope ret_left = cadd_Pr_Pr_Pr_l(l_0, l_1);
  std::pair<mfeanswer, pfanswer>  ret_right = cadd_Pr_Pr_Pr_r(r_0, r_1);
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfeanswer, pfanswer> >  hishapeh_mfe_pfx::combine(const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_le, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_re)
{
  Rope l_0 = p_le.first;
  Rope l_1 = p_re.first;
  std::pair<mfeanswer, pfanswer>  r_0 = p_le.second;
  std::pair<mfeanswer, pfanswer>  r_1 = p_re.second;
  Rope ret_left = combine_l(l_0, l_1);
  std::pair<mfeanswer, pfanswer>  ret_right = combine_r(r_0, r_1);
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfeanswer, pfanswer> >  hishapeh_mfe_pfx::drem(const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e)
{
  Rope l_0 = p_e.first;
  std::pair<mfeanswer, pfanswer>  r_0 = p_e.second;
  Rope ret_left = drem_l(l_0);
  std::pair<mfeanswer, pfanswer>  ret_right = drem_r(r_0);
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfeanswer, pfanswer> >  hishapeh_mfe_pfx::edl(const TUSubsequence & p_lb, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e)
{
  TUSubsequence l_0 = p_lb;
  Rope l_1 = p_e.first;
  TUSubsequence r_0 = p_lb;
  std::pair<mfeanswer, pfanswer>  r_1 = p_e.second;
  Rope ret_left = edl_l(l_0, l_1);
  std::pair<mfeanswer, pfanswer>  ret_right = edl_r(r_0, r_1);
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfeanswer, pfanswer> >  hishapeh_mfe_pfx::edlr(const TUSubsequence & p_lb, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e, const TUSubsequence & p_rb)
{
  TUSubsequence l_0 = p_lb;
  Rope l_1 = p_e.first;
  TUSubsequence l_2 = p_rb;
  TUSubsequence r_0 = p_lb;
  std::pair<mfeanswer, pfanswer>  r_1 = p_e.second;
  TUSubsequence r_2 = p_rb;
  Rope ret_left = edlr_l(l_0, l_1, l_2);
  std::pair<mfeanswer, pfanswer>  ret_right = edlr_r(r_0, r_1, r_2);
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfeanswer, pfanswer> >  hishapeh_mfe_pfx::edr(const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e, const TUSubsequence & p_rb)
{
  Rope l_0 = p_e.first;
  TUSubsequence l_1 = p_rb;
  std::pair<mfeanswer, pfanswer>  r_0 = p_e.second;
  TUSubsequence r_1 = p_rb;
  Rope ret_left = edr_l(l_0, l_1);
  std::pair<mfeanswer, pfanswer>  ret_right = edr_r(r_0, r_1);
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

template <typename Iterator>
hishapeh_mfe_pfx_hash_h_h_pfx hishapeh_mfe_pfx::h(std::pair<Iterator, Iterator> i)

{
  hishapeh_mfe_pfx_hash_h_h_pfx answers;
  empty(answers);
  append_filter( answers, i);
  finalize( answers);
  return answers;
}

std::pair<Rope, std::pair<mfeanswer, pfanswer> >  hishapeh_mfe_pfx::hl(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const TUSubsequence & p_region, const TUSubsequence & p_rb, const TUSubsequence & p_rrb)
{
  TUSubsequence l_0 = p_llb;
  TUSubsequence l_1 = p_lb;
  TUSubsequence l_2 = p_region;
  TUSubsequence l_3 = p_rb;
  TUSubsequence l_4 = p_rrb;
  TUSubsequence r_0 = p_llb;
  TUSubsequence r_1 = p_lb;
  TUSubsequence r_2 = p_region;
  TUSubsequence r_3 = p_rb;
  TUSubsequence r_4 = p_rrb;
  Rope ret_left = hl_l(l_0, l_1, l_2, l_3, l_4);
  std::pair<mfeanswer, pfanswer>  ret_right = hl_r(r_0, r_1, r_2, r_3, r_4);
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfeanswer, pfanswer> >  hishapeh_mfe_pfx::il(const TUSubsequence & p_lregion, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e, const TUSubsequence & p_rregion)
{
  TUSubsequence l_0 = p_lregion;
  Rope l_1 = p_e.first;
  TUSubsequence l_2 = p_rregion;
  TUSubsequence r_0 = p_lregion;
  std::pair<mfeanswer, pfanswer>  r_1 = p_e.second;
  TUSubsequence r_2 = p_rregion;
  Rope ret_left = il_l(l_0, l_1, l_2);
  std::pair<mfeanswer, pfanswer>  ret_right = il_r(r_0, r_1, r_2);
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfeanswer, pfanswer> >  hishapeh_mfe_pfx::incl(const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e)
{
  Rope l_0 = p_e.first;
  std::pair<mfeanswer, pfanswer>  r_0 = p_e.second;
  Rope ret_left = incl_l(l_0);
  std::pair<mfeanswer, pfanswer>  ret_right = incl_r(r_0);
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfeanswer, pfanswer> >  hishapeh_mfe_pfx::is(const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e)
{
  Rope l_0 = p_e.first;
  std::pair<mfeanswer, pfanswer>  r_0 = p_e.second;
  Rope ret_left = is_l(l_0);
  std::pair<mfeanswer, pfanswer>  ret_right = is_r(r_0);
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfeanswer, pfanswer> >  hishapeh_mfe_pfx::ml(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e, const TUSubsequence & p_rb, const TUSubsequence & p_rrb)
{
  TUSubsequence l_0 = p_llb;
  TUSubsequence l_1 = p_lb;
  Rope l_2 = p_e.first;
  TUSubsequence l_3 = p_rb;
  TUSubsequence l_4 = p_rrb;
  TUSubsequence r_0 = p_llb;
  TUSubsequence r_1 = p_lb;
  std::pair<mfeanswer, pfanswer>  r_2 = p_e.second;
  TUSubsequence r_3 = p_rb;
  TUSubsequence r_4 = p_rrb;
  Rope ret_left = ml_l(l_0, l_1, l_2, l_3, l_4);
  std::pair<mfeanswer, pfanswer>  ret_right = ml_r(r_0, r_1, r_2, r_3, r_4);
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfeanswer, pfanswer> >  hishapeh_mfe_pfx::mladl(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e, const TUSubsequence & p_rb, const TUSubsequence & p_rrb)
{
  TUSubsequence l_0 = p_llb;
  TUSubsequence l_1 = p_lb;
  TUSubsequence l_2 = p_dl;
  Rope l_3 = p_e.first;
  TUSubsequence l_4 = p_rb;
  TUSubsequence l_5 = p_rrb;
  TUSubsequence r_0 = p_llb;
  TUSubsequence r_1 = p_lb;
  TUSubsequence r_2 = p_dl;
  std::pair<mfeanswer, pfanswer>  r_3 = p_e.second;
  TUSubsequence r_4 = p_rb;
  TUSubsequence r_5 = p_rrb;
  Rope ret_left = mladl_l(l_0, l_1, l_2, l_3, l_4, l_5);
  std::pair<mfeanswer, pfanswer>  ret_right = mladl_r(r_0, r_1, r_2, r_3, r_4, r_5);
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfeanswer, pfanswer> >  hishapeh_mfe_pfx::mladldr(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb, const TUSubsequence & p_rrb)
{
  TUSubsequence l_0 = p_llb;
  TUSubsequence l_1 = p_lb;
  TUSubsequence l_2 = p_dl;
  Rope l_3 = p_e.first;
  TUSubsequence l_4 = p_dr;
  TUSubsequence l_5 = p_rb;
  TUSubsequence l_6 = p_rrb;
  TUSubsequence r_0 = p_llb;
  TUSubsequence r_1 = p_lb;
  TUSubsequence r_2 = p_dl;
  std::pair<mfeanswer, pfanswer>  r_3 = p_e.second;
  TUSubsequence r_4 = p_dr;
  TUSubsequence r_5 = p_rb;
  TUSubsequence r_6 = p_rrb;
  Rope ret_left = mladldr_l(l_0, l_1, l_2, l_3, l_4, l_5, l_6);
  std::pair<mfeanswer, pfanswer>  ret_right = mladldr_r(r_0, r_1, r_2, r_3, r_4, r_5, r_6);
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfeanswer, pfanswer> >  hishapeh_mfe_pfx::mladlr(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb, const TUSubsequence & p_rrb)
{
  TUSubsequence l_0 = p_llb;
  TUSubsequence l_1 = p_lb;
  TUSubsequence l_2 = p_dl;
  Rope l_3 = p_e.first;
  TUSubsequence l_4 = p_dr;
  TUSubsequence l_5 = p_rb;
  TUSubsequence l_6 = p_rrb;
  TUSubsequence r_0 = p_llb;
  TUSubsequence r_1 = p_lb;
  TUSubsequence r_2 = p_dl;
  std::pair<mfeanswer, pfanswer>  r_3 = p_e.second;
  TUSubsequence r_4 = p_dr;
  TUSubsequence r_5 = p_rb;
  TUSubsequence r_6 = p_rrb;
  Rope ret_left = mladlr_l(l_0, l_1, l_2, l_3, l_4, l_5, l_6);
  std::pair<mfeanswer, pfanswer>  ret_right = mladlr_r(r_0, r_1, r_2, r_3, r_4, r_5, r_6);
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfeanswer, pfanswer> >  hishapeh_mfe_pfx::mladr(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb, const TUSubsequence & p_rrb)
{
  TUSubsequence l_0 = p_llb;
  TUSubsequence l_1 = p_lb;
  Rope l_2 = p_e.first;
  TUSubsequence l_3 = p_dr;
  TUSubsequence l_4 = p_rb;
  TUSubsequence l_5 = p_rrb;
  TUSubsequence r_0 = p_llb;
  TUSubsequence r_1 = p_lb;
  std::pair<mfeanswer, pfanswer>  r_2 = p_e.second;
  TUSubsequence r_3 = p_dr;
  TUSubsequence r_4 = p_rb;
  TUSubsequence r_5 = p_rrb;
  Rope ret_left = mladr_l(l_0, l_1, l_2, l_3, l_4, l_5);
  std::pair<mfeanswer, pfanswer>  ret_right = mladr_r(r_0, r_1, r_2, r_3, r_4, r_5);
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfeanswer, pfanswer> >  hishapeh_mfe_pfx::mldl(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e, const TUSubsequence & p_rb, const TUSubsequence & p_rrb)
{
  TUSubsequence l_0 = p_llb;
  TUSubsequence l_1 = p_lb;
  TUSubsequence l_2 = p_dl;
  Rope l_3 = p_e.first;
  TUSubsequence l_4 = p_rb;
  TUSubsequence l_5 = p_rrb;
  TUSubsequence r_0 = p_llb;
  TUSubsequence r_1 = p_lb;
  TUSubsequence r_2 = p_dl;
  std::pair<mfeanswer, pfanswer>  r_3 = p_e.second;
  TUSubsequence r_4 = p_rb;
  TUSubsequence r_5 = p_rrb;
  Rope ret_left = mldl_l(l_0, l_1, l_2, l_3, l_4, l_5);
  std::pair<mfeanswer, pfanswer>  ret_right = mldl_r(r_0, r_1, r_2, r_3, r_4, r_5);
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfeanswer, pfanswer> >  hishapeh_mfe_pfx::mldladr(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb, const TUSubsequence & p_rrb)
{
  TUSubsequence l_0 = p_llb;
  TUSubsequence l_1 = p_lb;
  TUSubsequence l_2 = p_dl;
  Rope l_3 = p_e.first;
  TUSubsequence l_4 = p_dr;
  TUSubsequence l_5 = p_rb;
  TUSubsequence l_6 = p_rrb;
  TUSubsequence r_0 = p_llb;
  TUSubsequence r_1 = p_lb;
  TUSubsequence r_2 = p_dl;
  std::pair<mfeanswer, pfanswer>  r_3 = p_e.second;
  TUSubsequence r_4 = p_dr;
  TUSubsequence r_5 = p_rb;
  TUSubsequence r_6 = p_rrb;
  Rope ret_left = mldladr_l(l_0, l_1, l_2, l_3, l_4, l_5, l_6);
  std::pair<mfeanswer, pfanswer>  ret_right = mldladr_r(r_0, r_1, r_2, r_3, r_4, r_5, r_6);
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfeanswer, pfanswer> >  hishapeh_mfe_pfx::mldlr(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb, const TUSubsequence & p_rrb)
{
  TUSubsequence l_0 = p_llb;
  TUSubsequence l_1 = p_lb;
  TUSubsequence l_2 = p_dl;
  Rope l_3 = p_e.first;
  TUSubsequence l_4 = p_dr;
  TUSubsequence l_5 = p_rb;
  TUSubsequence l_6 = p_rrb;
  TUSubsequence r_0 = p_llb;
  TUSubsequence r_1 = p_lb;
  TUSubsequence r_2 = p_dl;
  std::pair<mfeanswer, pfanswer>  r_3 = p_e.second;
  TUSubsequence r_4 = p_dr;
  TUSubsequence r_5 = p_rb;
  TUSubsequence r_6 = p_rrb;
  Rope ret_left = mldlr_l(l_0, l_1, l_2, l_3, l_4, l_5, l_6);
  std::pair<mfeanswer, pfanswer>  ret_right = mldlr_r(r_0, r_1, r_2, r_3, r_4, r_5, r_6);
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfeanswer, pfanswer> >  hishapeh_mfe_pfx::mldr(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb, const TUSubsequence & p_rrb)
{
  TUSubsequence l_0 = p_llb;
  TUSubsequence l_1 = p_lb;
  Rope l_2 = p_e.first;
  TUSubsequence l_3 = p_dr;
  TUSubsequence l_4 = p_rb;
  TUSubsequence l_5 = p_rrb;
  TUSubsequence r_0 = p_llb;
  TUSubsequence r_1 = p_lb;
  std::pair<mfeanswer, pfanswer>  r_2 = p_e.second;
  TUSubsequence r_3 = p_dr;
  TUSubsequence r_4 = p_rb;
  TUSubsequence r_5 = p_rrb;
  Rope ret_left = mldr_l(l_0, l_1, l_2, l_3, l_4, l_5);
  std::pair<mfeanswer, pfanswer>  ret_right = mldr_r(r_0, r_1, r_2, r_3, r_4, r_5);
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfeanswer, pfanswer> >  hishapeh_mfe_pfx::nil(const TUSubsequence & p_loc)
{
  TUSubsequence l_0 = p_loc;
  TUSubsequence r_0 = p_loc;
  Rope ret_left = nil_l(l_0);
  std::pair<mfeanswer, pfanswer>  ret_right = nil_r(r_0);
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfeanswer, pfanswer> >  hishapeh_mfe_pfx::nil_Pr(const TUSubsequence & p_loc)
{
  TUSubsequence l_0 = p_loc;
  TUSubsequence r_0 = p_loc;
  Rope ret_left = nil_Pr_l(l_0);
  std::pair<mfeanswer, pfanswer>  ret_right = nil_Pr_r(r_0);
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfeanswer, pfanswer> >  hishapeh_mfe_pfx::sadd(const TUSubsequence & p_b, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e)
{
  TUSubsequence l_0 = p_b;
  Rope l_1 = p_e.first;
  TUSubsequence r_0 = p_b;
  std::pair<mfeanswer, pfanswer>  r_1 = p_e.second;
  Rope ret_left = sadd_l(l_0, l_1);
  std::pair<mfeanswer, pfanswer>  ret_right = sadd_r(r_0, r_1);
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfeanswer, pfanswer> >  hishapeh_mfe_pfx::sp(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e, const TUSubsequence & p_rb, const TUSubsequence & p_rrb)
{
  TUSubsequence l_0 = p_llb;
  TUSubsequence l_1 = p_lb;
  Rope l_2 = p_e.first;
  TUSubsequence l_3 = p_rb;
  TUSubsequence l_4 = p_rrb;
  TUSubsequence r_0 = p_llb;
  TUSubsequence r_1 = p_lb;
  std::pair<mfeanswer, pfanswer>  r_2 = p_e.second;
  TUSubsequence r_3 = p_rb;
  TUSubsequence r_4 = p_rrb;
  Rope ret_left = sp_l(l_0, l_1, l_2, l_3, l_4);
  std::pair<mfeanswer, pfanswer>  ret_right = sp_r(r_0, r_1, r_2, r_3, r_4);
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfeanswer, pfanswer> >  hishapeh_mfe_pfx::sr(const TUSubsequence & p_lb, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e, const TUSubsequence & p_rb)
{
  TUSubsequence l_0 = p_lb;
  Rope l_1 = p_e.first;
  TUSubsequence l_2 = p_rb;
  TUSubsequence r_0 = p_lb;
  std::pair<mfeanswer, pfanswer>  r_1 = p_e.second;
  TUSubsequence r_2 = p_rb;
  Rope ret_left = sr_l(l_0, l_1, l_2);
  std::pair<mfeanswer, pfanswer>  ret_right = sr_r(r_0, r_1, r_2);
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfeanswer, pfanswer> >  hishapeh_mfe_pfx::ssadd(const TUSubsequence & p_lb, const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e)
{
  TUSubsequence l_0 = p_lb;
  Rope l_1 = p_e.first;
  TUSubsequence r_0 = p_lb;
  std::pair<mfeanswer, pfanswer>  r_1 = p_e.second;
  Rope ret_left = ssadd_l(l_0, l_1);
  std::pair<mfeanswer, pfanswer>  ret_right = ssadd_r(r_0, r_1);
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfeanswer, pfanswer> >  hishapeh_mfe_pfx::trafo(const std::pair<Rope, std::pair<mfeanswer, pfanswer> > & p_e)
{
  Rope l_0 = p_e.first;
  std::pair<mfeanswer, pfanswer>  r_0 = p_e.second;
  Rope ret_left = trafo_l(l_0);
  std::pair<mfeanswer, pfanswer>  ret_right = trafo_r(r_0);
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}



Rope hishapeh_mfe_pfx::acomb_l(const Rope & le, const TUSubsequence & b, const Rope & re)
{
#line 3564 "hishapes.gap"
  Rope res;
  append( res, le);
  append( res, re);
  return res;
#line 3337 "hishapeh_mfe_pfx.cc"
}

Rope hishapeh_mfe_pfx::addss_l(const Rope & e, const TUSubsequence & rb)
{
#line 3541 "hishapes.gap"
  return e;
#line 3344 "hishapeh_mfe_pfx.cc"
}

Rope hishapeh_mfe_pfx::ambd_l(const Rope & le, const TUSubsequence & b, const Rope & re)
{
#line 3427 "hishapes.gap"
  Rope res;
  append( res, le);
  append( res, re);
  return res;
#line 3354 "hishapeh_mfe_pfx.cc"
}

Rope hishapeh_mfe_pfx::ambd_Pr_l(const Rope & le, const TUSubsequence & b, const Rope & re)
{
#line 3434 "hishapes.gap"
  Rope res;
  append( res, le);
  append( res, re);
  return res;
#line 3364 "hishapeh_mfe_pfx.cc"
}

Rope hishapeh_mfe_pfx::bl_l(const TUSubsequence & lregion, const Rope & e)
{
#line 3493 "hishapes.gap"
  return e;
#line 3371 "hishapeh_mfe_pfx.cc"
}

Rope hishapeh_mfe_pfx::br_l(const Rope & e, const TUSubsequence & rregion)
{
#line 3497 "hishapes.gap"
  return e;
#line 3378 "hishapeh_mfe_pfx.cc"
}

Rope hishapeh_mfe_pfx::cadd_l(const Rope & le, const Rope & re)
{
#line 3397 "hishapes.gap"
  if ((re == "_"))
    {
      return le;
    }

  else
    {
      return (le + re);
    }

#line 3394 "hishapeh_mfe_pfx.cc"
}

Rope hishapeh_mfe_pfx::cadd_Pr_l(const Rope & le, const Rope & re)
{
#line 3405 "hishapes.gap"
  Rope res;
  append( res, le);
  append( res, re);
  return res;
#line 3404 "hishapeh_mfe_pfx.cc"
}

Rope hishapeh_mfe_pfx::cadd_Pr_Pr_l(const Rope & le, const Rope & re)
{
#line 3412 "hishapes.gap"
  if ((re == "_"))
    {
      return le;
    }

  else
    {
      return (le + re);
    }

#line 3420 "hishapeh_mfe_pfx.cc"
}

Rope hishapeh_mfe_pfx::cadd_Pr_Pr_Pr_l(const Rope & le, const Rope & re)
{
#line 3420 "hishapes.gap"
  Rope res;
  append( res, le);
  append( res, re);
  return res;
#line 3430 "hishapeh_mfe_pfx.cc"
}

Rope hishapeh_mfe_pfx::combine_l(const Rope & le, const Rope & re)
{
#line 3557 "hishapes.gap"
  Rope res;
  append( res, le);
  append( res, re);
  return res;
#line 3440 "hishapeh_mfe_pfx.cc"
}

Rope hishapeh_mfe_pfx::drem_l(const Rope & e)
{
#line 3463 "hishapes.gap"
  return e;
#line 3447 "hishapeh_mfe_pfx.cc"
}

Rope hishapeh_mfe_pfx::edl_l(const TUSubsequence & lb, const Rope & e)
{
#line 3451 "hishapes.gap"
  return e;
#line 3454 "hishapeh_mfe_pfx.cc"
}

Rope hishapeh_mfe_pfx::edlr_l(const TUSubsequence & lb, const Rope & e, const TUSubsequence & rb)
{
#line 3459 "hishapes.gap"
  return e;
#line 3461 "hishapeh_mfe_pfx.cc"
}

Rope hishapeh_mfe_pfx::edr_l(const Rope & e, const TUSubsequence & rb)
{
#line 3455 "hishapes.gap"
  return e;
#line 3468 "hishapeh_mfe_pfx.cc"
}

Rope hishapeh_mfe_pfx::hl_l(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & region, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 3475 "hishapes.gap"
  Rope res;
  int pos;
  pos = ( ( ((lb.i + rb.j) + 1) )  / 2);
  if (((pos * 2) > ((lb.i + rb.j) + 1)))
    {
      pos = (pos - 1);
    }

  append( res, pos);
  if (((pos * 2) != ((lb.i + rb.j) + 1)))
    {
      append( res, ".5", 2);
    }

  append( res, ',');
  return res;
#line 3490 "hishapeh_mfe_pfx.cc"
}

Rope hishapeh_mfe_pfx::il_l(const TUSubsequence & lregion, const Rope & e, const TUSubsequence & rregion)
{
#line 3501 "hishapes.gap"
  return e;
#line 3497 "hishapeh_mfe_pfx.cc"
}

Rope hishapeh_mfe_pfx::incl_l(const Rope & e)
{
#line 3553 "hishapes.gap"
  return e;
#line 3504 "hishapeh_mfe_pfx.cc"
}

Rope hishapeh_mfe_pfx::is_l(const Rope & e)
{
#line 3467 "hishapes.gap"
  return e;
#line 3511 "hishapeh_mfe_pfx.cc"
}

Rope hishapeh_mfe_pfx::ml_l(const TUSubsequence & llb, const TUSubsequence & lb, const Rope & e, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 3505 "hishapes.gap"
  return e;
#line 3518 "hishapeh_mfe_pfx.cc"
}

Rope hishapeh_mfe_pfx::mladl_l(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const Rope & e, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 3537 "hishapes.gap"
  return e;
#line 3525 "hishapeh_mfe_pfx.cc"
}

Rope hishapeh_mfe_pfx::mladldr_l(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const Rope & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 3529 "hishapes.gap"
  return e;
#line 3532 "hishapeh_mfe_pfx.cc"
}

Rope hishapeh_mfe_pfx::mladlr_l(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const Rope & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 3521 "hishapes.gap"
  return e;
#line 3539 "hishapeh_mfe_pfx.cc"
}

Rope hishapeh_mfe_pfx::mladr_l(const TUSubsequence & llb, const TUSubsequence & lb, const Rope & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 3513 "hishapes.gap"
  return e;
#line 3546 "hishapeh_mfe_pfx.cc"
}

Rope hishapeh_mfe_pfx::mldl_l(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const Rope & e, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 3533 "hishapes.gap"
  return e;
#line 3553 "hishapeh_mfe_pfx.cc"
}

Rope hishapeh_mfe_pfx::mldladr_l(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const Rope & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 3525 "hishapes.gap"
  return e;
#line 3560 "hishapeh_mfe_pfx.cc"
}

Rope hishapeh_mfe_pfx::mldlr_l(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const Rope & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 3517 "hishapes.gap"
  return e;
#line 3567 "hishapeh_mfe_pfx.cc"
}

Rope hishapeh_mfe_pfx::mldr_l(const TUSubsequence & llb, const TUSubsequence & lb, const Rope & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 3509 "hishapes.gap"
  return e;
#line 3574 "hishapeh_mfe_pfx.cc"
}

Rope hishapeh_mfe_pfx::nil_l(const TUSubsequence & loc)
{
#line 3441 "hishapes.gap"
  Rope r;
  return r;
#line 3582 "hishapeh_mfe_pfx.cc"
}

Rope hishapeh_mfe_pfx::nil_Pr_l(const TUSubsequence & loc)
{
#line 3446 "hishapes.gap"
  Rope r;
  return r;
#line 3590 "hishapeh_mfe_pfx.cc"
}

Rope hishapeh_mfe_pfx::sadd_l(const TUSubsequence & b, const Rope & e)
{
#line 3384 "hishapes.gap"
  Rope emptyShape;
  Rope res;
  if ((e == emptyShape))
  {
    append( res, '_');
    append( res, e);
    return res;
  }

  else
    {
      return e;
    }

#line 3610 "hishapeh_mfe_pfx.cc"
}

Rope hishapeh_mfe_pfx::sp_l(const TUSubsequence & llb, const TUSubsequence & lb, const Rope & e, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 3489 "hishapes.gap"
  return e;
#line 3617 "hishapeh_mfe_pfx.cc"
}

Rope hishapeh_mfe_pfx::sr_l(const TUSubsequence & lb, const Rope & e, const TUSubsequence & rb)
{
#line 3471 "hishapes.gap"
  return e;
#line 3624 "hishapeh_mfe_pfx.cc"
}

Rope hishapeh_mfe_pfx::ssadd_l(const TUSubsequence & lb, const Rope & e)
{
#line 3545 "hishapes.gap"
  return e;
#line 3631 "hishapeh_mfe_pfx.cc"
}

Rope hishapeh_mfe_pfx::trafo_l(const Rope & e)
{
#line 3549 "hishapes.gap"
  return e;
#line 3638 "hishapeh_mfe_pfx.cc"
}



std::pair<mfeanswer, pfanswer>  hishapeh_mfe_pfx::acomb_r(const std::pair<mfeanswer, pfanswer> & p_le, const TUSubsequence & p_b, const std::pair<mfeanswer, pfanswer> & p_re)
{
  mfeanswer l_0 = p_le.first;
  TUSubsequence l_1 = p_b;
  mfeanswer l_2 = p_re.first;
  pfanswer r_0 = p_le.second;
  TUSubsequence r_1 = p_b;
  pfanswer r_2 = p_re.second;
  mfeanswer ret_left = acomb_r_l(l_0, l_1, l_2);
  pfanswer ret_right = acomb_r_r(r_0, r_1, r_2);
  std::pair<mfeanswer, pfanswer>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfeanswer, pfanswer>  hishapeh_mfe_pfx::addss_r(const std::pair<mfeanswer, pfanswer> & p_e, const TUSubsequence & p_rb)
{
  mfeanswer l_0 = p_e.first;
  TUSubsequence l_1 = p_rb;
  pfanswer r_0 = p_e.second;
  TUSubsequence r_1 = p_rb;
  mfeanswer ret_left = addss_r_l(l_0, l_1);
  pfanswer ret_right = addss_r_r(r_0, r_1);
  std::pair<mfeanswer, pfanswer>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfeanswer, pfanswer>  hishapeh_mfe_pfx::ambd_r(const std::pair<mfeanswer, pfanswer> & p_le, const TUSubsequence & p_b, const std::pair<mfeanswer, pfanswer> & p_re)
{
  mfeanswer l_0 = p_le.first;
  TUSubsequence l_1 = p_b;
  mfeanswer l_2 = p_re.first;
  pfanswer r_0 = p_le.second;
  TUSubsequence r_1 = p_b;
  pfanswer r_2 = p_re.second;
  mfeanswer ret_left = ambd_r_l(l_0, l_1, l_2);
  pfanswer ret_right = ambd_r_r(r_0, r_1, r_2);
  std::pair<mfeanswer, pfanswer>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfeanswer, pfanswer>  hishapeh_mfe_pfx::ambd_Pr_r(const std::pair<mfeanswer, pfanswer> & p_le, const TUSubsequence & p_b, const std::pair<mfeanswer, pfanswer> & p_re)
{
  mfeanswer l_0 = p_le.first;
  TUSubsequence l_1 = p_b;
  mfeanswer l_2 = p_re.first;
  pfanswer r_0 = p_le.second;
  TUSubsequence r_1 = p_b;
  pfanswer r_2 = p_re.second;
  mfeanswer ret_left = ambd_Pr_r_l(l_0, l_1, l_2);
  pfanswer ret_right = ambd_Pr_r_r(r_0, r_1, r_2);
  std::pair<mfeanswer, pfanswer>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfeanswer, pfanswer>  hishapeh_mfe_pfx::bl_r(const TUSubsequence & p_lregion, const std::pair<mfeanswer, pfanswer> & p_e)
{
  TUSubsequence l_0 = p_lregion;
  mfeanswer l_1 = p_e.first;
  TUSubsequence r_0 = p_lregion;
  pfanswer r_1 = p_e.second;
  mfeanswer ret_left = bl_r_l(l_0, l_1);
  pfanswer ret_right = bl_r_r(r_0, r_1);
  std::pair<mfeanswer, pfanswer>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfeanswer, pfanswer>  hishapeh_mfe_pfx::br_r(const std::pair<mfeanswer, pfanswer> & p_e, const TUSubsequence & p_rregion)
{
  mfeanswer l_0 = p_e.first;
  TUSubsequence l_1 = p_rregion;
  pfanswer r_0 = p_e.second;
  TUSubsequence r_1 = p_rregion;
  mfeanswer ret_left = br_r_l(l_0, l_1);
  pfanswer ret_right = br_r_r(r_0, r_1);
  std::pair<mfeanswer, pfanswer>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfeanswer, pfanswer>  hishapeh_mfe_pfx::cadd_r(const std::pair<mfeanswer, pfanswer> & p_le, const std::pair<mfeanswer, pfanswer> & p_re)
{
  mfeanswer l_0 = p_le.first;
  mfeanswer l_1 = p_re.first;
  pfanswer r_0 = p_le.second;
  pfanswer r_1 = p_re.second;
  mfeanswer ret_left = cadd_r_l(l_0, l_1);
  pfanswer ret_right = cadd_r_r(r_0, r_1);
  std::pair<mfeanswer, pfanswer>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfeanswer, pfanswer>  hishapeh_mfe_pfx::cadd_Pr_r(const std::pair<mfeanswer, pfanswer> & p_le, const std::pair<mfeanswer, pfanswer> & p_re)
{
  mfeanswer l_0 = p_le.first;
  mfeanswer l_1 = p_re.first;
  pfanswer r_0 = p_le.second;
  pfanswer r_1 = p_re.second;
  mfeanswer ret_left = cadd_Pr_r_l(l_0, l_1);
  pfanswer ret_right = cadd_Pr_r_r(r_0, r_1);
  std::pair<mfeanswer, pfanswer>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfeanswer, pfanswer>  hishapeh_mfe_pfx::cadd_Pr_Pr_r(const std::pair<mfeanswer, pfanswer> & p_le, const std::pair<mfeanswer, pfanswer> & p_re)
{
  mfeanswer l_0 = p_le.first;
  mfeanswer l_1 = p_re.first;
  pfanswer r_0 = p_le.second;
  pfanswer r_1 = p_re.second;
  mfeanswer ret_left = cadd_Pr_Pr_r_l(l_0, l_1);
  pfanswer ret_right = cadd_Pr_Pr_r_r(r_0, r_1);
  std::pair<mfeanswer, pfanswer>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfeanswer, pfanswer>  hishapeh_mfe_pfx::cadd_Pr_Pr_Pr_r(const std::pair<mfeanswer, pfanswer> & p_le, const std::pair<mfeanswer, pfanswer> & p_re)
{
  mfeanswer l_0 = p_le.first;
  mfeanswer l_1 = p_re.first;
  pfanswer r_0 = p_le.second;
  pfanswer r_1 = p_re.second;
  mfeanswer ret_left = cadd_Pr_Pr_Pr_r_l(l_0, l_1);
  pfanswer ret_right = cadd_Pr_Pr_Pr_r_r(r_0, r_1);
  std::pair<mfeanswer, pfanswer>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfeanswer, pfanswer>  hishapeh_mfe_pfx::combine_r(const std::pair<mfeanswer, pfanswer> & p_le, const std::pair<mfeanswer, pfanswer> & p_re)
{
  mfeanswer l_0 = p_le.first;
  mfeanswer l_1 = p_re.first;
  pfanswer r_0 = p_le.second;
  pfanswer r_1 = p_re.second;
  mfeanswer ret_left = combine_r_l(l_0, l_1);
  pfanswer ret_right = combine_r_r(r_0, r_1);
  std::pair<mfeanswer, pfanswer>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfeanswer, pfanswer>  hishapeh_mfe_pfx::drem_r(const std::pair<mfeanswer, pfanswer> & p_e)
{
  mfeanswer l_0 = p_e.first;
  pfanswer r_0 = p_e.second;
  mfeanswer ret_left = drem_r_l(l_0);
  pfanswer ret_right = drem_r_r(r_0);
  std::pair<mfeanswer, pfanswer>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfeanswer, pfanswer>  hishapeh_mfe_pfx::edl_r(const TUSubsequence & p_lb, const std::pair<mfeanswer, pfanswer> & p_e)
{
  TUSubsequence l_0 = p_lb;
  mfeanswer l_1 = p_e.first;
  TUSubsequence r_0 = p_lb;
  pfanswer r_1 = p_e.second;
  mfeanswer ret_left = edl_r_l(l_0, l_1);
  pfanswer ret_right = edl_r_r(r_0, r_1);
  std::pair<mfeanswer, pfanswer>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfeanswer, pfanswer>  hishapeh_mfe_pfx::edlr_r(const TUSubsequence & p_lb, const std::pair<mfeanswer, pfanswer> & p_e, const TUSubsequence & p_rb)
{
  TUSubsequence l_0 = p_lb;
  mfeanswer l_1 = p_e.first;
  TUSubsequence l_2 = p_rb;
  TUSubsequence r_0 = p_lb;
  pfanswer r_1 = p_e.second;
  TUSubsequence r_2 = p_rb;
  mfeanswer ret_left = edlr_r_l(l_0, l_1, l_2);
  pfanswer ret_right = edlr_r_r(r_0, r_1, r_2);
  std::pair<mfeanswer, pfanswer>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfeanswer, pfanswer>  hishapeh_mfe_pfx::edr_r(const std::pair<mfeanswer, pfanswer> & p_e, const TUSubsequence & p_rb)
{
  mfeanswer l_0 = p_e.first;
  TUSubsequence l_1 = p_rb;
  pfanswer r_0 = p_e.second;
  TUSubsequence r_1 = p_rb;
  mfeanswer ret_left = edr_r_l(l_0, l_1);
  pfanswer ret_right = edr_r_r(r_0, r_1);
  std::pair<mfeanswer, pfanswer>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfeanswer, pfanswer>  hishapeh_mfe_pfx::hl_r(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const TUSubsequence & p_region, const TUSubsequence & p_rb, const TUSubsequence & p_rrb)
{
  TUSubsequence l_0 = p_llb;
  TUSubsequence l_1 = p_lb;
  TUSubsequence l_2 = p_region;
  TUSubsequence l_3 = p_rb;
  TUSubsequence l_4 = p_rrb;
  TUSubsequence r_0 = p_llb;
  TUSubsequence r_1 = p_lb;
  TUSubsequence r_2 = p_region;
  TUSubsequence r_3 = p_rb;
  TUSubsequence r_4 = p_rrb;
  mfeanswer ret_left = hl_r_l(l_0, l_1, l_2, l_3, l_4);
  pfanswer ret_right = hl_r_r(r_0, r_1, r_2, r_3, r_4);
  std::pair<mfeanswer, pfanswer>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfeanswer, pfanswer>  hishapeh_mfe_pfx::il_r(const TUSubsequence & p_lregion, const std::pair<mfeanswer, pfanswer> & p_e, const TUSubsequence & p_rregion)
{
  TUSubsequence l_0 = p_lregion;
  mfeanswer l_1 = p_e.first;
  TUSubsequence l_2 = p_rregion;
  TUSubsequence r_0 = p_lregion;
  pfanswer r_1 = p_e.second;
  TUSubsequence r_2 = p_rregion;
  mfeanswer ret_left = il_r_l(l_0, l_1, l_2);
  pfanswer ret_right = il_r_r(r_0, r_1, r_2);
  std::pair<mfeanswer, pfanswer>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfeanswer, pfanswer>  hishapeh_mfe_pfx::incl_r(const std::pair<mfeanswer, pfanswer> & p_e)
{
  mfeanswer l_0 = p_e.first;
  pfanswer r_0 = p_e.second;
  mfeanswer ret_left = incl_r_l(l_0);
  pfanswer ret_right = incl_r_r(r_0);
  std::pair<mfeanswer, pfanswer>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfeanswer, pfanswer>  hishapeh_mfe_pfx::is_r(const std::pair<mfeanswer, pfanswer> & p_e)
{
  mfeanswer l_0 = p_e.first;
  pfanswer r_0 = p_e.second;
  mfeanswer ret_left = is_r_l(l_0);
  pfanswer ret_right = is_r_r(r_0);
  std::pair<mfeanswer, pfanswer>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfeanswer, pfanswer>  hishapeh_mfe_pfx::ml_r(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const std::pair<mfeanswer, pfanswer> & p_e, const TUSubsequence & p_rb, const TUSubsequence & p_rrb)
{
  TUSubsequence l_0 = p_llb;
  TUSubsequence l_1 = p_lb;
  mfeanswer l_2 = p_e.first;
  TUSubsequence l_3 = p_rb;
  TUSubsequence l_4 = p_rrb;
  TUSubsequence r_0 = p_llb;
  TUSubsequence r_1 = p_lb;
  pfanswer r_2 = p_e.second;
  TUSubsequence r_3 = p_rb;
  TUSubsequence r_4 = p_rrb;
  mfeanswer ret_left = ml_r_l(l_0, l_1, l_2, l_3, l_4);
  pfanswer ret_right = ml_r_r(r_0, r_1, r_2, r_3, r_4);
  std::pair<mfeanswer, pfanswer>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfeanswer, pfanswer>  hishapeh_mfe_pfx::mladl_r(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<mfeanswer, pfanswer> & p_e, const TUSubsequence & p_rb, const TUSubsequence & p_rrb)
{
  TUSubsequence l_0 = p_llb;
  TUSubsequence l_1 = p_lb;
  TUSubsequence l_2 = p_dl;
  mfeanswer l_3 = p_e.first;
  TUSubsequence l_4 = p_rb;
  TUSubsequence l_5 = p_rrb;
  TUSubsequence r_0 = p_llb;
  TUSubsequence r_1 = p_lb;
  TUSubsequence r_2 = p_dl;
  pfanswer r_3 = p_e.second;
  TUSubsequence r_4 = p_rb;
  TUSubsequence r_5 = p_rrb;
  mfeanswer ret_left = mladl_r_l(l_0, l_1, l_2, l_3, l_4, l_5);
  pfanswer ret_right = mladl_r_r(r_0, r_1, r_2, r_3, r_4, r_5);
  std::pair<mfeanswer, pfanswer>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfeanswer, pfanswer>  hishapeh_mfe_pfx::mladldr_r(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<mfeanswer, pfanswer> & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb, const TUSubsequence & p_rrb)
{
  TUSubsequence l_0 = p_llb;
  TUSubsequence l_1 = p_lb;
  TUSubsequence l_2 = p_dl;
  mfeanswer l_3 = p_e.first;
  TUSubsequence l_4 = p_dr;
  TUSubsequence l_5 = p_rb;
  TUSubsequence l_6 = p_rrb;
  TUSubsequence r_0 = p_llb;
  TUSubsequence r_1 = p_lb;
  TUSubsequence r_2 = p_dl;
  pfanswer r_3 = p_e.second;
  TUSubsequence r_4 = p_dr;
  TUSubsequence r_5 = p_rb;
  TUSubsequence r_6 = p_rrb;
  mfeanswer ret_left = mladldr_r_l(l_0, l_1, l_2, l_3, l_4, l_5, l_6);
  pfanswer ret_right = mladldr_r_r(r_0, r_1, r_2, r_3, r_4, r_5, r_6);
  std::pair<mfeanswer, pfanswer>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfeanswer, pfanswer>  hishapeh_mfe_pfx::mladlr_r(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<mfeanswer, pfanswer> & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb, const TUSubsequence & p_rrb)
{
  TUSubsequence l_0 = p_llb;
  TUSubsequence l_1 = p_lb;
  TUSubsequence l_2 = p_dl;
  mfeanswer l_3 = p_e.first;
  TUSubsequence l_4 = p_dr;
  TUSubsequence l_5 = p_rb;
  TUSubsequence l_6 = p_rrb;
  TUSubsequence r_0 = p_llb;
  TUSubsequence r_1 = p_lb;
  TUSubsequence r_2 = p_dl;
  pfanswer r_3 = p_e.second;
  TUSubsequence r_4 = p_dr;
  TUSubsequence r_5 = p_rb;
  TUSubsequence r_6 = p_rrb;
  mfeanswer ret_left = mladlr_r_l(l_0, l_1, l_2, l_3, l_4, l_5, l_6);
  pfanswer ret_right = mladlr_r_r(r_0, r_1, r_2, r_3, r_4, r_5, r_6);
  std::pair<mfeanswer, pfanswer>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfeanswer, pfanswer>  hishapeh_mfe_pfx::mladr_r(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const std::pair<mfeanswer, pfanswer> & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb, const TUSubsequence & p_rrb)
{
  TUSubsequence l_0 = p_llb;
  TUSubsequence l_1 = p_lb;
  mfeanswer l_2 = p_e.first;
  TUSubsequence l_3 = p_dr;
  TUSubsequence l_4 = p_rb;
  TUSubsequence l_5 = p_rrb;
  TUSubsequence r_0 = p_llb;
  TUSubsequence r_1 = p_lb;
  pfanswer r_2 = p_e.second;
  TUSubsequence r_3 = p_dr;
  TUSubsequence r_4 = p_rb;
  TUSubsequence r_5 = p_rrb;
  mfeanswer ret_left = mladr_r_l(l_0, l_1, l_2, l_3, l_4, l_5);
  pfanswer ret_right = mladr_r_r(r_0, r_1, r_2, r_3, r_4, r_5);
  std::pair<mfeanswer, pfanswer>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfeanswer, pfanswer>  hishapeh_mfe_pfx::mldl_r(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<mfeanswer, pfanswer> & p_e, const TUSubsequence & p_rb, const TUSubsequence & p_rrb)
{
  TUSubsequence l_0 = p_llb;
  TUSubsequence l_1 = p_lb;
  TUSubsequence l_2 = p_dl;
  mfeanswer l_3 = p_e.first;
  TUSubsequence l_4 = p_rb;
  TUSubsequence l_5 = p_rrb;
  TUSubsequence r_0 = p_llb;
  TUSubsequence r_1 = p_lb;
  TUSubsequence r_2 = p_dl;
  pfanswer r_3 = p_e.second;
  TUSubsequence r_4 = p_rb;
  TUSubsequence r_5 = p_rrb;
  mfeanswer ret_left = mldl_r_l(l_0, l_1, l_2, l_3, l_4, l_5);
  pfanswer ret_right = mldl_r_r(r_0, r_1, r_2, r_3, r_4, r_5);
  std::pair<mfeanswer, pfanswer>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfeanswer, pfanswer>  hishapeh_mfe_pfx::mldladr_r(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<mfeanswer, pfanswer> & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb, const TUSubsequence & p_rrb)
{
  TUSubsequence l_0 = p_llb;
  TUSubsequence l_1 = p_lb;
  TUSubsequence l_2 = p_dl;
  mfeanswer l_3 = p_e.first;
  TUSubsequence l_4 = p_dr;
  TUSubsequence l_5 = p_rb;
  TUSubsequence l_6 = p_rrb;
  TUSubsequence r_0 = p_llb;
  TUSubsequence r_1 = p_lb;
  TUSubsequence r_2 = p_dl;
  pfanswer r_3 = p_e.second;
  TUSubsequence r_4 = p_dr;
  TUSubsequence r_5 = p_rb;
  TUSubsequence r_6 = p_rrb;
  mfeanswer ret_left = mldladr_r_l(l_0, l_1, l_2, l_3, l_4, l_5, l_6);
  pfanswer ret_right = mldladr_r_r(r_0, r_1, r_2, r_3, r_4, r_5, r_6);
  std::pair<mfeanswer, pfanswer>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfeanswer, pfanswer>  hishapeh_mfe_pfx::mldlr_r(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<mfeanswer, pfanswer> & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb, const TUSubsequence & p_rrb)
{
  TUSubsequence l_0 = p_llb;
  TUSubsequence l_1 = p_lb;
  TUSubsequence l_2 = p_dl;
  mfeanswer l_3 = p_e.first;
  TUSubsequence l_4 = p_dr;
  TUSubsequence l_5 = p_rb;
  TUSubsequence l_6 = p_rrb;
  TUSubsequence r_0 = p_llb;
  TUSubsequence r_1 = p_lb;
  TUSubsequence r_2 = p_dl;
  pfanswer r_3 = p_e.second;
  TUSubsequence r_4 = p_dr;
  TUSubsequence r_5 = p_rb;
  TUSubsequence r_6 = p_rrb;
  mfeanswer ret_left = mldlr_r_l(l_0, l_1, l_2, l_3, l_4, l_5, l_6);
  pfanswer ret_right = mldlr_r_r(r_0, r_1, r_2, r_3, r_4, r_5, r_6);
  std::pair<mfeanswer, pfanswer>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfeanswer, pfanswer>  hishapeh_mfe_pfx::mldr_r(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const std::pair<mfeanswer, pfanswer> & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb, const TUSubsequence & p_rrb)
{
  TUSubsequence l_0 = p_llb;
  TUSubsequence l_1 = p_lb;
  mfeanswer l_2 = p_e.first;
  TUSubsequence l_3 = p_dr;
  TUSubsequence l_4 = p_rb;
  TUSubsequence l_5 = p_rrb;
  TUSubsequence r_0 = p_llb;
  TUSubsequence r_1 = p_lb;
  pfanswer r_2 = p_e.second;
  TUSubsequence r_3 = p_dr;
  TUSubsequence r_4 = p_rb;
  TUSubsequence r_5 = p_rrb;
  mfeanswer ret_left = mldr_r_l(l_0, l_1, l_2, l_3, l_4, l_5);
  pfanswer ret_right = mldr_r_r(r_0, r_1, r_2, r_3, r_4, r_5);
  std::pair<mfeanswer, pfanswer>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfeanswer, pfanswer>  hishapeh_mfe_pfx::nil_r(const TUSubsequence & p_loc)
{
  TUSubsequence l_0 = p_loc;
  TUSubsequence r_0 = p_loc;
  mfeanswer ret_left = nil_r_l(l_0);
  pfanswer ret_right = nil_r_r(r_0);
  std::pair<mfeanswer, pfanswer>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfeanswer, pfanswer>  hishapeh_mfe_pfx::nil_Pr_r(const TUSubsequence & p_loc)
{
  TUSubsequence l_0 = p_loc;
  TUSubsequence r_0 = p_loc;
  mfeanswer ret_left = nil_Pr_r_l(l_0);
  pfanswer ret_right = nil_Pr_r_r(r_0);
  std::pair<mfeanswer, pfanswer>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfeanswer, pfanswer>  hishapeh_mfe_pfx::sadd_r(const TUSubsequence & p_lb, const std::pair<mfeanswer, pfanswer> & p_e)
{
  TUSubsequence l_0 = p_lb;
  mfeanswer l_1 = p_e.first;
  TUSubsequence r_0 = p_lb;
  pfanswer r_1 = p_e.second;
  mfeanswer ret_left = sadd_r_l(l_0, l_1);
  pfanswer ret_right = sadd_r_r(r_0, r_1);
  std::pair<mfeanswer, pfanswer>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfeanswer, pfanswer>  hishapeh_mfe_pfx::sp_r(const TUSubsequence & p_llb, const TUSubsequence & p_lb, const std::pair<mfeanswer, pfanswer> & p_e, const TUSubsequence & p_rb, const TUSubsequence & p_rrb)
{
  TUSubsequence l_0 = p_llb;
  TUSubsequence l_1 = p_lb;
  mfeanswer l_2 = p_e.first;
  TUSubsequence l_3 = p_rb;
  TUSubsequence l_4 = p_rrb;
  TUSubsequence r_0 = p_llb;
  TUSubsequence r_1 = p_lb;
  pfanswer r_2 = p_e.second;
  TUSubsequence r_3 = p_rb;
  TUSubsequence r_4 = p_rrb;
  mfeanswer ret_left = sp_r_l(l_0, l_1, l_2, l_3, l_4);
  pfanswer ret_right = sp_r_r(r_0, r_1, r_2, r_3, r_4);
  std::pair<mfeanswer, pfanswer>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfeanswer, pfanswer>  hishapeh_mfe_pfx::sr_r(const TUSubsequence & p_lb, const std::pair<mfeanswer, pfanswer> & p_e, const TUSubsequence & p_rb)
{
  TUSubsequence l_0 = p_lb;
  mfeanswer l_1 = p_e.first;
  TUSubsequence l_2 = p_rb;
  TUSubsequence r_0 = p_lb;
  pfanswer r_1 = p_e.second;
  TUSubsequence r_2 = p_rb;
  mfeanswer ret_left = sr_r_l(l_0, l_1, l_2);
  pfanswer ret_right = sr_r_r(r_0, r_1, r_2);
  std::pair<mfeanswer, pfanswer>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfeanswer, pfanswer>  hishapeh_mfe_pfx::ssadd_r(const TUSubsequence & p_lb, const std::pair<mfeanswer, pfanswer> & p_e)
{
  TUSubsequence l_0 = p_lb;
  mfeanswer l_1 = p_e.first;
  TUSubsequence r_0 = p_lb;
  pfanswer r_1 = p_e.second;
  mfeanswer ret_left = ssadd_r_l(l_0, l_1);
  pfanswer ret_right = ssadd_r_r(r_0, r_1);
  std::pair<mfeanswer, pfanswer>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfeanswer, pfanswer>  hishapeh_mfe_pfx::trafo_r(const std::pair<mfeanswer, pfanswer> & p_e)
{
  mfeanswer l_0 = p_e.first;
  pfanswer r_0 = p_e.second;
  mfeanswer ret_left = trafo_r_l(l_0);
  pfanswer ret_right = trafo_r_r(r_0);
  std::pair<mfeanswer, pfanswer>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}



mfeanswer hishapeh_mfe_pfx::acomb_r_l(const mfeanswer & le, const TUSubsequence & b, const mfeanswer & re)
{
#line 2388 "hishapes.gap"
  mfeanswer res;
  res.energy = ((le.energy + re.energy) + min(dr_energy(le.lastStem, le.lastStem), dl_energy(re.firstStem, re.firstStem)));
  res.firstStem = le.firstStem;
  res.lastStem = re.lastStem;
  return res;
#line 4233 "hishapeh_mfe_pfx.cc"
}

mfeanswer hishapeh_mfe_pfx::addss_r_l(const mfeanswer & e, const TUSubsequence & rb)
{
#line 2348 "hishapes.gap"
  mfeanswer res;
  res.energy = (e.energy + ss_energy(rb));
  res.firstStem = e.firstStem;
  res.lastStem = e.lastStem;
  return res;
#line 4244 "hishapeh_mfe_pfx.cc"
}

mfeanswer hishapeh_mfe_pfx::ambd_r_l(const mfeanswer & le, const TUSubsequence & b, const mfeanswer & re)
{
#line 2077 "hishapes.gap"
  mfeanswer res;
  res.energy = ((le.energy + re.energy) + min(dr_energy(le.firstStem, le.firstStem), dl_energy(re.firstStem, re.firstStem)));
  res.firstStem = le.firstStem;
  return res;
#line 4254 "hishapeh_mfe_pfx.cc"
}

mfeanswer hishapeh_mfe_pfx::ambd_Pr_r_l(const mfeanswer & le, const TUSubsequence & b, const mfeanswer & re)
{
#line 2084 "hishapes.gap"
  mfeanswer res;
  res.energy = ((le.energy + re.energy) + min(dr_energy(le.firstStem, le.firstStem), dl_energy(re.firstStem, re.firstStem)));
  res.firstStem = le.firstStem;
  return res;
#line 4264 "hishapeh_mfe_pfx.cc"
}

mfeanswer hishapeh_mfe_pfx::bl_r_l(const TUSubsequence & lregion, const mfeanswer & e)
{
#line 2173 "hishapes.gap"
  mfeanswer res;
  res.firstStem.seq = lregion.seq;
  res.firstStem.i = lregion.i;
  res.firstStem.j = e.firstStem.j;
  TUSubsequence innerstem;
  innerstem.seq = lregion.seq;
  innerstem.i = (lregion.i - 1);
  innerstem.j = (e.firstStem.j + 1);
  res.energy = (e.energy + bl_energy(lregion, innerstem));
  return res;
#line 4280 "hishapeh_mfe_pfx.cc"
}

mfeanswer hishapeh_mfe_pfx::br_r_l(const mfeanswer & e, const TUSubsequence & rregion)
{
#line 2188 "hishapes.gap"
  mfeanswer res;
  res.firstStem.seq = rregion.seq;
  res.firstStem.i = e.firstStem.i;
  res.firstStem.j = rregion.j;
  TUSubsequence innerstem;
  innerstem.seq = rregion.seq;
  innerstem.i = (e.firstStem.i - 1);
  innerstem.j = (rregion.j + 1);
  res.energy = (e.energy + br_energy(innerstem, rregion));
  return res;
#line 4296 "hishapeh_mfe_pfx.cc"
}

mfeanswer hishapeh_mfe_pfx::cadd_r_l(const mfeanswer & le, const mfeanswer & re)
{
#line 2049 "hishapes.gap"
  mfeanswer res;
  res.energy = (le.energy + re.energy);
  res.firstStem = le.firstStem;
  return res;
#line 4306 "hishapeh_mfe_pfx.cc"
}

mfeanswer hishapeh_mfe_pfx::cadd_Pr_r_l(const mfeanswer & le, const mfeanswer & re)
{
#line 2056 "hishapes.gap"
  mfeanswer res;
  res.energy = (le.energy + re.energy);
  res.firstStem = le.firstStem;
  return res;
#line 4316 "hishapeh_mfe_pfx.cc"
}

mfeanswer hishapeh_mfe_pfx::cadd_Pr_Pr_r_l(const mfeanswer & le, const mfeanswer & re)
{
#line 2063 "hishapes.gap"
  mfeanswer res;
  res.energy = (le.energy + re.energy);
  res.firstStem = le.firstStem;
  return res;
#line 4326 "hishapeh_mfe_pfx.cc"
}

mfeanswer hishapeh_mfe_pfx::cadd_Pr_Pr_Pr_r_l(const mfeanswer & le, const mfeanswer & re)
{
#line 2070 "hishapes.gap"
  mfeanswer res;
  res.energy = (le.energy + re.energy);
  res.firstStem = le.firstStem;
  return res;
#line 4336 "hishapeh_mfe_pfx.cc"
}

mfeanswer hishapeh_mfe_pfx::combine_r_l(const mfeanswer & le, const mfeanswer & re)
{
#line 2379 "hishapes.gap"
  mfeanswer res;
  res.energy = (le.energy + re.energy);
  res.firstStem = le.firstStem;
  res.lastStem = re.lastStem;
  return res;
#line 4347 "hishapeh_mfe_pfx.cc"
}

mfeanswer hishapeh_mfe_pfx::drem_r_l(const mfeanswer & e)
{
#line 2126 "hishapes.gap"
  return e;
#line 4354 "hishapeh_mfe_pfx.cc"
}

mfeanswer hishapeh_mfe_pfx::edl_r_l(const TUSubsequence & lb, const mfeanswer & e)
{
#line 2105 "hishapes.gap"
  mfeanswer res;
  res.energy = (e.energy + dl_energy(e.firstStem, e.firstStem));
  res.firstStem = e.firstStem;
  return res;
#line 4364 "hishapeh_mfe_pfx.cc"
}

mfeanswer hishapeh_mfe_pfx::edlr_r_l(const TUSubsequence & lb, const mfeanswer & e, const TUSubsequence & rb)
{
#line 2119 "hishapes.gap"
  mfeanswer res;
  res.energy = (e.energy + ext_mismatch_energy(e.firstStem, e.firstStem));
  res.firstStem = e.firstStem;
  return res;
#line 4374 "hishapeh_mfe_pfx.cc"
}

mfeanswer hishapeh_mfe_pfx::edr_r_l(const mfeanswer & e, const TUSubsequence & rb)
{
#line 2112 "hishapes.gap"
  mfeanswer res;
  res.energy = (e.energy + dr_energy(e.firstStem, e.firstStem));
  res.firstStem = e.firstStem;
  return res;
#line 4384 "hishapeh_mfe_pfx.cc"
}

mfeanswer hishapeh_mfe_pfx::hl_r_l(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & region, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 2148 "hishapes.gap"
  mfeanswer res;
  res.firstStem.seq = llb.seq;
  res.firstStem.i = llb.i;
  res.firstStem.j = rrb.j;
  TUSubsequence innerstem;
  innerstem.seq = lb.seq;
  innerstem.i = lb.i;
  innerstem.j = rb.j;
  res.energy = (hl_energy(region) + sr_energy(res.firstStem, res.firstStem));
  return res;
#line 4400 "hishapeh_mfe_pfx.cc"
}

mfeanswer hishapeh_mfe_pfx::il_r_l(const TUSubsequence & lregion, const mfeanswer & e, const TUSubsequence & rregion)
{
#line 2203 "hishapes.gap"
  mfeanswer res;
  res.firstStem.seq = lregion.seq;
  res.firstStem.i = lregion.i;
  res.firstStem.j = rregion.j;
  res.energy = (e.energy + il_energy(lregion, rregion));
  return res;
#line 4412 "hishapeh_mfe_pfx.cc"
}

mfeanswer hishapeh_mfe_pfx::incl_r_l(const mfeanswer & e)
{
#line 2370 "hishapes.gap"
  mfeanswer res;
  res.energy = (ul_energy() + e.energy);
  res.firstStem = e.firstStem;
  res.lastStem = e.firstStem;
  return res;
#line 4423 "hishapeh_mfe_pfx.cc"
}

mfeanswer hishapeh_mfe_pfx::is_r_l(const mfeanswer & e)
{
#line 2130 "hishapes.gap"
  mfeanswer res;
  res.energy = (e.energy + termau_energy(e.firstStem, e.firstStem));
  res.firstStem = e.firstStem;
  return res;
#line 4433 "hishapeh_mfe_pfx.cc"
}

mfeanswer hishapeh_mfe_pfx::ml_r_l(const TUSubsequence & llb, const TUSubsequence & lb, const mfeanswer & e, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 2213 "hishapes.gap"
  mfeanswer res;
  res.firstStem.seq = llb.seq;
  res.firstStem.i = llb.i;
  res.firstStem.j = rrb.j;
  TUSubsequence innerstem;
  innerstem.seq = lb.seq;
  innerstem.i = lb.i;
  innerstem.j = rb.j;
  res.energy = ((((ml_energy() + ul_energy()) + e.energy) + sr_energy(res.firstStem, res.firstStem)) + termau_energy(innerstem, innerstem));
  return res;
#line 4449 "hishapeh_mfe_pfx.cc"
}

mfeanswer hishapeh_mfe_pfx::mladl_r_l(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const mfeanswer & e, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 2333 "hishapes.gap"
  mfeanswer res;
  res.firstStem.seq = llb.seq;
  res.firstStem.i = llb.i;
  res.firstStem.j = rrb.j;
  TUSubsequence innerstem;
  innerstem.seq = lb.seq;
  innerstem.i = lb.i;
  innerstem.j = rb.j;
  res.energy = (((((ml_energy() + ul_energy()) + e.energy) + min(dli_energy(innerstem, innerstem), dl_energy(e.firstStem, e.firstStem))) + sr_energy(res.firstStem, res.firstStem)) + termau_energy(innerstem, innerstem));
  return res;
#line 4465 "hishapeh_mfe_pfx.cc"
}

mfeanswer hishapeh_mfe_pfx::mladldr_r_l(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const mfeanswer & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 2303 "hishapes.gap"
  mfeanswer res;
  res.firstStem.seq = llb.seq;
  res.firstStem.i = llb.i;
  res.firstStem.j = rrb.j;
  TUSubsequence innerstem;
  innerstem.seq = lb.seq;
  innerstem.i = lb.i;
  innerstem.j = rb.j;
  res.energy = ((((((ml_energy() + ul_energy()) + e.energy) + min(dli_energy(innerstem, innerstem), dl_energy(e.firstStem, e.firstStem))) + dri_energy(innerstem, innerstem)) + sr_energy(res.firstStem, res.firstStem)) + termau_energy(innerstem, innerstem));
  return res;
#line 4481 "hishapeh_mfe_pfx.cc"
}

mfeanswer hishapeh_mfe_pfx::mladlr_r_l(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const mfeanswer & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 2273 "hishapes.gap"
  mfeanswer res;
  res.firstStem.seq = llb.seq;
  res.firstStem.i = llb.i;
  res.firstStem.j = rrb.j;
  TUSubsequence innerstem;
  innerstem.seq = lb.seq;
  innerstem.i = lb.i;
  innerstem.j = rb.j;
  res.energy = ((((((ml_energy() + ul_energy()) + e.energy) + min(dli_energy(innerstem, innerstem), dl_energy(e.firstStem, e.firstStem))) + min(dri_energy(innerstem, innerstem), dr_energy(e.lastStem, e.lastStem))) + sr_energy(res.firstStem, res.firstStem)) + termau_energy(innerstem, innerstem));
  return res;
#line 4497 "hishapeh_mfe_pfx.cc"
}

mfeanswer hishapeh_mfe_pfx::mladr_r_l(const TUSubsequence & llb, const TUSubsequence & lb, const mfeanswer & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 2243 "hishapes.gap"
  mfeanswer res;
  res.firstStem.seq = llb.seq;
  res.firstStem.i = llb.i;
  res.firstStem.j = rrb.j;
  TUSubsequence innerstem;
  innerstem.seq = lb.seq;
  innerstem.i = lb.i;
  innerstem.j = rb.j;
  res.energy = (((((ml_energy() + ul_energy()) + e.energy) + min(dri_energy(innerstem, innerstem), dr_energy(e.lastStem, e.lastStem))) + sr_energy(res.firstStem, res.firstStem)) + termau_energy(innerstem, innerstem));
  return res;
#line 4513 "hishapeh_mfe_pfx.cc"
}

mfeanswer hishapeh_mfe_pfx::mldl_r_l(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const mfeanswer & e, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 2318 "hishapes.gap"
  mfeanswer res;
  res.firstStem.seq = llb.seq;
  res.firstStem.i = llb.i;
  res.firstStem.j = rrb.j;
  TUSubsequence innerstem;
  innerstem.seq = lb.seq;
  innerstem.i = lb.i;
  innerstem.j = rb.j;
  res.energy = (((((ml_energy() + ul_energy()) + e.energy) + dli_energy(innerstem, innerstem)) + sr_energy(res.firstStem, res.firstStem)) + termau_energy(innerstem, innerstem));
  return res;
#line 4529 "hishapeh_mfe_pfx.cc"
}

mfeanswer hishapeh_mfe_pfx::mldladr_r_l(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const mfeanswer & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 2288 "hishapes.gap"
  mfeanswer res;
  res.firstStem.seq = llb.seq;
  res.firstStem.i = llb.i;
  res.firstStem.j = rrb.j;
  TUSubsequence innerstem;
  innerstem.seq = lb.seq;
  innerstem.i = lb.i;
  innerstem.j = rb.j;
  res.energy = ((((((ml_energy() + ul_energy()) + e.energy) + dli_energy(innerstem, innerstem)) + min(dri_energy(innerstem, innerstem), dr_energy(e.lastStem, e.lastStem))) + sr_energy(res.firstStem, res.firstStem)) + termau_energy(innerstem, innerstem));
  return res;
#line 4545 "hishapeh_mfe_pfx.cc"
}

mfeanswer hishapeh_mfe_pfx::mldlr_r_l(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const mfeanswer & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 2258 "hishapes.gap"
  mfeanswer res;
  res.firstStem.seq = llb.seq;
  res.firstStem.i = llb.i;
  res.firstStem.j = rrb.j;
  TUSubsequence innerstem;
  innerstem.seq = lb.seq;
  innerstem.i = lb.i;
  innerstem.j = rb.j;
  res.energy = (((((ml_energy() + ul_energy()) + e.energy) + ml_mismatch_energy(innerstem, innerstem)) + sr_energy(res.firstStem, res.firstStem)) + termau_energy(innerstem, innerstem));
  return res;
#line 4561 "hishapeh_mfe_pfx.cc"
}

mfeanswer hishapeh_mfe_pfx::mldr_r_l(const TUSubsequence & llb, const TUSubsequence & lb, const mfeanswer & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 2228 "hishapes.gap"
  mfeanswer res;
  res.firstStem.seq = llb.seq;
  res.firstStem.i = llb.i;
  res.firstStem.j = rrb.j;
  TUSubsequence innerstem;
  innerstem.seq = lb.seq;
  innerstem.i = lb.i;
  innerstem.j = rb.j;
  res.energy = (((((ml_energy() + ul_energy()) + e.energy) + dri_energy(innerstem, innerstem)) + sr_energy(res.firstStem, res.firstStem)) + termau_energy(innerstem, innerstem));
  return res;
#line 4577 "hishapeh_mfe_pfx.cc"
}

mfeanswer hishapeh_mfe_pfx::nil_r_l(const TUSubsequence & loc)
{
#line 2091 "hishapes.gap"
  mfeanswer res;
  res.energy = 0;
  res.firstStem = loc;
  return res;
#line 4587 "hishapeh_mfe_pfx.cc"
}

mfeanswer hishapeh_mfe_pfx::nil_Pr_r_l(const TUSubsequence & loc)
{
#line 2098 "hishapes.gap"
  mfeanswer res;
  res.energy = 0;
  res.firstStem = loc;
  return res;
#line 4597 "hishapeh_mfe_pfx.cc"
}

mfeanswer hishapeh_mfe_pfx::sadd_r_l(const TUSubsequence & lb, const mfeanswer & e)
{
#line 2040 "hishapes.gap"
  mfeanswer res;
  res.energy = e.energy;
  res.firstStem.seq = lb.seq;
  res.firstStem.i = lb.i;
  res.firstStem.j = e.firstStem.j;
  return res;
#line 4609 "hishapeh_mfe_pfx.cc"
}

mfeanswer hishapeh_mfe_pfx::sp_r_l(const TUSubsequence & llb, const TUSubsequence & lb, const mfeanswer & e, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 2163 "hishapes.gap"
  mfeanswer res;
  res.firstStem.seq = llb.seq;
  res.firstStem.i = llb.i;
  res.firstStem.j = rrb.j;
  res.energy = (e.energy + sr_energy(res.firstStem, res.firstStem));
  return res;
#line 4621 "hishapeh_mfe_pfx.cc"
}

mfeanswer hishapeh_mfe_pfx::sr_r_l(const TUSubsequence & lb, const mfeanswer & e, const TUSubsequence & rb)
{
#line 2138 "hishapes.gap"
  mfeanswer res;
  res.firstStem.seq = lb.seq;
  res.firstStem.i = lb.i;
  res.firstStem.j = rb.j;
  res.energy = (e.energy + sr_energy(res.firstStem, res.firstStem));
  return res;
#line 4633 "hishapeh_mfe_pfx.cc"
}

mfeanswer hishapeh_mfe_pfx::ssadd_r_l(const TUSubsequence & lb, const mfeanswer & e)
{
#line 2357 "hishapes.gap"
  mfeanswer res;
  res.energy = ((ul_energy() + e.energy) + ss_energy(lb));
  res.firstStem = e.firstStem;
  res.lastStem = e.firstStem;
  return res;
#line 4644 "hishapeh_mfe_pfx.cc"
}

mfeanswer hishapeh_mfe_pfx::trafo_r_l(const mfeanswer & e)
{
#line 2366 "hishapes.gap"
  return e;
#line 4651 "hishapeh_mfe_pfx.cc"
}



pfanswer hishapeh_mfe_pfx::acomb_r_r(const pfanswer & le, const TUSubsequence & b, const pfanswer & re)
{
#line 1970 "hishapes.gap"
  pfanswer res = le;
  res.firststem = le.firststem;
  base_t baseLeftStem = base_t(le.firststem[(b.i - 1)]);
  base_t baseRightStem = base_t(re.firststem[(b.i + 1)]);
  base_t baseAmbigious = base_t(b[b.i]);
  double wcDr = dr_dangle_dg(wc_comp(baseLeftStem), baseLeftStem, baseAmbigious);
  double wobDr = dr_dangle_dg(wob_comp(baseLeftStem), baseLeftStem, baseAmbigious);
  double wcDl = dl_dangle_dg(baseAmbigious, baseRightStem, wc_comp(baseRightStem));
  double wobDl = dl_dangle_dg(baseAmbigious, baseRightStem, wob_comp(baseRightStem));
  res.pf.q1 = ((le.pf.q1 *  ( ((re.pf.q1 * mk_pf(min(wcDr, wcDl))) + (re.pf.q3 * mk_pf(min(wcDr, wobDl)))) ) ) + (le.pf.q2 *  ( ((re.pf.q1 * mk_pf(min(wobDr, wcDl))) + (re.pf.q3 * mk_pf(min(wobDr, wobDl)))) ) ));
  res.pf.q2 = ((le.pf.q2 *  ( ((re.pf.q2 * mk_pf(min(wobDr, wcDl))) + (re.pf.q4 * mk_pf(min(wobDr, wobDl)))) ) ) + (le.pf.q1 *  ( ((re.pf.q2 * mk_pf(min(wcDr, wcDl))) + (re.pf.q4 * mk_pf(min(wcDr, wobDl)))) ) ));
  res.pf.q3 = ((le.pf.q3 *  ( ((re.pf.q3 * mk_pf(min(wcDr, wobDl))) + (re.pf.q1 * mk_pf(min(wcDr, wcDl)))) ) ) + (le.pf.q4 *  ( ((re.pf.q3 * mk_pf(min(wobDr, wobDl))) + (re.pf.q1 * mk_pf(min(wobDr, wcDl)))) ) ));
  res.pf.q4 = ((le.pf.q4 *  ( ((re.pf.q4 * mk_pf(min(wobDr, wobDl))) + (re.pf.q2 * mk_pf(min(wobDr, wcDl)))) ) ) + (le.pf.q3 *  ( ((re.pf.q4 * mk_pf(min(wcDr, wobDl))) + (re.pf.q2 * mk_pf(min(wcDr, wcDl)))) ) ));
  res.pf.q1 = (res.pf.q1 * scale(1));
  res.pf.q2 = (res.pf.q2 * scale(1));
  res.pf.q3 = (res.pf.q3 * scale(1));
  res.pf.q4 = (res.pf.q4 * scale(1));
  return res;
#line 4677 "hishapeh_mfe_pfx.cc"
}

pfanswer hishapeh_mfe_pfx::addss_r_r(const pfanswer & e, const TUSubsequence & rregion)
{
#line 1917 "hishapes.gap"
  pfanswer res = e;
  res.pf = mult_tup((scale((rregion.j - rregion.i)) * mk_pf(ss_energy(rregion))), e.pf);
  return res;
#line 4686 "hishapeh_mfe_pfx.cc"
}

pfanswer hishapeh_mfe_pfx::ambd_r_r(const pfanswer & le, const TUSubsequence & b, const pfanswer & re)
{
#line 1519 "hishapes.gap"
  pfanswer res = le;
  res.pf.q1 = (scale(1) * check_tuple(le.pf.q1, le.firststem, re.firststem, b, re.pf));
  res.pf.q2 = 0.000000e+00;
  res.pf.q3 = 0.000000e+00;
  res.pf.q4 = 0.000000e+00;
  return res;
#line 4698 "hishapeh_mfe_pfx.cc"
}

pfanswer hishapeh_mfe_pfx::ambd_Pr_r_r(const pfanswer & le, const TUSubsequence & b, const pfanswer & re)
{
#line 1530 "hishapes.gap"
  pfanswer res = le;
  res.pf = mk_tuple(le.firststem, (scale(1) * check_tuple(le.pf.q1, le.firststem, re.firststem, b, re.pf)));
  return res;
#line 4707 "hishapeh_mfe_pfx.cc"
}

pfanswer hishapeh_mfe_pfx::bl_r_r(const TUSubsequence & lregion, const pfanswer & e)
{
#line 1662 "hishapes.gap"
  pfanswer res = e;
  res.firststem.i = lregion.i;
  TUSubsequence innerstem;
  innerstem.seq = lregion.seq;
  innerstem.i = (lregion.i - 1);
  innerstem.j = (e.firststem.j + 1);
  res.pf.q1 = ((scale((lregion.j - lregion.i)) * e.pf.q1) * mk_pf(bl_energy(lregion, innerstem)));
  res.pf.q2 = 0.000000e+00;
  res.pf.q3 = 0.000000e+00;
  res.pf.q4 = 0.000000e+00;
  return res;
#line 4724 "hishapeh_mfe_pfx.cc"
}

pfanswer hishapeh_mfe_pfx::br_r_r(const pfanswer & e, const TUSubsequence & rregion)
{
#line 1680 "hishapes.gap"
  pfanswer res = e;
  res.firststem.j = rregion.j;
  TUSubsequence innerstem;
  innerstem.seq = rregion.seq;
  innerstem.i = (e.firststem.i - 1);
  innerstem.j = (rregion.j + 1);
  res.pf.q1 = ((scale((rregion.j - rregion.i)) * e.pf.q1) * mk_pf(br_energy(innerstem, rregion)));
  res.pf.q2 = 0.000000e+00;
  res.pf.q3 = 0.000000e+00;
  res.pf.q4 = 0.000000e+00;
  return res;
#line 4741 "hishapeh_mfe_pfx.cc"
}

pfanswer hishapeh_mfe_pfx::cadd_r_r(const pfanswer & le, const pfanswer & re)
{
#line 1481 "hishapes.gap"
  pfanswer res = le;
  res.pf.q1 = (le.pf.q1 * re.pf.q1);
  res.pf.q2 = 0.000000e+00;
  res.pf.q3 = 0.000000e+00;
  res.pf.q4 = 0.000000e+00;
  return res;
#line 4753 "hishapeh_mfe_pfx.cc"
}

pfanswer hishapeh_mfe_pfx::cadd_Pr_r_r(const pfanswer & le, const pfanswer & re)
{
#line 1492 "hishapes.gap"
  pfanswer res = le;
  res.pf.q1 = (le.pf.q1 * sum_elems(re.pf));
  res.pf.q2 = 0.000000e+00;
  res.pf.q3 = 0.000000e+00;
  res.pf.q4 = 0.000000e+00;
  return res;
#line 4765 "hishapeh_mfe_pfx.cc"
}

pfanswer hishapeh_mfe_pfx::cadd_Pr_Pr_r_r(const pfanswer & le, const pfanswer & re)
{
#line 1503 "hishapes.gap"
  pfanswer res = le;
  res.pf = mk_tuple(le.firststem, (le.pf.q1 * re.pf.q1));
  return res;
#line 4774 "hishapeh_mfe_pfx.cc"
}

pfanswer hishapeh_mfe_pfx::cadd_Pr_Pr_Pr_r_r(const pfanswer & le, const pfanswer & re)
{
#line 1511 "hishapes.gap"
  pfanswer res = le;
  res.pf = mk_tuple(le.firststem, (le.pf.q1 * sum_elems(re.pf)));
  return res;
#line 4783 "hishapeh_mfe_pfx.cc"
}

pfanswer hishapeh_mfe_pfx::combine_r_r(const pfanswer & le, const pfanswer & re)
{
#line 1957 "hishapes.gap"
  pfanswer res = le;
  res.firststem = le.firststem;
  res.pf.q1 = ( ( (le.pf.q1 + le.pf.q2) )  *  ( (re.pf.q1 + re.pf.q3) ) );
  res.pf.q2 = ( ( (le.pf.q1 + le.pf.q2) )  *  ( (re.pf.q2 + re.pf.q4) ) );
  res.pf.q3 = ( ( (le.pf.q3 + le.pf.q4) )  *  ( (re.pf.q3 + re.pf.q1) ) );
  res.pf.q4 = ( ( (le.pf.q4 + le.pf.q3) )  *  ( (re.pf.q4 + re.pf.q2) ) );
  return res;
#line 4796 "hishapeh_mfe_pfx.cc"
}

pfanswer hishapeh_mfe_pfx::drem_r_r(const pfanswer & e)
{
#line 1599 "hishapes.gap"
  return e;
#line 4803 "hishapeh_mfe_pfx.cc"
}

pfanswer hishapeh_mfe_pfx::edl_r_r(const TUSubsequence & lb, const pfanswer & e)
{
#line 1566 "hishapes.gap"
  pfanswer res = e;
  res.pf.q1 = ((scale(1) * e.pf.q1) * mk_pf(dl_energy(e.firststem, e.firststem)));
  res.pf.q2 = 0.000000e+00;
  res.pf.q3 = 0.000000e+00;
  res.pf.q4 = 0.000000e+00;
  return res;
#line 4815 "hishapeh_mfe_pfx.cc"
}

pfanswer hishapeh_mfe_pfx::edlr_r_r(const TUSubsequence & lb, const pfanswer & e, const TUSubsequence & rb)
{
#line 1588 "hishapes.gap"
  pfanswer res = e;
  res.pf.q1 = ((scale(2) * e.pf.q1) * mk_pf(ext_mismatch_energy(e.firststem, e.firststem)));
  res.pf.q2 = 0.000000e+00;
  res.pf.q3 = 0.000000e+00;
  res.pf.q4 = 0.000000e+00;
  return res;
#line 4827 "hishapeh_mfe_pfx.cc"
}

pfanswer hishapeh_mfe_pfx::edr_r_r(const pfanswer & e, const TUSubsequence & rb)
{
#line 1577 "hishapes.gap"
  pfanswer res = e;
  res.pf.q1 = ((scale(1) * e.pf.q1) * mk_pf(dr_energy(e.firststem, e.firststem)));
  res.pf.q2 = 0.000000e+00;
  res.pf.q3 = 0.000000e+00;
  res.pf.q4 = 0.000000e+00;
  return res;
#line 4839 "hishapeh_mfe_pfx.cc"
}

pfanswer hishapeh_mfe_pfx::hl_r_r(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & region, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 1628 "hishapes.gap"
  pfanswer res;
  res.firststem.seq = llb.seq;
  res.firststem.i = llb.i;
  res.firststem.j = rrb.j;
  TUSubsequence innerstem;
  innerstem.seq = lb.seq;
  innerstem.i = lb.i;
  innerstem.j = rb.j;
  res.pf.q1 = (scale(((region.j - region.i) + 4)) * mk_pf((hl_energy(region) + sr_energy(res.firststem, res.firststem))));
  res.pf.q2 = 0.000000e+00;
  res.pf.q3 = 0.000000e+00;
  res.pf.q4 = 0.000000e+00;
  return res;
#line 4858 "hishapeh_mfe_pfx.cc"
}

pfanswer hishapeh_mfe_pfx::il_r_r(const TUSubsequence & lregion, const pfanswer & e, const TUSubsequence & rregion)
{
#line 1698 "hishapes.gap"
  pfanswer res = e;
  res.firststem.i = lregion.i;
  res.firststem.j = rregion.j;
  res.pf.q1 = ((scale(( ( (lregion.j - lregion.i) )  +  ( (rregion.j - rregion.i) ) )) * e.pf.q1) * mk_pf(il_energy(lregion, rregion)));
  res.pf.q2 = 0.000000e+00;
  res.pf.q3 = 0.000000e+00;
  res.pf.q4 = 0.000000e+00;
  return res;
#line 4872 "hishapeh_mfe_pfx.cc"
}

pfanswer hishapeh_mfe_pfx::incl_r_r(const pfanswer & e)
{
#line 1949 "hishapes.gap"
  pfanswer res = e;
  res.pf = mk_tuple(e.firststem, (e.pf.q1 * mk_pf(ul_energy())));
  return res;
#line 4881 "hishapeh_mfe_pfx.cc"
}

pfanswer hishapeh_mfe_pfx::is_r_r(const pfanswer & e)
{
#line 1603 "hishapes.gap"
  pfanswer res = e;
  res.pf.q1 = (e.pf.q1 * mk_pf(termau_energy(e.firststem, e.firststem)));
  res.pf.q2 = 0.000000e+00;
  res.pf.q3 = 0.000000e+00;
  res.pf.q4 = 0.000000e+00;
  return res;
#line 4893 "hishapeh_mfe_pfx.cc"
}

pfanswer hishapeh_mfe_pfx::ml_r_r(const TUSubsequence & llb, const TUSubsequence & lb, const pfanswer & e, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 1712 "hishapes.gap"
  pfanswer res = e;
  res.firststem.i = llb.i;
  res.firststem.j = rrb.j;
  TUSubsequence innerstem;
  innerstem.seq = lb.seq;
  innerstem.i = lb.i;
  innerstem.j = rb.j;
  res.pf.q1 = ((scale(4) * sum_elems(e.pf)) * mk_pf((((ml_energy() + ul_energy()) + sr_energy(res.firststem, res.firststem)) + termau_energy(innerstem, innerstem))));
  res.pf.q2 = 0.000000e+00;
  res.pf.q3 = 0.000000e+00;
  res.pf.q4 = 0.000000e+00;
  return res;
#line 4911 "hishapeh_mfe_pfx.cc"
}

pfanswer hishapeh_mfe_pfx::mladl_r_r(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const pfanswer & e, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 1892 "hishapes.gap"
  pfanswer res = e;
  res.firststem.i = llb.i;
  res.firststem.j = rrb.j;
  TUSubsequence innerstem;
  innerstem.seq = lb.seq;
  innerstem.i = lb.i;
  innerstem.j = rb.j;
  base_t leftdanglingBase = base_t(dl[dl.i]);
  base_t leftmostBasefirstStem = base_t(e.firststem[(dl.i + 1)]);
  double amdangle;
  amdangle = (( ( (e.pf.q1 + e.pf.q2) )  * mk_pf(min(dl_dangle_dg(leftdanglingBase, leftmostBasefirstStem, wc_comp(leftmostBasefirstStem)), dli_energy(innerstem, innerstem)))) + ( ( (e.pf.q3 + e.pf.q4) )  * mk_pf(min(dl_dangle_dg(leftdanglingBase, leftmostBasefirstStem, wob_comp(leftmostBasefirstStem)), dli_energy(innerstem, innerstem)))));
  res.pf.q1 = ((scale(5) * amdangle) * mk_pf((((ml_energy() + ul_energy()) + sr_energy(res.firststem, res.firststem)) + termau_energy(innerstem, innerstem))));
  res.pf.q2 = 0.000000e+00;
  res.pf.q3 = 0.000000e+00;
  res.pf.q4 = 0.000000e+00;
  return res;
#line 4933 "hishapeh_mfe_pfx.cc"
}

pfanswer hishapeh_mfe_pfx::mladldr_r_r(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const pfanswer & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 1848 "hishapes.gap"
  pfanswer res = e;
  res.firststem.i = llb.i;
  res.firststem.j = rrb.j;
  TUSubsequence innerstem;
  innerstem.seq = lb.seq;
  innerstem.i = lb.i;
  innerstem.j = rb.j;
  base_t leftdanglingBase = base_t(dl[dl.i]);
  base_t leftmostBasefirstStem = base_t(e.firststem[(dl.i + 1)]);
  double amdangle;
  amdangle = (( ( (e.pf.q1 + e.pf.q2) )  * mk_pf(min(dl_dangle_dg(leftdanglingBase, leftmostBasefirstStem, wc_comp(leftmostBasefirstStem)), dli_energy(innerstem, innerstem)))) + ( ( (e.pf.q3 + (e.pf.q4 * mk_pf(dri_energy(innerstem, innerstem)))) )  * mk_pf(min(dl_dangle_dg(leftdanglingBase, leftmostBasefirstStem, wob_comp(leftmostBasefirstStem)), dli_energy(innerstem, innerstem)))));
  res.pf.q1 = ((scale(6) * amdangle) * mk_pf((((ml_energy() + ul_energy()) + sr_energy(res.firststem, res.firststem)) + termau_energy(innerstem, innerstem))));
  res.pf.q2 = 0.000000e+00;
  res.pf.q3 = 0.000000e+00;
  res.pf.q4 = 0.000000e+00;
  return res;
#line 4955 "hishapeh_mfe_pfx.cc"
}

pfanswer hishapeh_mfe_pfx::mladlr_r_r(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const pfanswer & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 1794 "hishapes.gap"
  pfanswer res = e;
  res.firststem.i = llb.i;
  res.firststem.j = rrb.j;
  TUSubsequence innerstem;
  innerstem.seq = lb.seq;
  innerstem.i = lb.i;
  innerstem.j = rb.j;
  base_t leftdanglingBase = base_t(dl[dl.i]);
  base_t rightdanglingBase = base_t(dr[dr.i]);
  base_t leftmostBasefirstStem = base_t(e.firststem[(dl.i + 1)]);
  base_t rightmostBaselastStem = base_t(e.firststem[(dr.i - 1)]);
  double amdangle;
  amdangle = ((((e.pf.q1 * mk_pf((min(dl_dangle_dg(leftdanglingBase, leftmostBasefirstStem, wc_comp(leftmostBasefirstStem)), dli_energy(innerstem, innerstem)) + min(dr_dangle_dg(wc_comp(rightmostBaselastStem), rightmostBaselastStem, rightdanglingBase), dri_energy(innerstem, innerstem))))) + (e.pf.q2 * mk_pf((min(dl_dangle_dg(leftdanglingBase, leftmostBasefirstStem, wc_comp(leftmostBasefirstStem)), dli_energy(innerstem, innerstem)) + min(dr_dangle_dg(wob_comp(rightmostBaselastStem), rightmostBaselastStem, rightdanglingBase), dri_energy(innerstem, innerstem)))))) + (e.pf.q3 * mk_pf((min(dl_dangle_dg(leftdanglingBase, leftmostBasefirstStem, wob_comp(leftmostBasefirstStem)), dli_energy(innerstem, innerstem)) + min(dr_dangle_dg(wc_comp(rightmostBaselastStem), rightmostBaselastStem, rightdanglingBase), dri_energy(innerstem, innerstem)))))) + (e.pf.q4 * mk_pf((min(dl_dangle_dg(leftdanglingBase, leftmostBasefirstStem, wob_comp(leftmostBasefirstStem)), dli_energy(innerstem, innerstem)) + min(dr_dangle_dg(wob_comp(rightmostBaselastStem), rightmostBaselastStem, rightdanglingBase), dri_energy(innerstem, innerstem))))));
  res.pf.q1 = ((scale(6) * amdangle) * mk_pf((((ml_energy() + ul_energy()) + sr_energy(res.firststem, res.firststem)) + termau_energy(innerstem, innerstem))));
  res.pf.q2 = 0.000000e+00;
  res.pf.q3 = 0.000000e+00;
  res.pf.q4 = 0.000000e+00;
  return res;
#line 4979 "hishapeh_mfe_pfx.cc"
}

pfanswer hishapeh_mfe_pfx::mladr_r_r(const TUSubsequence & llb, const TUSubsequence & lb, const pfanswer & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 1750 "hishapes.gap"
  pfanswer res = e;
  res.firststem.i = llb.i;
  res.firststem.j = rrb.j;
  TUSubsequence innerstem;
  innerstem.seq = lb.seq;
  innerstem.i = lb.i;
  innerstem.j = rb.j;
  base_t rightdanglingBase = base_t(dr[dr.i]);
  base_t rightmostBaselastStem = base_t(e.firststem[(dr.i - 1)]);
  double amdangle;
  amdangle = (( ( (e.pf.q1 + e.pf.q3) )  * mk_pf(min(dr_dangle_dg(wc_comp(rightmostBaselastStem), rightmostBaselastStem, rightdanglingBase), dri_energy(innerstem, innerstem)))) + ( ( (e.pf.q2 + e.pf.q4) )  * mk_pf(min(dr_dangle_dg(wob_comp(rightmostBaselastStem), rightmostBaselastStem, rightdanglingBase), dri_energy(innerstem, innerstem)))));
  res.pf.q1 = ((scale(5) * amdangle) * mk_pf((((ml_energy() + ul_energy()) + sr_energy(res.firststem, res.firststem)) + termau_energy(innerstem, innerstem))));
  res.pf.q2 = 0.000000e+00;
  res.pf.q3 = 0.000000e+00;
  res.pf.q4 = 0.000000e+00;
  return res;
#line 5001 "hishapeh_mfe_pfx.cc"
}

pfanswer hishapeh_mfe_pfx::mldl_r_r(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const pfanswer & e, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 1873 "hishapes.gap"
  pfanswer res = e;
  res.firststem.i = llb.i;
  res.firststem.j = rrb.j;
  TUSubsequence innerstem;
  innerstem.seq = lb.seq;
  innerstem.i = lb.i;
  innerstem.j = rb.j;
  res.pf.q1 = ((scale(5) * sum_elems(e.pf)) * mk_pf(((((ml_energy() + ul_energy()) + dli_energy(innerstem, innerstem)) + sr_energy(res.firststem, res.firststem)) + termau_energy(innerstem, innerstem))));
  res.pf.q2 = 0.000000e+00;
  res.pf.q3 = 0.000000e+00;
  res.pf.q4 = 0.000000e+00;
  return res;
#line 5019 "hishapeh_mfe_pfx.cc"
}

pfanswer hishapeh_mfe_pfx::mldladr_r_r(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const pfanswer & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 1823 "hishapes.gap"
  pfanswer res = e;
  res.firststem.i = llb.i;
  res.firststem.j = rrb.j;
  TUSubsequence innerstem;
  innerstem.seq = lb.seq;
  innerstem.i = lb.i;
  innerstem.j = rb.j;
  base_t rightdanglingBase = base_t(dr[dr.i]);
  base_t rightmostBaselastStem = base_t(e.firststem[(dr.i - 1)]);
  double amdangle;
  amdangle = (( ( ((e.pf.q1 * mk_pf(dli_energy(innerstem, innerstem))) + e.pf.q3) )  * mk_pf(min(dr_dangle_dg(wc_comp(rightmostBaselastStem), rightmostBaselastStem, rightdanglingBase), dri_energy(innerstem, innerstem)))) + ( ( (e.pf.q2 + e.pf.q4) )  * mk_pf(min(dr_dangle_dg(wob_comp(rightmostBaselastStem), rightmostBaselastStem, rightdanglingBase), dri_energy(innerstem, innerstem)))));
  res.pf.q1 = ((scale(6) * amdangle) * mk_pf((((ml_energy() + ul_energy()) + sr_energy(res.firststem, res.firststem)) + termau_energy(innerstem, innerstem))));
  res.pf.q2 = 0.000000e+00;
  res.pf.q3 = 0.000000e+00;
  res.pf.q4 = 0.000000e+00;
  return res;
#line 5041 "hishapeh_mfe_pfx.cc"
}

pfanswer hishapeh_mfe_pfx::mldlr_r_r(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const pfanswer & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 1775 "hishapes.gap"
  pfanswer res = e;
  res.firststem.i = llb.i;
  res.firststem.j = rrb.j;
  TUSubsequence innerstem;
  innerstem.seq = lb.seq;
  innerstem.i = lb.i;
  innerstem.j = rb.j;
  res.pf.q1 = ((scale(6) * sum_elems(e.pf)) * mk_pf(((((ml_energy() + ul_energy()) + ml_mismatch_energy(innerstem, innerstem)) + sr_energy(res.firststem, res.firststem)) + termau_energy(innerstem, innerstem))));
  res.pf.q2 = 0.000000e+00;
  res.pf.q3 = 0.000000e+00;
  res.pf.q4 = 0.000000e+00;
  return res;
#line 5059 "hishapeh_mfe_pfx.cc"
}

pfanswer hishapeh_mfe_pfx::mldr_r_r(const TUSubsequence & llb, const TUSubsequence & lb, const pfanswer & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 1731 "hishapes.gap"
  pfanswer res = e;
  res.firststem.i = llb.i;
  res.firststem.j = rrb.j;
  TUSubsequence innerstem;
  innerstem.seq = lb.seq;
  innerstem.i = lb.i;
  innerstem.j = rb.j;
  res.pf.q1 = ((scale(5) * sum_elems(e.pf)) * mk_pf(((((ml_energy() + ul_energy()) + dri_energy(innerstem, innerstem)) + sr_energy(res.firststem, res.firststem)) + termau_energy(innerstem, innerstem))));
  res.pf.q2 = 0.000000e+00;
  res.pf.q3 = 0.000000e+00;
  res.pf.q4 = 0.000000e+00;
  return res;
#line 5077 "hishapeh_mfe_pfx.cc"
}

pfanswer hishapeh_mfe_pfx::nil_r_r(const TUSubsequence & loc)
{
#line 1538 "hishapes.gap"
  pfanswer res;
  res.pf.q1 = 1.000000e+00;
  res.pf.q2 = 0.000000e+00;
  res.pf.q3 = 0.000000e+00;
  res.pf.q4 = 0.000000e+00;
  res.firststem.i = seq_size(loc);
  res.firststem.j = seq_size(loc);
  res.firststem.seq = loc.seq;
  return res;
#line 5092 "hishapeh_mfe_pfx.cc"
}

pfanswer hishapeh_mfe_pfx::nil_Pr_r_r(const TUSubsequence & loc)
{
#line 1552 "hishapes.gap"
  pfanswer res;
  res.pf.q1 = 1.000000e+00;
  res.pf.q2 = 0.000000e+00;
  res.pf.q3 = 0.000000e+00;
  res.pf.q4 = 0.000000e+00;
  res.firststem.i = seq_size(loc);
  res.firststem.j = seq_size(loc);
  res.firststem.seq = loc.seq;
  return res;
#line 5107 "hishapeh_mfe_pfx.cc"
}

pfanswer hishapeh_mfe_pfx::sadd_r_r(const TUSubsequence & lb, const pfanswer & e)
{
#line 1470 "hishapes.gap"
  pfanswer res = e;
  res.pf.q1 = (scale(1) * e.pf.q1);
  res.pf.q2 = 0.000000e+00;
  res.pf.q3 = 0.000000e+00;
  res.pf.q4 = 0.000000e+00;
  return res;
#line 5119 "hishapeh_mfe_pfx.cc"
}

pfanswer hishapeh_mfe_pfx::sp_r_r(const TUSubsequence & llb, const TUSubsequence & lb, const pfanswer & e, const TUSubsequence & rb, const TUSubsequence & rrb)
{
#line 1648 "hishapes.gap"
  pfanswer res = e;
  res.firststem.i = llb.i;
  res.firststem.j = rrb.j;
  res.pf.q1 = ((scale(4) * e.pf.q1) * mk_pf(sr_energy(res.firststem, res.firststem)));
  res.pf.q2 = 0.000000e+00;
  res.pf.q3 = 0.000000e+00;
  res.pf.q4 = 0.000000e+00;
  return res;
#line 5133 "hishapeh_mfe_pfx.cc"
}

pfanswer hishapeh_mfe_pfx::sr_r_r(const TUSubsequence & lb, const pfanswer & e, const TUSubsequence & rb)
{
#line 1614 "hishapes.gap"
  pfanswer res = e;
  res.firststem.i = lb.i;
  res.firststem.j = rb.j;
  res.pf.q1 = ((scale(2) * e.pf.q1) * mk_pf(sr_energy(res.firststem, res.firststem)));
  res.pf.q2 = 0.000000e+00;
  res.pf.q3 = 0.000000e+00;
  res.pf.q4 = 0.000000e+00;
  return res;
#line 5147 "hishapeh_mfe_pfx.cc"
}

pfanswer hishapeh_mfe_pfx::ssadd_r_r(const TUSubsequence & lregion, const pfanswer & e)
{
#line 1925 "hishapes.gap"
  pfanswer res = e;
  TUSubsequence test;
  test.seq = lregion.seq;
  test.i = lregion.i;
  test.j = (lregion.j + 1);
  res.pf = mk_tuple(e.firststem, ((scale((lregion.j - lregion.i)) * e.pf.q1) * mk_pf((ul_energy() + ss_energy(lregion)))));
  return res;
#line 5160 "hishapeh_mfe_pfx.cc"
}

pfanswer hishapeh_mfe_pfx::trafo_r_r(const pfanswer & e)
{
#line 1938 "hishapes.gap"
  pfanswer res = e;
  res.pf.q1 = sum_elems(e.pf);
  res.pf.q2 = 0.000000e+00;
  res.pf.q3 = 0.000000e+00;
  res.pf.q4 = 0.000000e+00;
  return res;
#line 5172 "hishapeh_mfe_pfx.cc"
}


    void hishapeh_mfe_pfx::cyk()
{

}



#ident "$Id: Compiled with gapc bellmansgapc-2012.05.07 $"

List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > hishapeh_mfe_pfx::bt_proxy_nt_struct()
{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > l;
  empty(l);
  hishapeh_mfe_pfx_hash_h_h_pfx ret = nt_struct();
  if (is_empty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_struct_Back<hishapeh_mfe_pfx, String, unsigned int>  >  bt = new Backtrace_nt_struct_Back<hishapeh_mfe_pfx, String, unsigned int> (this);
  for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  elem = *elem_itr;
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_struct_Front<String, unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > hishapeh_mfe_pfx::bt_proxy_nt_left_unpaired(unsigned int t_0_i)
{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > l;
  empty(l);
  hishapeh_mfe_pfx_hash_h_h_pfx ret = nt_left_unpaired(t_0_i);
  if (is_empty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_left_unpaired_Back<hishapeh_mfe_pfx, String, unsigned int>  >  bt = new Backtrace_nt_left_unpaired_Back<hishapeh_mfe_pfx, String, unsigned int> (this, t_0_i);
  for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  elem = *elem_itr;
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_left_unpaired_Front<String, unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > hishapeh_mfe_pfx::bt_proxy_nt_left_dangle(unsigned int t_0_i)
{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > l;
  empty(l);
  hishapeh_mfe_pfx_hash_h_h_pfx ret = nt_left_dangle(t_0_i);
  if (is_empty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_left_dangle_Back<hishapeh_mfe_pfx, String, unsigned int>  >  bt = new Backtrace_nt_left_dangle_Back<hishapeh_mfe_pfx, String, unsigned int> (this, t_0_i);
  for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  elem = *elem_itr;
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_left_dangle_Front<String, unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > hishapeh_mfe_pfx::bt_proxy_nt_noleft_dangle(unsigned int t_0_i)
{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > l;
  empty(l);
  hishapeh_mfe_pfx_hash_h_h_pfx ret = nt_noleft_dangle(t_0_i);
  if (is_empty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_noleft_dangle_Back<hishapeh_mfe_pfx, String, unsigned int>  >  bt = new Backtrace_nt_noleft_dangle_Back<hishapeh_mfe_pfx, String, unsigned int> (this, t_0_i);
  for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  elem = *elem_itr;
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_noleft_dangle_Front<String, unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > hishapeh_mfe_pfx::bt_proxy_nt_edanglel_struct(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > l;
  empty(l);
  hishapeh_mfe_pfx_hash_h_h_pfx ret = nt_edanglel_struct(t_0_i, t_0_j);
  if (is_empty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_edanglel_struct_Back<hishapeh_mfe_pfx, String, unsigned int>  >  bt = new Backtrace_nt_edanglel_struct_Back<hishapeh_mfe_pfx, String, unsigned int> (this, t_0_i, t_0_j);
  for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  elem = *elem_itr;
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_edanglel_struct_Front<String, unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > hishapeh_mfe_pfx::bt_proxy_nt_edangler_struct(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > l;
  empty(l);
  hishapeh_mfe_pfx_hash_h_h_pfx ret = nt_edangler_struct(t_0_i, t_0_j);
  if (is_empty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_edangler_struct_Back<hishapeh_mfe_pfx, String, unsigned int>  >  bt = new Backtrace_nt_edangler_struct_Back<hishapeh_mfe_pfx, String, unsigned int> (this, t_0_i, t_0_j);
  for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  elem = *elem_itr;
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_edangler_struct_Front<String, unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > hishapeh_mfe_pfx::bt_proxy_nt_edanglelr_struct(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > l;
  empty(l);
  hishapeh_mfe_pfx_hash_h_h_pfx ret = nt_edanglelr_struct(t_0_i, t_0_j);
  if (is_empty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_edanglelr_struct_Back<hishapeh_mfe_pfx, String, unsigned int>  >  bt = new Backtrace_nt_edanglelr_struct_Back<hishapeh_mfe_pfx, String, unsigned int> (this, t_0_i, t_0_j);
  for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  elem = *elem_itr;
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_edanglelr_struct_Front<String, unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > hishapeh_mfe_pfx::bt_proxy_nt_nodangle_struct(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > l;
  empty(l);
  hishapeh_mfe_pfx_hash_h_h_pfx ret = nt_nodangle_struct(t_0_i, t_0_j);
  if (is_empty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_nodangle_struct_Back<hishapeh_mfe_pfx, String, unsigned int>  >  bt = new Backtrace_nt_nodangle_struct_Back<hishapeh_mfe_pfx, String, unsigned int> (this, t_0_i, t_0_j);
  for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  elem = *elem_itr;
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_nodangle_struct_Front<String, unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > hishapeh_mfe_pfx::bt_proxy_nt_edanglel_ml(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > l;
  empty(l);
  hishapeh_mfe_pfx_hash_h_h_pfx ret = nt_edanglel_ml(t_0_i, t_0_j);
  if (is_empty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_edanglel_ml_Back<hishapeh_mfe_pfx, String, unsigned int>  >  bt = new Backtrace_nt_edanglel_ml_Back<hishapeh_mfe_pfx, String, unsigned int> (this, t_0_i, t_0_j);
  for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  elem = *elem_itr;
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_edanglel_ml_Front<String, unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > hishapeh_mfe_pfx::bt_proxy_nt_edangler_ml(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > l;
  empty(l);
  hishapeh_mfe_pfx_hash_h_h_pfx ret = nt_edangler_ml(t_0_i, t_0_j);
  if (is_empty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_edangler_ml_Back<hishapeh_mfe_pfx, String, unsigned int>  >  bt = new Backtrace_nt_edangler_ml_Back<hishapeh_mfe_pfx, String, unsigned int> (this, t_0_i, t_0_j);
  for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  elem = *elem_itr;
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_edangler_ml_Front<String, unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > hishapeh_mfe_pfx::bt_proxy_nt_edanglelr_ml(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > l;
  empty(l);
  hishapeh_mfe_pfx_hash_h_h_pfx ret = nt_edanglelr_ml(t_0_i, t_0_j);
  if (is_empty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_edanglelr_ml_Back<hishapeh_mfe_pfx, String, unsigned int>  >  bt = new Backtrace_nt_edanglelr_ml_Back<hishapeh_mfe_pfx, String, unsigned int> (this, t_0_i, t_0_j);
  for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  elem = *elem_itr;
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_edanglelr_ml_Front<String, unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > hishapeh_mfe_pfx::bt_proxy_nt_nodangle_ml(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > l;
  empty(l);
  hishapeh_mfe_pfx_hash_h_h_pfx ret = nt_nodangle_ml(t_0_i, t_0_j);
  if (is_empty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_nodangle_ml_Back<hishapeh_mfe_pfx, String, unsigned int>  >  bt = new Backtrace_nt_nodangle_ml_Back<hishapeh_mfe_pfx, String, unsigned int> (this, t_0_i, t_0_j);
  for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  elem = *elem_itr;
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_nodangle_ml_Front<String, unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > hishapeh_mfe_pfx::bt_proxy_nt_initstem(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > l;
  empty(l);
  hishapeh_mfe_pfx_hash_h_h_pfx ret = nt_initstem(t_0_i, t_0_j);
  if (is_empty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_initstem_Back<hishapeh_mfe_pfx, String, unsigned int>  >  bt = new Backtrace_nt_initstem_Back<hishapeh_mfe_pfx, String, unsigned int> (this, t_0_i, t_0_j);
  for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  elem = *elem_itr;
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_initstem_Front<String, unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > hishapeh_mfe_pfx::bt_proxy_nt_closed(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > l;
  empty(l);
  hishapeh_mfe_pfx_hash_h_h_pfx ret = nt_closed(t_0_i, t_0_j);
  if (is_empty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_closed_Back<hishapeh_mfe_pfx, String, unsigned int>  >  bt = new Backtrace_nt_closed_Back<hishapeh_mfe_pfx, String, unsigned int> (this, t_0_i, t_0_j);
  for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  elem = *elem_itr;
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_closed_Front<String, unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > hishapeh_mfe_pfx::bt_proxy_nt_multiloop(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > l;
  empty(l);
  hishapeh_mfe_pfx_hash_h_h_pfx ret = nt_multiloop(t_0_i, t_0_j);
  if (is_empty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_multiloop_Back<hishapeh_mfe_pfx, String, unsigned int>  >  bt = new Backtrace_nt_multiloop_Back<hishapeh_mfe_pfx, String, unsigned int> (this, t_0_i, t_0_j);
  for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  elem = *elem_itr;
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_multiloop_Front<String, unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > hishapeh_mfe_pfx::bt_proxy_nt_ml_comps1(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > l;
  empty(l);
  hishapeh_mfe_pfx_hash_h_h_pfx ret = nt_ml_comps1(t_0_i, t_0_j);
  if (is_empty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_ml_comps1_Back<hishapeh_mfe_pfx, String, unsigned int>  >  bt = new Backtrace_nt_ml_comps1_Back<hishapeh_mfe_pfx, String, unsigned int> (this, t_0_i, t_0_j);
  for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  elem = *elem_itr;
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_ml_comps1_Front<String, unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > hishapeh_mfe_pfx::bt_proxy_nt_ml_comps2(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > l;
  empty(l);
  hishapeh_mfe_pfx_hash_h_h_pfx ret = nt_ml_comps2(t_0_i, t_0_j);
  if (is_empty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_ml_comps2_Back<hishapeh_mfe_pfx, String, unsigned int>  >  bt = new Backtrace_nt_ml_comps2_Back<hishapeh_mfe_pfx, String, unsigned int> (this, t_0_i, t_0_j);
  for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  elem = *elem_itr;
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_ml_comps2_Front<String, unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > hishapeh_mfe_pfx::bt_proxy_nt_ml_comps3(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > l;
  empty(l);
  hishapeh_mfe_pfx_hash_h_h_pfx ret = nt_ml_comps3(t_0_i, t_0_j);
  if (is_empty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_ml_comps3_Back<hishapeh_mfe_pfx, String, unsigned int>  >  bt = new Backtrace_nt_ml_comps3_Back<hishapeh_mfe_pfx, String, unsigned int> (this, t_0_i, t_0_j);
  for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  elem = *elem_itr;
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_ml_comps3_Front<String, unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > hishapeh_mfe_pfx::bt_proxy_nt_ml_comps4(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > l;
  empty(l);
  hishapeh_mfe_pfx_hash_h_h_pfx ret = nt_ml_comps4(t_0_i, t_0_j);
  if (is_empty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_ml_comps4_Back<hishapeh_mfe_pfx, String, unsigned int>  >  bt = new Backtrace_nt_ml_comps4_Back<hishapeh_mfe_pfx, String, unsigned int> (this, t_0_i, t_0_j);
  for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  elem = *elem_itr;
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_ml_comps4_Front<String, unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > hishapeh_mfe_pfx::bt_proxy_nt_block_dl(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > l;
  empty(l);
  hishapeh_mfe_pfx_hash_h_h_pfx ret = nt_block_dl(t_0_i, t_0_j);
  if (is_empty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_block_dl_Back<hishapeh_mfe_pfx, String, unsigned int>  >  bt = new Backtrace_nt_block_dl_Back<hishapeh_mfe_pfx, String, unsigned int> (this, t_0_i, t_0_j);
  for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  elem = *elem_itr;
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_block_dl_Front<String, unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > hishapeh_mfe_pfx::bt_proxy_nt_block_dlr(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > l;
  empty(l);
  hishapeh_mfe_pfx_hash_h_h_pfx ret = nt_block_dlr(t_0_i, t_0_j);
  if (is_empty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_block_dlr_Back<hishapeh_mfe_pfx, String, unsigned int>  >  bt = new Backtrace_nt_block_dlr_Back<hishapeh_mfe_pfx, String, unsigned int> (this, t_0_i, t_0_j);
  for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  elem = *elem_itr;
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_block_dlr_Front<String, unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > hishapeh_mfe_pfx::bt_proxy_nt_no_dl_no_ss_end(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > l;
  empty(l);
  hishapeh_mfe_pfx_hash_h_h_pfx ret = nt_no_dl_no_ss_end(t_0_i, t_0_j);
  if (is_empty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_no_dl_no_ss_end_Back<hishapeh_mfe_pfx, String, unsigned int>  >  bt = new Backtrace_nt_no_dl_no_ss_end_Back<hishapeh_mfe_pfx, String, unsigned int> (this, t_0_i, t_0_j);
  for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  elem = *elem_itr;
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_no_dl_no_ss_end_Front<String, unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > hishapeh_mfe_pfx::bt_proxy_nt_dl_or_ss_left_no_ss_end(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > l;
  empty(l);
  hishapeh_mfe_pfx_hash_h_h_pfx ret = nt_dl_or_ss_left_no_ss_end(t_0_i, t_0_j);
  if (is_empty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_dl_or_ss_left_no_ss_end_Back<hishapeh_mfe_pfx, String, unsigned int>  >  bt = new Backtrace_nt_dl_or_ss_left_no_ss_end_Back<hishapeh_mfe_pfx, String, unsigned int> (this, t_0_i, t_0_j);
  for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  elem = *elem_itr;
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_dl_or_ss_left_no_ss_end_Front<String, unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > hishapeh_mfe_pfx::bt_proxy_nt_no_dl_ss_end(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > l;
  empty(l);
  hishapeh_mfe_pfx_hash_h_h_pfx ret = nt_no_dl_ss_end(t_0_i, t_0_j);
  if (is_empty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_no_dl_ss_end_Back<hishapeh_mfe_pfx, String, unsigned int>  >  bt = new Backtrace_nt_no_dl_ss_end_Back<hishapeh_mfe_pfx, String, unsigned int> (this, t_0_i, t_0_j);
  for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  elem = *elem_itr;
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_no_dl_ss_end_Front<String, unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > hishapeh_mfe_pfx::bt_proxy_nt_dl_or_ss_left_ss_end(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > l;
  empty(l);
  hishapeh_mfe_pfx_hash_h_h_pfx ret = nt_dl_or_ss_left_ss_end(t_0_i, t_0_j);
  if (is_empty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_dl_or_ss_left_ss_end_Back<hishapeh_mfe_pfx, String, unsigned int>  >  bt = new Backtrace_nt_dl_or_ss_left_ss_end_Back<hishapeh_mfe_pfx, String, unsigned int> (this, t_0_i, t_0_j);
  for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  elem = *elem_itr;
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_dl_or_ss_left_ss_end_Front<String, unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > hishapeh_mfe_pfx::bt_proxy_nt_stack(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > l;
  empty(l);
  hishapeh_mfe_pfx_hash_h_h_pfx ret = nt_stack(t_0_i, t_0_j);
  if (is_empty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_stack_Back<hishapeh_mfe_pfx, String, unsigned int>  >  bt = new Backtrace_nt_stack_Back<hishapeh_mfe_pfx, String, unsigned int> (this, t_0_i, t_0_j);
  for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  elem = *elem_itr;
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_stack_Front<String, unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  hishapeh_mfe_pfx::bt_proxy_nt_hairpin(unsigned int t_0_i, unsigned int t_0_j)
{
  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  l;
  hishapeh_mfe_pfx_hash_h_h_pfx ret = nt_hairpin(t_0_i, t_0_j);
  if (is_empty(ret))
  {
    empty( l);
    return l;
  }

  intrusive_ptr<Backtrace_nt_hairpin_Back<hishapeh_mfe_pfx, String, unsigned int>  >  bt = new Backtrace_nt_hairpin_Back<hishapeh_mfe_pfx, String, unsigned int> (this, t_0_i, t_0_j);
  for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  elem = *elem_itr;
    l.first = elem;
    l.second = new Backtrace_nt_hairpin_Front<String, unsigned int> (bt);
    set_value( l);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > hishapeh_mfe_pfx::bt_proxy_nt_leftB(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > l;
  empty(l);
  hishapeh_mfe_pfx_hash_h_h_pfx ret = nt_leftB(t_0_i, t_0_j);
  if (is_empty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_leftB_Back<hishapeh_mfe_pfx, String, unsigned int>  >  bt = new Backtrace_nt_leftB_Back<hishapeh_mfe_pfx, String, unsigned int> (this, t_0_i, t_0_j);
  for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  elem = *elem_itr;
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_leftB_Front<String, unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > hishapeh_mfe_pfx::bt_proxy_nt_rightB(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > l;
  empty(l);
  hishapeh_mfe_pfx_hash_h_h_pfx ret = nt_rightB(t_0_i, t_0_j);
  if (is_empty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_rightB_Back<hishapeh_mfe_pfx, String, unsigned int>  >  bt = new Backtrace_nt_rightB_Back<hishapeh_mfe_pfx, String, unsigned int> (this, t_0_i, t_0_j);
  for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  elem = *elem_itr;
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_rightB_Front<String, unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > hishapeh_mfe_pfx::bt_proxy_nt_iloop(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > l;
  empty(l);
  hishapeh_mfe_pfx_hash_h_h_pfx ret = nt_iloop(t_0_i, t_0_j);
  if (is_empty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_iloop_Back<hishapeh_mfe_pfx, String, unsigned int>  >  bt = new Backtrace_nt_iloop_Back<hishapeh_mfe_pfx, String, unsigned int> (this, t_0_i, t_0_j);
  for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, std::pair<mfeanswer, pfanswer> >  elem = *elem_itr;
    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_iloop_Front<String, unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::bt_nt_block_dl(unsigned int t_0_i, unsigned int t_0_j)
{
  if (!block_dl_table.is_tabulated(t_0_i, t_0_j))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 9))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 1); (t_0_k_0 <= (t_0_j - 8)); ++t_0_k_0)
      {
        TUSubsequence ret_1 = REGION(t_0_seq, t_0_i, t_0_k_0);
        TUSubsequence a_0 = ret_1;
        if (is_not_empty(a_0))
        {
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_2 = bt_proxy_nt_edanglel_ml(t_0_k_0, t_0_j);
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_1 = ret_2;
          if (is_not_empty(a_1))
            {
              for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
                std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_1 = *x_1_itr;
                std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = ssadd_bt(a_0, x_1);
                push_back( answers, ans);
              }
            }

          erase( a_1);
        }

        erase( a_0);
      }

    }


  if (((t_0_j - t_0_i) >= 8))
  {
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_4 = bt_proxy_nt_edanglel_ml(t_0_i, t_0_j);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_2 = ret_4;
    if (is_not_empty(a_2))
      {
        for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
          std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_2 = *x_2_itr;
          std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = incl_bt(x_2);
          push_back( answers, ans);
        }
      }

    erase( a_2);
  }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > eval = h_bt(answers, block_dl_table.get(t_0_i, t_0_j));
  erase( answers);
  intrusive_ptr<Backtrace<String, unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::bt_nt_block_dlr(unsigned int t_0_i, unsigned int t_0_j)
{
  if (!block_dlr_table.is_tabulated(t_0_i, t_0_j))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 10))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 1); (t_0_k_0 <= (t_0_j - 9)); ++t_0_k_0)
      {
        TUSubsequence ret_1 = REGION(t_0_seq, t_0_i, t_0_k_0);
        TUSubsequence a_0 = ret_1;
        if (is_not_empty(a_0))
        {
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_2 = bt_proxy_nt_edanglelr_ml(t_0_k_0, t_0_j);
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_1 = ret_2;
          if (is_not_empty(a_1))
            {
              for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
                std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_1 = *x_1_itr;
                std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = ssadd_bt(a_0, x_1);
                push_back( answers, ans);
              }
            }

          erase( a_1);
        }

        erase( a_0);
      }

    }


  if (((t_0_j - t_0_i) >= 9))
  {
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_4 = bt_proxy_nt_edanglelr_ml(t_0_i, t_0_j);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_2 = ret_4;
    if (is_not_empty(a_2))
      {
        for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
          std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_2 = *x_2_itr;
          std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = incl_bt(x_2);
          push_back( answers, ans);
        }
      }

    erase( a_2);
  }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > eval = h_bt(answers, block_dlr_table.get(t_0_i, t_0_j));
  erase( answers);
  intrusive_ptr<Backtrace<String, unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::bt_nt_closed(unsigned int t_0_i, unsigned int t_0_j)
{
  if (!closed_table.is_tabulated(t_0_i, t_0_j))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_0 = bt_proxy_nt_stack(t_0_i, t_0_j);
  append( answers, ret_0);
  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ret_1 = bt_proxy_nt_hairpin(t_0_i, t_0_j);
  if (is_not_empty(ret_1))
    {
      push_back( answers, ret_1);
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_2 = bt_proxy_nt_multiloop(t_0_i, t_0_j);
  append( answers, ret_2);
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_3 = bt_proxy_nt_leftB(t_0_i, t_0_j);
  append( answers, ret_3);
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_4 = bt_proxy_nt_rightB(t_0_i, t_0_j);
  append( answers, ret_4);
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_5 = bt_proxy_nt_iloop(t_0_i, t_0_j);
  append( answers, ret_5);
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > eval = h_bt(answers, closed_table.get(t_0_i, t_0_j));
  erase( answers);
  intrusive_ptr<Backtrace<String, unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::bt_nt_dl_or_ss_left_no_ss_end(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 8))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_0 = bt_proxy_nt_ml_comps1(t_0_i, t_0_j);
  append( answers, ret_0);
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_1 = bt_proxy_nt_block_dl(t_0_i, t_0_j);
  append( answers, ret_1);
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > eval = h_bt(answers);
  erase( answers);
  intrusive_ptr<Backtrace<String, unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::bt_nt_dl_or_ss_left_ss_end(unsigned int t_0_i, unsigned int t_0_j)
{
  if (!dl_or_ss_left_ss_end_table.is_tabulated(t_0_i, t_0_j))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_0 = bt_proxy_nt_ml_comps4(t_0_i, t_0_j);
  append( answers, ret_0);
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_1 = bt_proxy_nt_block_dlr(t_0_i, t_0_j);
  append( answers, ret_1);

  if (((t_0_j - t_0_i) >= 10))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 9); (t_0_k_0 <= (t_0_j - 1)); ++t_0_k_0)
      {
        TUSubsequence ret_4 = REGION(t_0_seq, t_0_k_0, t_0_j);
        TUSubsequence a_1 = ret_4;
        if (is_not_empty(a_1))
        {
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_3 = bt_proxy_nt_block_dlr(t_0_i, t_0_k_0);
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_0 = ret_3;
          if (is_not_empty(a_0))
            {
              for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_0_itr = a_0.ref().begin(); x_0_itr!=a_0.ref().end(); ++x_0_itr){
                std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_0 = *x_0_itr;
                std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = addss_bt(x_0, a_1);
                push_back( answers, ans);
              }
            }

          erase( a_0);
        }

        erase( a_1);
      }

    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > eval = h_bt(answers, dl_or_ss_left_ss_end_table.get(t_0_i, t_0_j));
  erase( answers);
  intrusive_ptr<Backtrace<String, unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::bt_nt_edanglel_ml(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 8))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 8))
  {
    TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
    TUSubsequence a_0 = ret_1;
    if (is_not_empty(a_0))
    {
      List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_2 = bt_proxy_nt_initstem((t_0_i + 1), t_0_j);
      List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_1 = ret_2;
      if (is_not_empty(a_1))
        {
          for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
            std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_1 = *x_1_itr;
            std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = edl_bt(a_0, x_1);
            push_back( answers, ans);
          }
        }

      erase( a_1);
    }

    erase( a_0);
  }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > eval = h_bt(answers);
  erase( answers);
  intrusive_ptr<Backtrace<String, unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::bt_nt_edanglel_struct(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 8))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 8))
  {
    TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
    TUSubsequence a_0 = ret_1;
    if (is_not_empty(a_0))
    {
      List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_2 = bt_proxy_nt_initstem((t_0_i + 1), t_0_j);
      List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_1 = ret_2;
      if (is_not_empty(a_1))
        {
          for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
            std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_1 = *x_1_itr;
            std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = edl_bt(a_0, x_1);
            push_back( answers, ans);
          }
        }

      erase( a_1);
    }

    erase( a_0);
  }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > eval = h_bt(answers);
  erase( answers);
  intrusive_ptr<Backtrace<String, unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::bt_nt_edanglelr_ml(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 9))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 9))
  {
    TUSubsequence ret_3 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
    TUSubsequence a_2 = ret_3;
    if (is_not_empty(a_2))
    {
      TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
      TUSubsequence a_0 = ret_1;
      if (is_not_empty(a_0))
      {
        List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_2 = bt_proxy_nt_initstem((t_0_i + 1), (t_0_j - 1));
        List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_1 = ret_2;
        if (is_not_empty(a_1))
          {
            for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
              std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_1 = *x_1_itr;
              std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = edlr_bt(a_0, x_1, a_2);
              push_back( answers, ans);
            }
          }

        erase( a_1);
      }

      erase( a_0);
    }

    erase( a_2);
  }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > eval = h_bt(answers);
  erase( answers);
  intrusive_ptr<Backtrace<String, unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::bt_nt_edanglelr_struct(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 9))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 9))
  {
    TUSubsequence ret_3 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
    TUSubsequence a_2 = ret_3;
    if (is_not_empty(a_2))
    {
      TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
      TUSubsequence a_0 = ret_1;
      if (is_not_empty(a_0))
      {
        List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_2 = bt_proxy_nt_initstem((t_0_i + 1), (t_0_j - 1));
        List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_1 = ret_2;
        if (is_not_empty(a_1))
          {
            for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
              std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_1 = *x_1_itr;
              std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = edlr_bt(a_0, x_1, a_2);
              push_back( answers, ans);
            }
          }

        erase( a_1);
      }

      erase( a_0);
    }

    erase( a_2);
  }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > eval = h_bt(answers);
  erase( answers);
  intrusive_ptr<Backtrace<String, unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::bt_nt_edangler_ml(unsigned int t_0_i, unsigned int t_0_j)
{
  if (!edangler_ml_table.is_tabulated(t_0_i, t_0_j))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 8))
  {
    TUSubsequence ret_2 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
    TUSubsequence a_1 = ret_2;
    if (is_not_empty(a_1))
    {
      List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_1 = bt_proxy_nt_initstem(t_0_i, (t_0_j - 1));
      List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_0 = ret_1;
      if (is_not_empty(a_0))
        {
          for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_0_itr = a_0.ref().begin(); x_0_itr!=a_0.ref().end(); ++x_0_itr){
            std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_0 = *x_0_itr;
            std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = edr_bt(x_0, a_1);
            push_back( answers, ans);
          }
        }

      erase( a_0);
    }

    erase( a_1);
  }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > eval = h_bt(answers, edangler_ml_table.get(t_0_i, t_0_j));
  erase( answers);
  intrusive_ptr<Backtrace<String, unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::bt_nt_edangler_struct(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 8))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 8))
  {
    TUSubsequence ret_2 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
    TUSubsequence a_1 = ret_2;
    if (is_not_empty(a_1))
    {
      List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_1 = bt_proxy_nt_initstem(t_0_i, (t_0_j - 1));
      List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_0 = ret_1;
      if (is_not_empty(a_0))
        {
          for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_0_itr = a_0.ref().begin(); x_0_itr!=a_0.ref().end(); ++x_0_itr){
            std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_0 = *x_0_itr;
            std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = edr_bt(x_0, a_1);
            push_back( answers, ans);
          }
        }

      erase( a_0);
    }

    erase( a_1);
  }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > eval = h_bt(answers);
  erase( answers);
  intrusive_ptr<Backtrace<String, unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::bt_nt_hairpin(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 7))
    {
      return 0;
    }

  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  answers;
  empty( answers);
  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ret_0;
  if (((t_0_j - t_0_i) >= 7))
    {
      if (((!_exact) && pairing_center_at(t_0_seq, t_0_i, t_0_j, _match_tokens_h, _theta)) || ((_exact) && exact_pairing_center_at(t_0_seq, t_0_i, t_0_j, _match_tokens_h)))  // added
      {                                                                                                                                                               // added
        TUSubsequence ret_5 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_4 = ret_5;
        if (is_not_empty(a_4))
        {
          TUSubsequence ret_4 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
          TUSubsequence a_3 = ret_4;
          if (is_not_empty(a_3))
          {
            TUSubsequence ret_3;
            if (minsize(t_0_seq, (t_0_i + 2), (t_0_j - 2), 3))
              {
                ret_3 = REGION(t_0_seq, (t_0_i + 2), (t_0_j - 2));
              }

            else
              {
                empty( ret_3);
              }

            TUSubsequence a_2 = ret_3;
            if (is_not_empty(a_2))
            {
              TUSubsequence ret_2 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
              TUSubsequence a_1 = ret_2;
              if (is_not_empty(a_1))
              {
                TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
                TUSubsequence a_0 = ret_1;
                if (is_not_empty(a_0))
                  {
                    ret_0 = hl_bt(a_0, a_1, a_2, a_3, a_4);
                  }

                else
                  {
                    empty( ret_0);
                  }

                erase( a_0);
              }

              else
                {
                  empty( ret_0);
                }

              erase( a_1);
            }

            else
              {
                empty( ret_0);
              }

            erase( a_2);
          }

          else
            {
              empty( ret_0);
            }

          erase( a_3);
        }

        else
          {
            empty( ret_0);
          }

        erase( a_4);
      }

      else
      {
        empty( ret_0);
        empty( ret_0);
      }

    }

  else
    {
      empty( ret_0);
    }

  answers = ret_0;
  intrusive_ptr<Backtrace<String, unsigned int> >  bt_list = execute_backtrack_k(answers);
  return bt_list;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::bt_nt_iloop(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 13))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 13))
    {
      if (stackpairing(t_0_seq, t_0_i, t_0_j))
      {
        TUSubsequence ret_8 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_7 = ret_8;
        if (is_not_empty(a_7))
        {
          TUSubsequence ret_7 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
          TUSubsequence a_6 = ret_7;
          if (is_not_empty(a_6))
          {
            TUSubsequence ret_2 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
            TUSubsequence a_1 = ret_2;
            if (is_not_empty(a_1))
            {
              TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
              TUSubsequence a_0 = ret_1;
              if (is_not_empty(a_0))
              {
                List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_3;
                empty(ret_3);
                if ((((t_0_j - 2) - (t_0_i + 2)) >= 9))
                  {
                    for(                    unsigned int t_0_k_0 = ((t_0_i + 2) + 1); ((t_0_k_0 <= ((t_0_j - 2) - 8)) && (t_0_k_0 <= ((t_0_i + 2) + 30))); ++t_0_k_0)
                    {
                      for(                      unsigned int t_0_k_1 = ((((t_0_j - 2) - (t_0_k_0 + 7)) >= 30)) ? (((t_0_j - 2) - 30)) : ((t_0_k_0 + 7)); (t_0_k_1 <= ((t_0_j - 2) - 1)); ++t_0_k_1)
                      {
                        TUSubsequence ret_6;
                        if (maxsize(t_0_seq, t_0_k_1, (t_0_j - 2), 30))
                          {
                            ret_6 = REGION(t_0_seq, t_0_k_1, (t_0_j - 2));
                          }

                        else
                          {
                            empty( ret_6);
                          }

                        TUSubsequence a_5 = ret_6;
                        if (is_not_empty(a_5))
                        {
                          TUSubsequence ret_4;
                          if (maxsize(t_0_seq, (t_0_i + 2), t_0_k_0, 30))
                            {
                              ret_4 = REGION(t_0_seq, (t_0_i + 2), t_0_k_0);
                            }

                          else
                            {
                              empty( ret_4);
                            }

                          TUSubsequence a_3 = ret_4;
                          if (is_not_empty(a_3))
                          {
                            List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_5 = bt_proxy_nt_closed(t_0_k_0, t_0_k_1);
                            List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_4 = ret_5;
                            if (is_not_empty(a_4))
                              {
                                for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_4_itr = a_4.ref().begin(); x_4_itr!=a_4.ref().end(); ++x_4_itr){
                                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_4 = *x_4_itr;
                                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = il_bt(a_3, x_4, a_5);
                                  push_back( ret_3, ans);
                                }
                              }

                            erase( a_4);
                          }

                          erase( a_3);
                        }

                        erase( a_5);
                      }

                    }

                  }

                finalize( ret_3);
                List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_2 = ret_3;
                if (is_not_empty(a_2))
                  {
                    for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                      std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_2 = *x_2_itr;
                      std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = sp_bt(a_0, a_1, x_2, a_6, a_7);
                      push_back( answers, ans);
                    }
                  }

                erase( a_2);
              }

              erase( a_0);
            }

            erase( a_1);
          }

          erase( a_6);
        }

        erase( a_7);
      }

      else
        {
          empty( answers);
        }

    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > eval = h_bt(answers);
  erase( answers);
  intrusive_ptr<Backtrace<String, unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::bt_nt_initstem(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 7))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 7))
  {
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_1 = bt_proxy_nt_closed(t_0_i, t_0_j);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_0 = ret_1;
    if (is_not_empty(a_0))
      {
        for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_0_itr = a_0.ref().begin(); x_0_itr!=a_0.ref().end(); ++x_0_itr){
          std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_0 = *x_0_itr;
          std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = is_bt(x_0);
          push_back( answers, ans);
        }
      }

    erase( a_0);
  }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > eval = h_bt(answers);
  erase( answers);
  intrusive_ptr<Backtrace<String, unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::bt_nt_leftB(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 12))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 12))
    {
      if (stackpairing(t_0_seq, t_0_i, t_0_j))
      {
        TUSubsequence ret_7 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_6 = ret_7;
        if (is_not_empty(a_6))
        {
          TUSubsequence ret_6 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
          TUSubsequence a_5 = ret_6;
          if (is_not_empty(a_5))
          {
            TUSubsequence ret_2 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
            TUSubsequence a_1 = ret_2;
            if (is_not_empty(a_1))
            {
              TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
              TUSubsequence a_0 = ret_1;
              if (is_not_empty(a_0))
              {
                List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_3;
                empty(ret_3);
                if ((((t_0_j - 2) - (t_0_i + 2)) >= 8))
                  {
                    for(                    unsigned int t_0_k_0 = ((t_0_i + 2) + 1); (t_0_k_0 <= ((t_0_j - 2) - 7)); ++t_0_k_0)
                    {
                      TUSubsequence ret_4 = REGION(t_0_seq, (t_0_i + 2), t_0_k_0);
                      TUSubsequence a_3 = ret_4;
                      if (is_not_empty(a_3))
                      {
                        List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_5 = bt_proxy_nt_closed(t_0_k_0, (t_0_j - 2));
                        List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_4 = ret_5;
                        if (is_not_empty(a_4))
                          {
                            for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_4_itr = a_4.ref().begin(); x_4_itr!=a_4.ref().end(); ++x_4_itr){
                              std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_4 = *x_4_itr;
                              std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = bl_bt(a_3, x_4);
                              push_back( ret_3, ans);
                            }
                          }

                        erase( a_4);
                      }

                      erase( a_3);
                    }

                  }

                finalize( ret_3);
                List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_2 = ret_3;
                if (is_not_empty(a_2))
                  {
                    for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                      std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_2 = *x_2_itr;
                      std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = sp_bt(a_0, a_1, x_2, a_5, a_6);
                      push_back( answers, ans);
                    }
                  }

                erase( a_2);
              }

              erase( a_0);
            }

            erase( a_1);
          }

          erase( a_5);
        }

        erase( a_6);
      }

      else
        {
          empty( answers);
        }

    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > eval = h_bt(answers);
  erase( answers);
  intrusive_ptr<Backtrace<String, unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::bt_nt_left_dangle(unsigned int t_0_i)
{
  if (!left_dangle_table.is_tabulated(t_0_i))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);

  if (((t_0_right_most - t_0_i) >= 16))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 8); (t_0_k_0 <= (t_0_right_most - 8)); ++t_0_k_0)
      {
        TUSubsequence ret_2 = BASE(t_0_seq, t_0_k_0, (t_0_k_0 + 1));
        TUSubsequence a_1 = ret_2;
        if (is_not_empty(a_1))
        {
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_3 = bt_proxy_nt_noleft_dangle((t_0_k_0 + 1));
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_2 = ret_3;
          if (is_not_empty(a_2))
          {
            List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_1 = bt_proxy_nt_edanglel_struct(t_0_i, t_0_k_0);
            List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_0 = ret_1;
            if (is_not_empty(a_0))
              {
                for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_0_itr = a_0.ref().begin(); x_0_itr!=a_0.ref().end(); ++x_0_itr){
                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_0 = *x_0_itr;
                  for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_2 = *x_2_itr;
                    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = ambd_bt(x_0, a_1, x_2);
                    push_back( answers, ans);
                  }
                }
              }

            erase( a_0);
          }

          else
            {
              for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator elem_itr = a_2.ref().begin(); elem_itr!=a_2.ref().end(); ++elem_itr){
                std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  elem = *elem_itr;
                erase( elem.second);
              }
            }

          erase( a_2);
        }

        erase( a_1);
      }

    }


  if (((t_0_right_most - t_0_i) >= 8))
    {
      for(      unsigned int t_0_k_1 = (t_0_i + 8); (t_0_k_1 <= t_0_right_most); ++t_0_k_1)
      {
        List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_6;
        empty(ret_6);
        empty( ret_6);
        List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_7 = bt_proxy_nt_noleft_dangle(t_0_k_1);
        append( ret_6, ret_7);
        std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ret_8;
        if ((((t_0_right_most - t_0_k_1) >= 0) && ((t_0_right_most - t_0_k_1) <= 0)))
        {
          TUSubsequence ret_9 = LOC(t_0_seq, t_0_k_1, t_0_k_1);
          TUSubsequence a_5 = ret_9;
          if (is_not_empty(a_5))
            {
              ret_8 = nil_Pr_bt(a_5);
            }

          else
            {
              empty( ret_8);
            }

          erase( a_5);
        }

        else
          {
            empty( ret_8);
          }

        if (is_not_empty(ret_8))
          {
            push_back( ret_6, ret_8);
          }

        finalize( ret_6);
        List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_4 = ret_6;
        if (is_not_empty(a_4))
        {
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_5 = bt_proxy_nt_edanglel_struct(t_0_i, t_0_k_1);
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_3 = ret_5;
          if (is_not_empty(a_3))
            {
              for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_3_itr = a_3.ref().begin(); x_3_itr!=a_3.ref().end(); ++x_3_itr){
                std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_3 = *x_3_itr;
                for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_4_itr = a_4.ref().begin(); x_4_itr!=a_4.ref().end(); ++x_4_itr){
                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_4 = *x_4_itr;
                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = cadd_Pr_bt(x_3, x_4);
                  push_back( answers, ans);
                }
              }
            }

          erase( a_3);
        }

        else
          {
            for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator elem_itr = a_4.ref().begin(); elem_itr!=a_4.ref().end(); ++elem_itr){
              std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  elem = *elem_itr;
              erase( elem.second);
            }
          }

        erase( a_4);
      }

    }


  if (((t_0_right_most - t_0_i) >= 9))
    {
      for(      unsigned int t_0_k_2 = (t_0_i + 9); (t_0_k_2 <= t_0_right_most); ++t_0_k_2)
      {
        List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_12;
        empty(ret_12);
        empty( ret_12);
        List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_13 = bt_proxy_nt_left_dangle(t_0_k_2);
        append( ret_12, ret_13);
        List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_14 = bt_proxy_nt_left_unpaired(t_0_k_2);
        append( ret_12, ret_14);
        finalize( ret_12);
        List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_7 = ret_12;
        if (is_not_empty(a_7))
        {
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_11 = bt_proxy_nt_edanglelr_struct(t_0_i, t_0_k_2);
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_6 = ret_11;
          if (is_not_empty(a_6))
            {
              for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_6_itr = a_6.ref().begin(); x_6_itr!=a_6.ref().end(); ++x_6_itr){
                std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_6 = *x_6_itr;
                for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_7_itr = a_7.ref().begin(); x_7_itr!=a_7.ref().end(); ++x_7_itr){
                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_7 = *x_7_itr;
                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = cadd_bt(x_6, x_7);
                  push_back( answers, ans);
                }
              }
            }

          erase( a_6);
        }

        else
          {
            for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator elem_itr = a_7.ref().begin(); elem_itr!=a_7.ref().end(); ++elem_itr){
              std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  elem = *elem_itr;
              erase( elem.second);
            }
          }

        erase( a_7);
      }

    }

  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ret_15;
  if ((((t_0_right_most - t_0_i) >= 0) && ((t_0_right_most - t_0_i) <= 0)))
  {
    TUSubsequence ret_16 = LOC(t_0_seq, t_0_i, t_0_i);
    TUSubsequence a_8 = ret_16;
    if (is_not_empty(a_8))
      {
        ret_15 = nil_bt(a_8);
      }

    else
      {
        empty( ret_15);
      }

    erase( a_8);
  }

  else
    {
      empty( ret_15);
    }

  if (is_not_empty(ret_15))
    {
      push_back( answers, ret_15);
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > eval = h_bt(answers, left_dangle_table.get(t_0_i));
  erase( answers);
  intrusive_ptr<Backtrace<String, unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::bt_nt_left_unpaired(unsigned int t_0_i)
{
  if (!left_unpaired_table.is_tabulated(t_0_i))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);

  if (((t_0_right_most - t_0_i) >= 2))
  {
    TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
    TUSubsequence a_0 = ret_1;
    if (is_not_empty(a_0))
    {
      List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_2 = bt_proxy_nt_left_unpaired((t_0_i + 1));
      List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_1 = ret_2;
      if (is_not_empty(a_1))
        {
          for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
            std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_1 = *x_1_itr;
            std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = sadd_bt(a_0, x_1);
            push_back( answers, ans);
          }
        }

      erase( a_1);
    }

    erase( a_0);
  }


  if (((t_0_right_most - t_0_i) >= 1))
  {
    TUSubsequence ret_4 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
    TUSubsequence a_2 = ret_4;
    if (is_not_empty(a_2))
    {
      List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_5 = bt_proxy_nt_left_dangle((t_0_i + 1));
      List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_3 = ret_5;
      if (is_not_empty(a_3))
        {
          for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_3_itr = a_3.ref().begin(); x_3_itr!=a_3.ref().end(); ++x_3_itr){
            std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_3 = *x_3_itr;
            std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = sadd_bt(a_2, x_3);
            push_back( answers, ans);
          }
        }

      erase( a_3);
    }

    erase( a_2);
  }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > eval = h_bt(answers, left_unpaired_table.get(t_0_i));
  erase( answers);
  intrusive_ptr<Backtrace<String, unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::bt_nt_ml_comps1(unsigned int t_0_i, unsigned int t_0_j)
{
  if (!ml_comps1_table.is_tabulated(t_0_i, t_0_j))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 15))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 8); (t_0_k_0 <= (t_0_j - 7)); ++t_0_k_0)
      {
        List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_2 = bt_proxy_nt_no_dl_no_ss_end(t_0_k_0, t_0_j);
        List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_1 = ret_2;
        if (is_not_empty(a_1))
        {
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_1 = bt_proxy_nt_block_dl(t_0_i, t_0_k_0);
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_0 = ret_1;
          if (is_not_empty(a_0))
            {
              for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_0_itr = a_0.ref().begin(); x_0_itr!=a_0.ref().end(); ++x_0_itr){
                std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_0 = *x_0_itr;
                for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_1 = *x_1_itr;
                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = combine_bt(x_0, x_1);
                  push_back( answers, ans);
                }
              }
            }

          erase( a_0);
        }

        else
          {
            for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator elem_itr = a_1.ref().begin(); elem_itr!=a_1.ref().end(); ++elem_itr){
              std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  elem = *elem_itr;
              erase( elem.second);
            }
          }

        erase( a_1);
      }

    }


  if (((t_0_j - t_0_i) >= 17))
    {
      for(      unsigned int t_0_k_1 = (t_0_i + 9); (t_0_k_1 <= (t_0_j - 8)); ++t_0_k_1)
      {
        List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_5 = bt_proxy_nt_dl_or_ss_left_no_ss_end(t_0_k_1, t_0_j);
        List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_3 = ret_5;
        if (is_not_empty(a_3))
        {
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_4 = bt_proxy_nt_block_dlr(t_0_i, t_0_k_1);
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_2 = ret_4;
          if (is_not_empty(a_2))
            {
              for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_2 = *x_2_itr;
                for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_3_itr = a_3.ref().begin(); x_3_itr!=a_3.ref().end(); ++x_3_itr){
                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_3 = *x_3_itr;
                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = combine_bt(x_2, x_3);
                  push_back( answers, ans);
                }
              }
            }

          erase( a_2);
        }

        else
          {
            for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator elem_itr = a_3.ref().begin(); elem_itr!=a_3.ref().end(); ++elem_itr){
              std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  elem = *elem_itr;
              erase( elem.second);
            }
          }

        erase( a_3);
      }

    }


  if (((t_0_j - t_0_i) >= 16))
    {
      for(      unsigned int t_0_k_2 = (t_0_i + 8); (t_0_k_2 <= (t_0_j - 8)); ++t_0_k_2)
      {
        TUSubsequence ret_8 = BASE(t_0_seq, t_0_k_2, (t_0_k_2 + 1));
        TUSubsequence a_5 = ret_8;
        if (is_not_empty(a_5))
        {
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_9 = bt_proxy_nt_no_dl_no_ss_end((t_0_k_2 + 1), t_0_j);
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_6 = ret_9;
          if (is_not_empty(a_6))
          {
            List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_7 = bt_proxy_nt_block_dl(t_0_i, t_0_k_2);
            List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_4 = ret_7;
            if (is_not_empty(a_4))
              {
                for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_4_itr = a_4.ref().begin(); x_4_itr!=a_4.ref().end(); ++x_4_itr){
                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_4 = *x_4_itr;
                  for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_6_itr = a_6.ref().begin(); x_6_itr!=a_6.ref().end(); ++x_6_itr){
                    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_6 = *x_6_itr;
                    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = acomb_bt(x_4, a_5, x_6);
                    push_back( answers, ans);
                  }
                }
              }

            erase( a_4);
          }

          else
            {
              for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator elem_itr = a_6.ref().begin(); elem_itr!=a_6.ref().end(); ++elem_itr){
                std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  elem = *elem_itr;
                erase( elem.second);
              }
            }

          erase( a_6);
        }

        erase( a_5);
      }

    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > eval = h_bt(answers, ml_comps1_table.get(t_0_i, t_0_j));
  erase( answers);
  intrusive_ptr<Backtrace<String, unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::bt_nt_ml_comps2(unsigned int t_0_i, unsigned int t_0_j)
{
  if (!ml_comps2_table.is_tabulated(t_0_i, t_0_j))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 14))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 7); (t_0_k_0 <= (t_0_j - 7)); ++t_0_k_0)
      {
        List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_3 = bt_proxy_nt_no_dl_no_ss_end(t_0_k_0, t_0_j);
        List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_2 = ret_3;
        if (is_not_empty(a_2))
        {
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_1;
          empty(ret_1);
          if (((t_0_k_0 - t_0_i) >= 7))
          {
            List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_2 = bt_proxy_nt_nodangle_ml(t_0_i, t_0_k_0);
            List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_1 = ret_2;
            if (is_not_empty(a_1))
              {
                for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_1 = *x_1_itr;
                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = incl_bt(x_1);
                  push_back( ret_1, ans);
                }
              }

            erase( a_1);
          }

          finalize( ret_1);
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_0 = ret_1;
          if (is_not_empty(a_0))
            {
              for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_0_itr = a_0.ref().begin(); x_0_itr!=a_0.ref().end(); ++x_0_itr){
                std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_0 = *x_0_itr;
                for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_2 = *x_2_itr;
                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = combine_bt(x_0, x_2);
                  push_back( answers, ans);
                }
              }
            }

          erase( a_0);
        }

        else
          {
            for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator elem_itr = a_2.ref().begin(); elem_itr!=a_2.ref().end(); ++elem_itr){
              std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  elem = *elem_itr;
              erase( elem.second);
            }
          }

        erase( a_2);
      }

    }


  if (((t_0_j - t_0_i) >= 16))
    {
      for(      unsigned int t_0_k_1 = (t_0_i + 8); (t_0_k_1 <= (t_0_j - 8)); ++t_0_k_1)
      {
        List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_7 = bt_proxy_nt_dl_or_ss_left_no_ss_end(t_0_k_1, t_0_j);
        List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_5 = ret_7;
        if (is_not_empty(a_5))
        {
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_5;
          empty(ret_5);
          if (((t_0_k_1 - t_0_i) >= 8))
          {
            List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_6 = bt_proxy_nt_edangler_ml(t_0_i, t_0_k_1);
            List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_4 = ret_6;
            if (is_not_empty(a_4))
              {
                for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_4_itr = a_4.ref().begin(); x_4_itr!=a_4.ref().end(); ++x_4_itr){
                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_4 = *x_4_itr;
                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = incl_bt(x_4);
                  push_back( ret_5, ans);
                }
              }

            erase( a_4);
          }

          finalize( ret_5);
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_3 = ret_5;
          if (is_not_empty(a_3))
            {
              for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_3_itr = a_3.ref().begin(); x_3_itr!=a_3.ref().end(); ++x_3_itr){
                std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_3 = *x_3_itr;
                for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_5_itr = a_5.ref().begin(); x_5_itr!=a_5.ref().end(); ++x_5_itr){
                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_5 = *x_5_itr;
                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = combine_bt(x_3, x_5);
                  push_back( answers, ans);
                }
              }
            }

          erase( a_3);
        }

        else
          {
            for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator elem_itr = a_5.ref().begin(); elem_itr!=a_5.ref().end(); ++elem_itr){
              std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  elem = *elem_itr;
              erase( elem.second);
            }
          }

        erase( a_5);
      }

    }


  if (((t_0_j - t_0_i) >= 15))
    {
      for(      unsigned int t_0_k_2 = (t_0_i + 7); (t_0_k_2 <= (t_0_j - 8)); ++t_0_k_2)
      {
        TUSubsequence ret_11 = BASE(t_0_seq, t_0_k_2, (t_0_k_2 + 1));
        TUSubsequence a_8 = ret_11;
        if (is_not_empty(a_8))
        {
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_12 = bt_proxy_nt_no_dl_no_ss_end((t_0_k_2 + 1), t_0_j);
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_9 = ret_12;
          if (is_not_empty(a_9))
          {
            List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_9;
            empty(ret_9);
            if (((t_0_k_2 - t_0_i) >= 7))
            {
              List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_10 = bt_proxy_nt_nodangle_ml(t_0_i, t_0_k_2);
              List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_7 = ret_10;
              if (is_not_empty(a_7))
                {
                  for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_7_itr = a_7.ref().begin(); x_7_itr!=a_7.ref().end(); ++x_7_itr){
                    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_7 = *x_7_itr;
                    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = incl_bt(x_7);
                    push_back( ret_9, ans);
                  }
                }

              erase( a_7);
            }

            finalize( ret_9);
            List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_6 = ret_9;
            if (is_not_empty(a_6))
              {
                for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_6_itr = a_6.ref().begin(); x_6_itr!=a_6.ref().end(); ++x_6_itr){
                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_6 = *x_6_itr;
                  for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_9_itr = a_9.ref().begin(); x_9_itr!=a_9.ref().end(); ++x_9_itr){
                    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_9 = *x_9_itr;
                    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = acomb_bt(x_6, a_8, x_9);
                    push_back( answers, ans);
                  }
                }
              }

            erase( a_6);
          }

          else
            {
              for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator elem_itr = a_9.ref().begin(); elem_itr!=a_9.ref().end(); ++elem_itr){
                std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  elem = *elem_itr;
                erase( elem.second);
              }
            }

          erase( a_9);
        }

        erase( a_8);
      }

    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > eval = h_bt(answers, ml_comps2_table.get(t_0_i, t_0_j));
  erase( answers);
  intrusive_ptr<Backtrace<String, unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::bt_nt_ml_comps3(unsigned int t_0_i, unsigned int t_0_j)
{
  if (!ml_comps3_table.is_tabulated(t_0_i, t_0_j))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 17))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 8); (t_0_k_0 <= (t_0_j - 9)); ++t_0_k_0)
      {
        List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_3 = bt_proxy_nt_dl_or_ss_left_ss_end(t_0_k_0, t_0_j);
        List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_2 = ret_3;
        if (is_not_empty(a_2))
        {
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_1;
          empty(ret_1);
          if (((t_0_k_0 - t_0_i) >= 8))
          {
            List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_2 = bt_proxy_nt_edangler_ml(t_0_i, t_0_k_0);
            List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_1 = ret_2;
            if (is_not_empty(a_1))
              {
                for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_1 = *x_1_itr;
                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = incl_bt(x_1);
                  push_back( ret_1, ans);
                }
              }

            erase( a_1);
          }

          finalize( ret_1);
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_0 = ret_1;
          if (is_not_empty(a_0))
            {
              for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_0_itr = a_0.ref().begin(); x_0_itr!=a_0.ref().end(); ++x_0_itr){
                std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_0 = *x_0_itr;
                for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_2 = *x_2_itr;
                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = combine_bt(x_0, x_2);
                  push_back( answers, ans);
                }
              }
            }

          erase( a_0);
        }

        else
          {
            for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator elem_itr = a_2.ref().begin(); elem_itr!=a_2.ref().end(); ++elem_itr){
              std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  elem = *elem_itr;
              erase( elem.second);
            }
          }

        erase( a_2);
      }

    }


  if (((t_0_j - t_0_i) >= 15))
    {
      for(      unsigned int t_0_k_1 = (t_0_i + 7); (t_0_k_1 <= (t_0_j - 8)); ++t_0_k_1)
      {
        List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_7 = bt_proxy_nt_no_dl_ss_end(t_0_k_1, t_0_j);
        List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_5 = ret_7;
        if (is_not_empty(a_5))
        {
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_5;
          empty(ret_5);
          if (((t_0_k_1 - t_0_i) >= 7))
          {
            List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_6 = bt_proxy_nt_nodangle_ml(t_0_i, t_0_k_1);
            List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_4 = ret_6;
            if (is_not_empty(a_4))
              {
                for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_4_itr = a_4.ref().begin(); x_4_itr!=a_4.ref().end(); ++x_4_itr){
                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_4 = *x_4_itr;
                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = incl_bt(x_4);
                  push_back( ret_5, ans);
                }
              }

            erase( a_4);
          }

          finalize( ret_5);
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_3 = ret_5;
          if (is_not_empty(a_3))
            {
              for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_3_itr = a_3.ref().begin(); x_3_itr!=a_3.ref().end(); ++x_3_itr){
                std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_3 = *x_3_itr;
                for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_5_itr = a_5.ref().begin(); x_5_itr!=a_5.ref().end(); ++x_5_itr){
                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_5 = *x_5_itr;
                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = combine_bt(x_3, x_5);
                  push_back( answers, ans);
                }
              }
            }

          erase( a_3);
        }

        else
          {
            for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator elem_itr = a_5.ref().begin(); elem_itr!=a_5.ref().end(); ++elem_itr){
              std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  elem = *elem_itr;
              erase( elem.second);
            }
          }

        erase( a_5);
      }

    }


  if (((t_0_j - t_0_i) >= 16))
    {
      for(      unsigned int t_0_k_2 = (t_0_i + 7); (t_0_k_2 <= (t_0_j - 9)); ++t_0_k_2)
      {
        TUSubsequence ret_11 = BASE(t_0_seq, t_0_k_2, (t_0_k_2 + 1));
        TUSubsequence a_8 = ret_11;
        if (is_not_empty(a_8))
        {
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_12 = bt_proxy_nt_no_dl_ss_end((t_0_k_2 + 1), t_0_j);
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_9 = ret_12;
          if (is_not_empty(a_9))
          {
            List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_9;
            empty(ret_9);
            if (((t_0_k_2 - t_0_i) >= 7))
            {
              List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_10 = bt_proxy_nt_nodangle_ml(t_0_i, t_0_k_2);
              List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_7 = ret_10;
              if (is_not_empty(a_7))
                {
                  for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_7_itr = a_7.ref().begin(); x_7_itr!=a_7.ref().end(); ++x_7_itr){
                    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_7 = *x_7_itr;
                    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = incl_bt(x_7);
                    push_back( ret_9, ans);
                  }
                }

              erase( a_7);
            }

            finalize( ret_9);
            List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_6 = ret_9;
            if (is_not_empty(a_6))
              {
                for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_6_itr = a_6.ref().begin(); x_6_itr!=a_6.ref().end(); ++x_6_itr){
                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_6 = *x_6_itr;
                  for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_9_itr = a_9.ref().begin(); x_9_itr!=a_9.ref().end(); ++x_9_itr){
                    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_9 = *x_9_itr;
                    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = acomb_bt(x_6, a_8, x_9);
                    push_back( answers, ans);
                  }
                }
              }

            erase( a_6);
          }

          else
            {
              for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator elem_itr = a_9.ref().begin(); elem_itr!=a_9.ref().end(); ++elem_itr){
                std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  elem = *elem_itr;
                erase( elem.second);
              }
            }

          erase( a_9);
        }

        erase( a_8);
      }

    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > eval = h_bt(answers, ml_comps3_table.get(t_0_i, t_0_j));
  erase( answers);
  intrusive_ptr<Backtrace<String, unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::bt_nt_ml_comps4(unsigned int t_0_i, unsigned int t_0_j)
{
  if (!ml_comps4_table.is_tabulated(t_0_i, t_0_j))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 16))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 8); (t_0_k_0 <= (t_0_j - 8)); ++t_0_k_0)
      {
        List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_2 = bt_proxy_nt_no_dl_ss_end(t_0_k_0, t_0_j);
        List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_1 = ret_2;
        if (is_not_empty(a_1))
        {
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_1 = bt_proxy_nt_block_dl(t_0_i, t_0_k_0);
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_0 = ret_1;
          if (is_not_empty(a_0))
            {
              for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_0_itr = a_0.ref().begin(); x_0_itr!=a_0.ref().end(); ++x_0_itr){
                std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_0 = *x_0_itr;
                for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_1 = *x_1_itr;
                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = combine_bt(x_0, x_1);
                  push_back( answers, ans);
                }
              }
            }

          erase( a_0);
        }

        else
          {
            for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator elem_itr = a_1.ref().begin(); elem_itr!=a_1.ref().end(); ++elem_itr){
              std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  elem = *elem_itr;
              erase( elem.second);
            }
          }

        erase( a_1);
      }

    }


  if (((t_0_j - t_0_i) >= 18))
    {
      for(      unsigned int t_0_k_1 = (t_0_i + 9); (t_0_k_1 <= (t_0_j - 9)); ++t_0_k_1)
      {
        List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_5 = bt_proxy_nt_dl_or_ss_left_ss_end(t_0_k_1, t_0_j);
        List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_3 = ret_5;
        if (is_not_empty(a_3))
        {
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_4 = bt_proxy_nt_block_dlr(t_0_i, t_0_k_1);
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_2 = ret_4;
          if (is_not_empty(a_2))
            {
              for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_2 = *x_2_itr;
                for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_3_itr = a_3.ref().begin(); x_3_itr!=a_3.ref().end(); ++x_3_itr){
                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_3 = *x_3_itr;
                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = combine_bt(x_2, x_3);
                  push_back( answers, ans);
                }
              }
            }

          erase( a_2);
        }

        else
          {
            for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator elem_itr = a_3.ref().begin(); elem_itr!=a_3.ref().end(); ++elem_itr){
              std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  elem = *elem_itr;
              erase( elem.second);
            }
          }

        erase( a_3);
      }

    }


  if (((t_0_j - t_0_i) >= 17))
    {
      for(      unsigned int t_0_k_2 = (t_0_i + 8); (t_0_k_2 <= (t_0_j - 9)); ++t_0_k_2)
      {
        TUSubsequence ret_8 = BASE(t_0_seq, t_0_k_2, (t_0_k_2 + 1));
        TUSubsequence a_5 = ret_8;
        if (is_not_empty(a_5))
        {
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_9 = bt_proxy_nt_no_dl_ss_end((t_0_k_2 + 1), t_0_j);
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_6 = ret_9;
          if (is_not_empty(a_6))
          {
            List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_7 = bt_proxy_nt_block_dl(t_0_i, t_0_k_2);
            List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_4 = ret_7;
            if (is_not_empty(a_4))
              {
                for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_4_itr = a_4.ref().begin(); x_4_itr!=a_4.ref().end(); ++x_4_itr){
                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_4 = *x_4_itr;
                  for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_6_itr = a_6.ref().begin(); x_6_itr!=a_6.ref().end(); ++x_6_itr){
                    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_6 = *x_6_itr;
                    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = acomb_bt(x_4, a_5, x_6);
                    push_back( answers, ans);
                  }
                }
              }

            erase( a_4);
          }

          else
            {
              for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator elem_itr = a_6.ref().begin(); elem_itr!=a_6.ref().end(); ++elem_itr){
                std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  elem = *elem_itr;
                erase( elem.second);
              }
            }

          erase( a_6);
        }

        erase( a_5);
      }

    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > eval = h_bt(answers, ml_comps4_table.get(t_0_i, t_0_j));
  erase( answers);
  intrusive_ptr<Backtrace<String, unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::bt_nt_multiloop(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 18))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);


  if (stackpairing(t_0_seq, t_0_i, t_0_j))
  {
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_1;
    empty(ret_1);
    if (((t_0_j - t_0_i) >= 20))
    {
      TUSubsequence ret_7 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
      TUSubsequence a_5 = ret_7;
      if (is_not_empty(a_5))
      {
        TUSubsequence ret_6 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
        TUSubsequence a_4 = ret_6;
        if (is_not_empty(a_4))
        {
          TUSubsequence ret_4 = BASE(t_0_seq, (t_0_i + 2), ((t_0_i + 2) + 1));
          TUSubsequence a_2 = ret_4;
          if (is_not_empty(a_2))
          {
            TUSubsequence ret_3 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
            TUSubsequence a_1 = ret_3;
            if (is_not_empty(a_1))
            {
              TUSubsequence ret_2 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
              TUSubsequence a_0 = ret_2;
              if (is_not_empty(a_0))
              {
                List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_5 = bt_proxy_nt_ml_comps1((t_0_i + 3), (t_0_j - 2));
                List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_3 = ret_5;
                if (is_not_empty(a_3))
                  {
                    for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_3_itr = a_3.ref().begin(); x_3_itr!=a_3.ref().end(); ++x_3_itr){
                      std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_3 = *x_3_itr;
                      std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = mldl_bt(a_0, a_1, a_2, x_3, a_4, a_5);
                      push_back( ret_1, ans);
                    }
                  }

                erase( a_3);
              }

              erase( a_0);
            }

            erase( a_1);
          }

          erase( a_2);
        }

        erase( a_4);
      }

      erase( a_5);
    }

    finalize( ret_1);
    append( answers, ret_1);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_8;
    empty(ret_8);
    if (((t_0_j - t_0_i) >= 19))
    {
      TUSubsequence ret_14 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
      TUSubsequence a_11 = ret_14;
      if (is_not_empty(a_11))
      {
        TUSubsequence ret_13 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
        TUSubsequence a_10 = ret_13;
        if (is_not_empty(a_10))
        {
          TUSubsequence ret_11 = BASE(t_0_seq, (t_0_i + 2), ((t_0_i + 2) + 1));
          TUSubsequence a_8 = ret_11;
          if (is_not_empty(a_8))
          {
            TUSubsequence ret_10 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
            TUSubsequence a_7 = ret_10;
            if (is_not_empty(a_7))
            {
              TUSubsequence ret_9 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
              TUSubsequence a_6 = ret_9;
              if (is_not_empty(a_6))
              {
                List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_12 = bt_proxy_nt_ml_comps2((t_0_i + 3), (t_0_j - 2));
                List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_9 = ret_12;
                if (is_not_empty(a_9))
                  {
                    for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_9_itr = a_9.ref().begin(); x_9_itr!=a_9.ref().end(); ++x_9_itr){
                      std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_9 = *x_9_itr;
                      std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = mladl_bt(a_6, a_7, a_8, x_9, a_10, a_11);
                      push_back( ret_8, ans);
                    }
                  }

                erase( a_9);
              }

              erase( a_6);
            }

            erase( a_7);
          }

          erase( a_8);
        }

        erase( a_10);
      }

      erase( a_11);
    }

    finalize( ret_8);
    append( answers, ret_8);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_15;
    empty(ret_15);
    if (((t_0_j - t_0_i) >= 20))
    {
      TUSubsequence ret_21 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
      TUSubsequence a_17 = ret_21;
      if (is_not_empty(a_17))
      {
        TUSubsequence ret_20 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
        TUSubsequence a_16 = ret_20;
        if (is_not_empty(a_16))
        {
          TUSubsequence ret_19 = BASE(t_0_seq, (t_0_j - 3), (t_0_j - 2));
          TUSubsequence a_15 = ret_19;
          if (is_not_empty(a_15))
          {
            TUSubsequence ret_17 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
            TUSubsequence a_13 = ret_17;
            if (is_not_empty(a_13))
            {
              TUSubsequence ret_16 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
              TUSubsequence a_12 = ret_16;
              if (is_not_empty(a_12))
              {
                List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_18 = bt_proxy_nt_ml_comps3((t_0_i + 2), (t_0_j - 3));
                List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_14 = ret_18;
                if (is_not_empty(a_14))
                  {
                    for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_14_itr = a_14.ref().begin(); x_14_itr!=a_14.ref().end(); ++x_14_itr){
                      std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_14 = *x_14_itr;
                      std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = mldr_bt(a_12, a_13, x_14, a_15, a_16, a_17);
                      push_back( ret_15, ans);
                    }
                  }

                erase( a_14);
              }

              erase( a_12);
            }

            erase( a_13);
          }

          erase( a_15);
        }

        erase( a_16);
      }

      erase( a_17);
    }

    finalize( ret_15);
    append( answers, ret_15);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_22;
    empty(ret_22);
    if (((t_0_j - t_0_i) >= 19))
    {
      TUSubsequence ret_28 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
      TUSubsequence a_23 = ret_28;
      if (is_not_empty(a_23))
      {
        TUSubsequence ret_27 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
        TUSubsequence a_22 = ret_27;
        if (is_not_empty(a_22))
        {
          TUSubsequence ret_26 = BASE(t_0_seq, (t_0_j - 3), (t_0_j - 2));
          TUSubsequence a_21 = ret_26;
          if (is_not_empty(a_21))
          {
            TUSubsequence ret_24 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
            TUSubsequence a_19 = ret_24;
            if (is_not_empty(a_19))
            {
              TUSubsequence ret_23 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
              TUSubsequence a_18 = ret_23;
              if (is_not_empty(a_18))
              {
                List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_25 = bt_proxy_nt_ml_comps2((t_0_i + 2), (t_0_j - 3));
                List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_20 = ret_25;
                if (is_not_empty(a_20))
                  {
                    for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_20_itr = a_20.ref().begin(); x_20_itr!=a_20.ref().end(); ++x_20_itr){
                      std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_20 = *x_20_itr;
                      std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = mladr_bt(a_18, a_19, x_20, a_21, a_22, a_23);
                      push_back( ret_22, ans);
                    }
                  }

                erase( a_20);
              }

              erase( a_18);
            }

            erase( a_19);
          }

          erase( a_21);
        }

        erase( a_22);
      }

      erase( a_23);
    }

    finalize( ret_22);
    append( answers, ret_22);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_29;
    empty(ret_29);
    if (((t_0_j - t_0_i) >= 22))
    {
      TUSubsequence ret_36 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
      TUSubsequence a_30 = ret_36;
      if (is_not_empty(a_30))
      {
        TUSubsequence ret_35 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
        TUSubsequence a_29 = ret_35;
        if (is_not_empty(a_29))
        {
          TUSubsequence ret_34 = BASE(t_0_seq, (t_0_j - 3), (t_0_j - 2));
          TUSubsequence a_28 = ret_34;
          if (is_not_empty(a_28))
          {
            TUSubsequence ret_32 = BASE(t_0_seq, (t_0_i + 2), ((t_0_i + 2) + 1));
            TUSubsequence a_26 = ret_32;
            if (is_not_empty(a_26))
            {
              TUSubsequence ret_31 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
              TUSubsequence a_25 = ret_31;
              if (is_not_empty(a_25))
              {
                TUSubsequence ret_30 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
                TUSubsequence a_24 = ret_30;
                if (is_not_empty(a_24))
                {
                  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_33 = bt_proxy_nt_ml_comps4((t_0_i + 3), (t_0_j - 3));
                  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_27 = ret_33;
                  if (is_not_empty(a_27))
                    {
                      for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_27_itr = a_27.ref().begin(); x_27_itr!=a_27.ref().end(); ++x_27_itr){
                        std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_27 = *x_27_itr;
                        std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = mldlr_bt(a_24, a_25, a_26, x_27, a_28, a_29, a_30);
                        push_back( ret_29, ans);
                      }
                    }

                  erase( a_27);
                }

                erase( a_24);
              }

              erase( a_25);
            }

            erase( a_26);
          }

          erase( a_28);
        }

        erase( a_29);
      }

      erase( a_30);
    }

    finalize( ret_29);
    append( answers, ret_29);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_37;
    empty(ret_37);
    if (((t_0_j - t_0_i) >= 20))
    {
      TUSubsequence ret_44 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
      TUSubsequence a_37 = ret_44;
      if (is_not_empty(a_37))
      {
        TUSubsequence ret_43 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
        TUSubsequence a_36 = ret_43;
        if (is_not_empty(a_36))
        {
          TUSubsequence ret_42 = BASE(t_0_seq, (t_0_j - 3), (t_0_j - 2));
          TUSubsequence a_35 = ret_42;
          if (is_not_empty(a_35))
          {
            TUSubsequence ret_40 = BASE(t_0_seq, (t_0_i + 2), ((t_0_i + 2) + 1));
            TUSubsequence a_33 = ret_40;
            if (is_not_empty(a_33))
            {
              TUSubsequence ret_39 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
              TUSubsequence a_32 = ret_39;
              if (is_not_empty(a_32))
              {
                TUSubsequence ret_38 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
                TUSubsequence a_31 = ret_38;
                if (is_not_empty(a_31))
                {
                  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_41 = bt_proxy_nt_ml_comps2((t_0_i + 3), (t_0_j - 3));
                  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_34 = ret_41;
                  if (is_not_empty(a_34))
                    {
                      for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_34_itr = a_34.ref().begin(); x_34_itr!=a_34.ref().end(); ++x_34_itr){
                        std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_34 = *x_34_itr;
                        std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = mladlr_bt(a_31, a_32, a_33, x_34, a_35, a_36, a_37);
                        push_back( ret_37, ans);
                      }
                    }

                  erase( a_34);
                }

                erase( a_31);
              }

              erase( a_32);
            }

            erase( a_33);
          }

          erase( a_35);
        }

        erase( a_36);
      }

      erase( a_37);
    }

    finalize( ret_37);
    append( answers, ret_37);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_45;
    empty(ret_45);
    if (((t_0_j - t_0_i) >= 21))
    {
      TUSubsequence ret_52 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
      TUSubsequence a_44 = ret_52;
      if (is_not_empty(a_44))
      {
        TUSubsequence ret_51 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
        TUSubsequence a_43 = ret_51;
        if (is_not_empty(a_43))
        {
          TUSubsequence ret_50 = BASE(t_0_seq, (t_0_j - 3), (t_0_j - 2));
          TUSubsequence a_42 = ret_50;
          if (is_not_empty(a_42))
          {
            TUSubsequence ret_48 = BASE(t_0_seq, (t_0_i + 2), ((t_0_i + 2) + 1));
            TUSubsequence a_40 = ret_48;
            if (is_not_empty(a_40))
            {
              TUSubsequence ret_47 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
              TUSubsequence a_39 = ret_47;
              if (is_not_empty(a_39))
              {
                TUSubsequence ret_46 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
                TUSubsequence a_38 = ret_46;
                if (is_not_empty(a_38))
                {
                  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_49 = bt_proxy_nt_ml_comps1((t_0_i + 3), (t_0_j - 3));
                  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_41 = ret_49;
                  if (is_not_empty(a_41))
                    {
                      for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_41_itr = a_41.ref().begin(); x_41_itr!=a_41.ref().end(); ++x_41_itr){
                        std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_41 = *x_41_itr;
                        std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = mldladr_bt(a_38, a_39, a_40, x_41, a_42, a_43, a_44);
                        push_back( ret_45, ans);
                      }
                    }

                  erase( a_41);
                }

                erase( a_38);
              }

              erase( a_39);
            }

            erase( a_40);
          }

          erase( a_42);
        }

        erase( a_43);
      }

      erase( a_44);
    }

    finalize( ret_45);
    append( answers, ret_45);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_53;
    empty(ret_53);
    if (((t_0_j - t_0_i) >= 21))
    {
      TUSubsequence ret_60 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
      TUSubsequence a_51 = ret_60;
      if (is_not_empty(a_51))
      {
        TUSubsequence ret_59 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
        TUSubsequence a_50 = ret_59;
        if (is_not_empty(a_50))
        {
          TUSubsequence ret_58 = BASE(t_0_seq, (t_0_j - 3), (t_0_j - 2));
          TUSubsequence a_49 = ret_58;
          if (is_not_empty(a_49))
          {
            TUSubsequence ret_56 = BASE(t_0_seq, (t_0_i + 2), ((t_0_i + 2) + 1));
            TUSubsequence a_47 = ret_56;
            if (is_not_empty(a_47))
            {
              TUSubsequence ret_55 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
              TUSubsequence a_46 = ret_55;
              if (is_not_empty(a_46))
              {
                TUSubsequence ret_54 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
                TUSubsequence a_45 = ret_54;
                if (is_not_empty(a_45))
                {
                  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_57 = bt_proxy_nt_ml_comps3((t_0_i + 3), (t_0_j - 3));
                  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_48 = ret_57;
                  if (is_not_empty(a_48))
                    {
                      for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_48_itr = a_48.ref().begin(); x_48_itr!=a_48.ref().end(); ++x_48_itr){
                        std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_48 = *x_48_itr;
                        std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = mladldr_bt(a_45, a_46, a_47, x_48, a_49, a_50, a_51);
                        push_back( ret_53, ans);
                      }
                    }

                  erase( a_48);
                }

                erase( a_45);
              }

              erase( a_46);
            }

            erase( a_47);
          }

          erase( a_49);
        }

        erase( a_50);
      }

      erase( a_51);
    }

    finalize( ret_53);
    append( answers, ret_53);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_61;
    empty(ret_61);
    if (((t_0_j - t_0_i) >= 18))
    {
      TUSubsequence ret_66 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
      TUSubsequence a_56 = ret_66;
      if (is_not_empty(a_56))
      {
        TUSubsequence ret_65 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
        TUSubsequence a_55 = ret_65;
        if (is_not_empty(a_55))
        {
          TUSubsequence ret_63 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
          TUSubsequence a_53 = ret_63;
          if (is_not_empty(a_53))
          {
            TUSubsequence ret_62 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
            TUSubsequence a_52 = ret_62;
            if (is_not_empty(a_52))
            {
              List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_64 = bt_proxy_nt_ml_comps2((t_0_i + 2), (t_0_j - 2));
              List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_54 = ret_64;
              if (is_not_empty(a_54))
                {
                  for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_54_itr = a_54.ref().begin(); x_54_itr!=a_54.ref().end(); ++x_54_itr){
                    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_54 = *x_54_itr;
                    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = ml_bt(a_52, a_53, x_54, a_55, a_56);
                    push_back( ret_61, ans);
                  }
                }

              erase( a_54);
            }

            erase( a_52);
          }

          erase( a_53);
        }

        erase( a_55);
      }

      erase( a_56);
    }

    finalize( ret_61);
    append( answers, ret_61);
  }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > eval = h_bt(answers);
  erase( answers);
  intrusive_ptr<Backtrace<String, unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::bt_nt_no_dl_no_ss_end(unsigned int t_0_i, unsigned int t_0_j)
{
  if (!no_dl_no_ss_end_table.is_tabulated(t_0_i, t_0_j))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_0 = bt_proxy_nt_ml_comps2(t_0_i, t_0_j);
  append( answers, ret_0);

  if (((t_0_j - t_0_i) >= 7))
  {
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_2 = bt_proxy_nt_nodangle_ml(t_0_i, t_0_j);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_0 = ret_2;
    if (is_not_empty(a_0))
      {
        for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_0_itr = a_0.ref().begin(); x_0_itr!=a_0.ref().end(); ++x_0_itr){
          std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_0 = *x_0_itr;
          std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = incl_bt(x_0);
          push_back( answers, ans);
        }
      }

    erase( a_0);
  }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > eval = h_bt(answers, no_dl_no_ss_end_table.get(t_0_i, t_0_j));
  erase( answers);
  intrusive_ptr<Backtrace<String, unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::bt_nt_no_dl_ss_end(unsigned int t_0_i, unsigned int t_0_j)
{
  if (!no_dl_ss_end_table.is_tabulated(t_0_i, t_0_j))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_0 = bt_proxy_nt_ml_comps3(t_0_i, t_0_j);
  append( answers, ret_0);

  if (((t_0_j - t_0_i) >= 8))
  {
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_2 = bt_proxy_nt_edangler_ml(t_0_i, t_0_j);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_0 = ret_2;
    if (is_not_empty(a_0))
      {
        for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_0_itr = a_0.ref().begin(); x_0_itr!=a_0.ref().end(); ++x_0_itr){
          std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_0 = *x_0_itr;
          std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = incl_bt(x_0);
          push_back( answers, ans);
        }
      }

    erase( a_0);
  }


  if (((t_0_j - t_0_i) >= 9))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 8); (t_0_k_0 <= (t_0_j - 1)); ++t_0_k_0)
      {
        TUSubsequence ret_6 = REGION(t_0_seq, t_0_k_0, t_0_j);
        TUSubsequence a_3 = ret_6;
        if (is_not_empty(a_3))
        {
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_4;
          empty(ret_4);
          if (((t_0_k_0 - t_0_i) >= 8))
          {
            List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_5 = bt_proxy_nt_edangler_ml(t_0_i, t_0_k_0);
            List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_2 = ret_5;
            if (is_not_empty(a_2))
              {
                for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_2 = *x_2_itr;
                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = incl_bt(x_2);
                  push_back( ret_4, ans);
                }
              }

            erase( a_2);
          }

          finalize( ret_4);
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_1 = ret_4;
          if (is_not_empty(a_1))
            {
              for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
                std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_1 = *x_1_itr;
                std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = addss_bt(x_1, a_3);
                push_back( answers, ans);
              }
            }

          erase( a_1);
        }

        erase( a_3);
      }

    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > eval = h_bt(answers, no_dl_ss_end_table.get(t_0_i, t_0_j));
  erase( answers);
  intrusive_ptr<Backtrace<String, unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::bt_nt_nodangle_ml(unsigned int t_0_i, unsigned int t_0_j)
{
  if (!nodangle_ml_table.is_tabulated(t_0_i, t_0_j))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 7))
  {
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_1 = bt_proxy_nt_initstem(t_0_i, t_0_j);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_0 = ret_1;
    if (is_not_empty(a_0))
      {
        for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_0_itr = a_0.ref().begin(); x_0_itr!=a_0.ref().end(); ++x_0_itr){
          std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_0 = *x_0_itr;
          std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = drem_bt(x_0);
          push_back( answers, ans);
        }
      }

    erase( a_0);
  }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > eval = h_bt(answers, nodangle_ml_table.get(t_0_i, t_0_j));
  erase( answers);
  intrusive_ptr<Backtrace<String, unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::bt_nt_nodangle_struct(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 7))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 7))
  {
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_1 = bt_proxy_nt_initstem(t_0_i, t_0_j);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_0 = ret_1;
    if (is_not_empty(a_0))
      {
        for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_0_itr = a_0.ref().begin(); x_0_itr!=a_0.ref().end(); ++x_0_itr){
          std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_0 = *x_0_itr;
          std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = drem_bt(x_0);
          push_back( answers, ans);
        }
      }

    erase( a_0);
  }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > eval = h_bt(answers);
  erase( answers);
  intrusive_ptr<Backtrace<String, unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::bt_nt_noleft_dangle(unsigned int t_0_i)
{
  if (!noleft_dangle_table.is_tabulated(t_0_i))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);

  if (((t_0_right_most - t_0_i) >= 8))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 8); (t_0_k_0 <= t_0_right_most); ++t_0_k_0)
      {
        List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_2;
        empty(ret_2);
        empty( ret_2);
        List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_3 = bt_proxy_nt_left_dangle(t_0_k_0);
        append( ret_2, ret_3);
        List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_4 = bt_proxy_nt_left_unpaired(t_0_k_0);
        append( ret_2, ret_4);
        finalize( ret_2);
        List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_1 = ret_2;
        if (is_not_empty(a_1))
        {
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_1 = bt_proxy_nt_edangler_struct(t_0_i, t_0_k_0);
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_0 = ret_1;
          if (is_not_empty(a_0))
            {
              for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_0_itr = a_0.ref().begin(); x_0_itr!=a_0.ref().end(); ++x_0_itr){
                std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_0 = *x_0_itr;
                for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_1 = *x_1_itr;
                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = cadd_Pr_Pr_bt(x_0, x_1);
                  push_back( answers, ans);
                }
              }
            }

          erase( a_0);
        }

        else
          {
            for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator elem_itr = a_1.ref().begin(); elem_itr!=a_1.ref().end(); ++elem_itr){
              std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  elem = *elem_itr;
              erase( elem.second);
            }
          }

        erase( a_1);
      }

    }


  if (((t_0_right_most - t_0_i) >= 7))
    {
      for(      unsigned int t_0_k_1 = (t_0_i + 7); (t_0_k_1 <= t_0_right_most); ++t_0_k_1)
      {
        List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_7;
        empty(ret_7);
        empty( ret_7);
        List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_8 = bt_proxy_nt_noleft_dangle(t_0_k_1);
        append( ret_7, ret_8);
        std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ret_9;
        if ((((t_0_right_most - t_0_k_1) >= 0) && ((t_0_right_most - t_0_k_1) <= 0)))
        {
          TUSubsequence ret_10 = LOC(t_0_seq, t_0_k_1, t_0_k_1);
          TUSubsequence a_4 = ret_10;
          if (is_not_empty(a_4))
            {
              ret_9 = nil_Pr_bt(a_4);
            }

          else
            {
              empty( ret_9);
            }

          erase( a_4);
        }

        else
          {
            empty( ret_9);
          }

        if (is_not_empty(ret_9))
          {
            push_back( ret_7, ret_9);
          }

        finalize( ret_7);
        List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_3 = ret_7;
        if (is_not_empty(a_3))
        {
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_6 = bt_proxy_nt_nodangle_struct(t_0_i, t_0_k_1);
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_2 = ret_6;
          if (is_not_empty(a_2))
            {
              for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_2 = *x_2_itr;
                for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_3_itr = a_3.ref().begin(); x_3_itr!=a_3.ref().end(); ++x_3_itr){
                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_3 = *x_3_itr;
                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = cadd_Pr_Pr_Pr_bt(x_2, x_3);
                  push_back( answers, ans);
                }
              }
            }

          erase( a_2);
        }

        else
          {
            for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator elem_itr = a_3.ref().begin(); elem_itr!=a_3.ref().end(); ++elem_itr){
              std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  elem = *elem_itr;
              erase( elem.second);
            }
          }

        erase( a_3);
      }

    }


  if (((t_0_right_most - t_0_i) >= 15))
    {
      for(      unsigned int t_0_k_2 = (t_0_i + 7); (t_0_k_2 <= (t_0_right_most - 8)); ++t_0_k_2)
      {
        TUSubsequence ret_13 = BASE(t_0_seq, t_0_k_2, (t_0_k_2 + 1));
        TUSubsequence a_6 = ret_13;
        if (is_not_empty(a_6))
        {
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_14 = bt_proxy_nt_noleft_dangle((t_0_k_2 + 1));
          List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_7 = ret_14;
          if (is_not_empty(a_7))
          {
            List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_12 = bt_proxy_nt_nodangle_struct(t_0_i, t_0_k_2);
            List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_5 = ret_12;
            if (is_not_empty(a_5))
              {
                for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_5_itr = a_5.ref().begin(); x_5_itr!=a_5.ref().end(); ++x_5_itr){
                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_5 = *x_5_itr;
                  for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_7_itr = a_7.ref().begin(); x_7_itr!=a_7.ref().end(); ++x_7_itr){
                    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_7 = *x_7_itr;
                    std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = ambd_Pr_bt(x_5, a_6, x_7);
                    push_back( answers, ans);
                  }
                }
              }

            erase( a_5);
          }

          else
            {
              for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator elem_itr = a_7.ref().begin(); elem_itr!=a_7.ref().end(); ++elem_itr){
                std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  elem = *elem_itr;
                erase( elem.second);
              }
            }

          erase( a_7);
        }

        erase( a_6);
      }

    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > eval = h_bt(answers, noleft_dangle_table.get(t_0_i));
  erase( answers);
  intrusive_ptr<Backtrace<String, unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::bt_nt_rightB(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 12))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 12))
    {
      if (stackpairing(t_0_seq, t_0_i, t_0_j))
      {
        TUSubsequence ret_7 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_6 = ret_7;
        if (is_not_empty(a_6))
        {
          TUSubsequence ret_6 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
          TUSubsequence a_5 = ret_6;
          if (is_not_empty(a_5))
          {
            TUSubsequence ret_2 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
            TUSubsequence a_1 = ret_2;
            if (is_not_empty(a_1))
            {
              TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
              TUSubsequence a_0 = ret_1;
              if (is_not_empty(a_0))
              {
                List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_3;
                empty(ret_3);
                if ((((t_0_j - 2) - (t_0_i + 2)) >= 8))
                  {
                    for(                    unsigned int t_0_k_0 = ((t_0_i + 2) + 7); (t_0_k_0 <= ((t_0_j - 2) - 1)); ++t_0_k_0)
                    {
                      TUSubsequence ret_5 = REGION(t_0_seq, t_0_k_0, (t_0_j - 2));
                      TUSubsequence a_4 = ret_5;
                      if (is_not_empty(a_4))
                      {
                        List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_4 = bt_proxy_nt_closed((t_0_i + 2), t_0_k_0);
                        List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_3 = ret_4;
                        if (is_not_empty(a_3))
                          {
                            for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_3_itr = a_3.ref().begin(); x_3_itr!=a_3.ref().end(); ++x_3_itr){
                              std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_3 = *x_3_itr;
                              std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = br_bt(x_3, a_4);
                              push_back( ret_3, ans);
                            }
                          }

                        erase( a_3);
                      }

                      erase( a_4);
                    }

                  }

                finalize( ret_3);
                List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_2 = ret_3;
                if (is_not_empty(a_2))
                  {
                    for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                      std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_2 = *x_2_itr;
                      std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = sp_bt(a_0, a_1, x_2, a_5, a_6);
                      push_back( answers, ans);
                    }
                  }

                erase( a_2);
              }

              erase( a_0);
            }

            erase( a_1);
          }

          erase( a_5);
        }

        erase( a_6);
      }

      else
        {
          empty( answers);
        }

    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > eval = h_bt(answers);
  erase( answers);
  intrusive_ptr<Backtrace<String, unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::bt_nt_stack(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 9))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 9))
    {
      if (basepairing(t_0_seq, t_0_i, t_0_j))
      {
        TUSubsequence ret_3 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_2 = ret_3;
        if (is_not_empty(a_2))
        {
          TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
          TUSubsequence a_0 = ret_1;
          if (is_not_empty(a_0))
          {
            List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_2 = bt_proxy_nt_closed((t_0_i + 1), (t_0_j - 1));
            List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_1 = ret_2;
            if (is_not_empty(a_1))
              {
                for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_1 = *x_1_itr;
                  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = sr_bt(a_0, x_1, a_2);
                  push_back( answers, ans);
                }
              }

            erase( a_1);
          }

          erase( a_0);
        }

        erase( a_2);
      }

      else
        {
          empty( answers);
        }

    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > eval = h_bt(answers);
  erase( answers);
  intrusive_ptr<Backtrace<String, unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::bt_nt_struct()
{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_0 = bt_proxy_nt_left_dangle(t_0_left_most);
  append( answers, ret_0);

  if (((t_0_right_most - t_0_left_most) >= 7))
  {
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_2 = bt_proxy_nt_noleft_dangle(t_0_left_most);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > a_0 = ret_2;
    if (is_not_empty(a_0))
      {
        for (List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator x_0_itr = a_0.ref().begin(); x_0_itr!=a_0.ref().end(); ++x_0_itr){
          std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  x_0 = *x_0_itr;
          std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ans = trafo_bt(x_0);
          push_back( answers, ans);
        }
      }

    erase( a_0);
  }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > ret_3 = bt_proxy_nt_left_unpaired(t_0_left_most);
  append( answers, ret_3);
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > eval = h_bt(answers);
  erase( answers);
  intrusive_ptr<Backtrace<String, unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}


intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::acomb_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<String, unsigned int> >  param_2)
{
  return new Backtrace_acomb<String, unsigned int> (param_0, param_1, param_2);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::addss_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0, const TUSubsequence & param_1)
{
  return new Backtrace_addss<String, unsigned int> (param_0, param_1);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::ambd_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<String, unsigned int> >  param_2)
{
  return new Backtrace_ambd<String, unsigned int> (param_0, param_1, param_2);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::ambd_Pr_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<String, unsigned int> >  param_2)
{
  return new Backtrace_ambd_Pr<String, unsigned int> (param_0, param_1, param_2);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::bl_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1)
{
  return new Backtrace_bl<String, unsigned int> (param_0, param_1);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::br_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0, const TUSubsequence & param_1)
{
  return new Backtrace_br<String, unsigned int> (param_0, param_1);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::cadd_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1)
{
  return new Backtrace_cadd<String, unsigned int> (param_0, param_1);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::cadd_Pr_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1)
{
  return new Backtrace_cadd_Pr<String, unsigned int> (param_0, param_1);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::cadd_Pr_Pr_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1)
{
  return new Backtrace_cadd_Pr_Pr<String, unsigned int> (param_0, param_1);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::cadd_Pr_Pr_Pr_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1)
{
  return new Backtrace_cadd_Pr_Pr_Pr<String, unsigned int> (param_0, param_1);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::combine_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1)
{
  return new Backtrace_combine<String, unsigned int> (param_0, param_1);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::drem_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0)
{
  return new Backtrace_drem<String, unsigned int> (param_0);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::edl_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1)
{
  return new Backtrace_edl<String, unsigned int> (param_0, param_1);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::edlr_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1, const TUSubsequence & param_2)
{
  return new Backtrace_edlr<String, unsigned int> (param_0, param_1, param_2);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::edr_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0, const TUSubsequence & param_1)
{
  return new Backtrace_edr<String, unsigned int> (param_0, param_1);
}

List_Ref<intrusive_ptr<Backtrace<String, unsigned int> > > hishapeh_mfe_pfx::h_bt_r(List_Ref<intrusive_ptr<Backtrace<String, unsigned int> > > param_0)
{
  return param_0;
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::hl_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, const TUSubsequence & param_2, const TUSubsequence & param_3, const TUSubsequence & param_4)
{
  return new Backtrace_hl<String, unsigned int> (param_0, param_1, param_2, param_3, param_4);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::il_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1, const TUSubsequence & param_2)
{
  return new Backtrace_il<String, unsigned int> (param_0, param_1, param_2);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::incl_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0)
{
  return new Backtrace_incl<String, unsigned int> (param_0);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::is_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0)
{
  return new Backtrace_is<String, unsigned int> (param_0);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::ml_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<String, unsigned int> >  param_2, const TUSubsequence & param_3, const TUSubsequence & param_4)
{
  return new Backtrace_ml<String, unsigned int> (param_0, param_1, param_2, param_3, param_4);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::mladl_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, const TUSubsequence & param_2, intrusive_ptr<Backtrace<String, unsigned int> >  param_3, const TUSubsequence & param_4, const TUSubsequence & param_5)
{
  return new Backtrace_mladl<String, unsigned int> (param_0, param_1, param_2, param_3, param_4, param_5);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::mladldr_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, const TUSubsequence & param_2, intrusive_ptr<Backtrace<String, unsigned int> >  param_3, const TUSubsequence & param_4, const TUSubsequence & param_5, const TUSubsequence & param_6)
{
  return new Backtrace_mladldr<String, unsigned int> (param_0, param_1, param_2, param_3, param_4, param_5, param_6);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::mladlr_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, const TUSubsequence & param_2, intrusive_ptr<Backtrace<String, unsigned int> >  param_3, const TUSubsequence & param_4, const TUSubsequence & param_5, const TUSubsequence & param_6)
{
  return new Backtrace_mladlr<String, unsigned int> (param_0, param_1, param_2, param_3, param_4, param_5, param_6);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::mladr_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<String, unsigned int> >  param_2, const TUSubsequence & param_3, const TUSubsequence & param_4, const TUSubsequence & param_5)
{
  return new Backtrace_mladr<String, unsigned int> (param_0, param_1, param_2, param_3, param_4, param_5);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::mldl_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, const TUSubsequence & param_2, intrusive_ptr<Backtrace<String, unsigned int> >  param_3, const TUSubsequence & param_4, const TUSubsequence & param_5)
{
  return new Backtrace_mldl<String, unsigned int> (param_0, param_1, param_2, param_3, param_4, param_5);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::mldladr_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, const TUSubsequence & param_2, intrusive_ptr<Backtrace<String, unsigned int> >  param_3, const TUSubsequence & param_4, const TUSubsequence & param_5, const TUSubsequence & param_6)
{
  return new Backtrace_mldladr<String, unsigned int> (param_0, param_1, param_2, param_3, param_4, param_5, param_6);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::mldlr_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, const TUSubsequence & param_2, intrusive_ptr<Backtrace<String, unsigned int> >  param_3, const TUSubsequence & param_4, const TUSubsequence & param_5, const TUSubsequence & param_6)
{
  return new Backtrace_mldlr<String, unsigned int> (param_0, param_1, param_2, param_3, param_4, param_5, param_6);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::mldr_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<String, unsigned int> >  param_2, const TUSubsequence & param_3, const TUSubsequence & param_4, const TUSubsequence & param_5)
{
  return new Backtrace_mldr<String, unsigned int> (param_0, param_1, param_2, param_3, param_4, param_5);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::nil_bt_r(const TUSubsequence & param_0)
{
  return new Backtrace_nil<String, unsigned int> (param_0);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::nil_Pr_bt_r(const TUSubsequence & param_0)
{
  return new Backtrace_nil_Pr<String, unsigned int> (param_0);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::sadd_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1)
{
  return new Backtrace_sadd<String, unsigned int> (param_0, param_1);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::sp_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<String, unsigned int> >  param_2, const TUSubsequence & param_3, const TUSubsequence & param_4)
{
  return new Backtrace_sp<String, unsigned int> (param_0, param_1, param_2, param_3, param_4);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::sr_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1, const TUSubsequence & param_2)
{
  return new Backtrace_sr<String, unsigned int> (param_0, param_1, param_2);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::ssadd_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1)
{
  return new Backtrace_ssadd<String, unsigned int> (param_0, param_1);
}

intrusive_ptr<Backtrace<String, unsigned int> >  hishapeh_mfe_pfx::trafo_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0)
{
  return new Backtrace_trafo<String, unsigned int> (param_0);
}



std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  hishapeh_mfe_pfx::acomb_bt(const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_le, const TUSubsequence & p_p_b, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_re)
{
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  l_0 = p_p_le.first;
  TUSubsequence l_1 = p_p_b;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  l_2 = p_p_re.first;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_0 = p_p_le.second;
  TUSubsequence r_1 = p_p_b;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_2 = p_p_re.second;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret_left = acomb(l_0, l_1, l_2);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = acomb_bt_r(r_0, r_1, r_2);
  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  hishapeh_mfe_pfx::addss_bt(const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb)
{
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  l_0 = p_p_e.first;
  TUSubsequence l_1 = p_p_rb;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_0 = p_p_e.second;
  TUSubsequence r_1 = p_p_rb;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret_left = addss(l_0, l_1);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = addss_bt_r(r_0, r_1);
  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  hishapeh_mfe_pfx::ambd_bt(const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_le, const TUSubsequence & p_p_b, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_re)
{
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  l_0 = p_p_le.first;
  TUSubsequence l_1 = p_p_b;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  l_2 = p_p_re.first;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_0 = p_p_le.second;
  TUSubsequence r_1 = p_p_b;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_2 = p_p_re.second;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret_left = ambd(l_0, l_1, l_2);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = ambd_bt_r(r_0, r_1, r_2);
  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  hishapeh_mfe_pfx::ambd_Pr_bt(const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_le, const TUSubsequence & p_p_b, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_re)
{
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  l_0 = p_p_le.first;
  TUSubsequence l_1 = p_p_b;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  l_2 = p_p_re.first;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_0 = p_p_le.second;
  TUSubsequence r_1 = p_p_b;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_2 = p_p_re.second;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret_left = ambd_Pr(l_0, l_1, l_2);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = ambd_Pr_bt_r(r_0, r_1, r_2);
  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  hishapeh_mfe_pfx::bl_bt(const TUSubsequence & p_p_lregion, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e)
{
  TUSubsequence l_0 = p_p_lregion;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  l_1 = p_p_e.first;
  TUSubsequence r_0 = p_p_lregion;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_1 = p_p_e.second;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret_left = bl(l_0, l_1);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = bl_bt_r(r_0, r_1);
  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  hishapeh_mfe_pfx::br_bt(const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rregion)
{
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  l_0 = p_p_e.first;
  TUSubsequence l_1 = p_p_rregion;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_0 = p_p_e.second;
  TUSubsequence r_1 = p_p_rregion;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret_left = br(l_0, l_1);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = br_bt_r(r_0, r_1);
  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  hishapeh_mfe_pfx::cadd_bt(const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_le, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_re)
{
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  l_0 = p_p_le.first;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  l_1 = p_p_re.first;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_0 = p_p_le.second;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_1 = p_p_re.second;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret_left = cadd(l_0, l_1);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = cadd_bt_r(r_0, r_1);
  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  hishapeh_mfe_pfx::cadd_Pr_bt(const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_le, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_re)
{
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  l_0 = p_p_le.first;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  l_1 = p_p_re.first;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_0 = p_p_le.second;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_1 = p_p_re.second;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret_left = cadd_Pr(l_0, l_1);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = cadd_Pr_bt_r(r_0, r_1);
  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  hishapeh_mfe_pfx::cadd_Pr_Pr_bt(const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_le, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_re)
{
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  l_0 = p_p_le.first;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  l_1 = p_p_re.first;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_0 = p_p_le.second;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_1 = p_p_re.second;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret_left = cadd_Pr_Pr(l_0, l_1);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = cadd_Pr_Pr_bt_r(r_0, r_1);
  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  hishapeh_mfe_pfx::cadd_Pr_Pr_Pr_bt(const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_le, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_re)
{
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  l_0 = p_p_le.first;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  l_1 = p_p_re.first;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_0 = p_p_le.second;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_1 = p_p_re.second;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret_left = cadd_Pr_Pr_Pr(l_0, l_1);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = cadd_Pr_Pr_Pr_bt_r(r_0, r_1);
  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  hishapeh_mfe_pfx::combine_bt(const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_le, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_re)
{
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  l_0 = p_p_le.first;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  l_1 = p_p_re.first;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_0 = p_p_le.second;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_1 = p_p_re.second;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret_left = combine(l_0, l_1);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = combine_bt_r(r_0, r_1);
  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  hishapeh_mfe_pfx::drem_bt(const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e)
{
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  l_0 = p_p_e.first;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_0 = p_p_e.second;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret_left = drem(l_0);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = drem_bt_r(r_0);
  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  hishapeh_mfe_pfx::edl_bt(const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e)
{
  TUSubsequence l_0 = p_p_lb;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  l_1 = p_p_e.first;
  TUSubsequence r_0 = p_p_lb;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_1 = p_p_e.second;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret_left = edl(l_0, l_1);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = edl_bt_r(r_0, r_1);
  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  hishapeh_mfe_pfx::edlr_bt(const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb)
{
  TUSubsequence l_0 = p_p_lb;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  l_1 = p_p_e.first;
  TUSubsequence l_2 = p_p_rb;
  TUSubsequence r_0 = p_p_lb;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_1 = p_p_e.second;
  TUSubsequence r_2 = p_p_rb;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret_left = edlr(l_0, l_1, l_2);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = edlr_bt_r(r_0, r_1, r_2);
  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  hishapeh_mfe_pfx::edr_bt(const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb)
{
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  l_0 = p_p_e.first;
  TUSubsequence l_1 = p_p_rb;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_0 = p_p_e.second;
  TUSubsequence r_1 = p_p_rb;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret_left = edr(l_0, l_1);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = edr_bt_r(r_0, r_1);
  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > hishapeh_mfe_pfx::h_bt(List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > i, hishapeh_mfe_pfx_hash_h_h_pfx &  left_answers)
{
  std::pair<List<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator, List<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator> range = get_range(i);
  return h_bt(range);
}

template <typename Iterator>
List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > hishapeh_mfe_pfx::h_bt(std::pair<Iterator, Iterator> i, hishapeh_mfe_pfx_hash_h_h_pfx &  left_answers)

{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);


  if (is_empty(left_answers))
  {
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > temp;
    empty(temp);
    empty( temp);
    erase( left_answers);
    return temp;
  }

  for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator elem = left_answers.ref().begin(); elem!=left_answers.ref().end(); ++elem){
    for (Iterator tupel = i.first; tupel != i.second; ++tupel) {
      if (((*tupel).first == (*elem)))
      {
        push_back( answers, (*tupel));
        break;
      }

    }
  }
  return answers;
}

List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > hishapeh_mfe_pfx::h_bt(List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > i)
{
  std::pair<List<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator, List<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > >::iterator> range = get_range(i);
  return h_bt(range);
}

template <typename Iterator>
List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > hishapeh_mfe_pfx::h_bt(std::pair<Iterator, Iterator> i)

{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > answers;
  empty(answers);
  empty( answers);
  std::pair<Proxy::Iterator<Iterator, select1st<typename Iterator::value_type> >  ,Proxy::Iterator<Iterator, select1st<typename Iterator::value_type> > >  left = splice_left(i);
  hishapeh_mfe_pfx_hash_h_h_pfx left_answers = h(left);
  if (is_empty(left_answers))
  {
    List_Ref<std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > > temp;
    empty(temp);
    empty( temp);
    erase( left_answers);
    return temp;
  }

  for (hishapeh_mfe_pfx_hash_h_h_pfx::iterator elem = left_answers.ref().begin(); elem!=left_answers.ref().end(); ++elem){
    for (Iterator tupel = i.first; tupel != i.second; ++tupel) {
      if (((*tupel).first == (*elem)))
      {
        push_back( answers, (*tupel));
        break;
      }

    }
  }
  return answers;
}

std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  hishapeh_mfe_pfx::hl_bt(const TUSubsequence & p_p_llb, const TUSubsequence & p_p_lb, const TUSubsequence & p_p_region, const TUSubsequence & p_p_rb, const TUSubsequence & p_p_rrb)
{
  TUSubsequence l_0 = p_p_llb;
  TUSubsequence l_1 = p_p_lb;
  TUSubsequence l_2 = p_p_region;
  TUSubsequence l_3 = p_p_rb;
  TUSubsequence l_4 = p_p_rrb;
  TUSubsequence r_0 = p_p_llb;
  TUSubsequence r_1 = p_p_lb;
  TUSubsequence r_2 = p_p_region;
  TUSubsequence r_3 = p_p_rb;
  TUSubsequence r_4 = p_p_rrb;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret_left = hl(l_0, l_1, l_2, l_3, l_4);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = hl_bt_r(r_0, r_1, r_2, r_3, r_4);
  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  hishapeh_mfe_pfx::il_bt(const TUSubsequence & p_p_lregion, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rregion)
{
  TUSubsequence l_0 = p_p_lregion;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  l_1 = p_p_e.first;
  TUSubsequence l_2 = p_p_rregion;
  TUSubsequence r_0 = p_p_lregion;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_1 = p_p_e.second;
  TUSubsequence r_2 = p_p_rregion;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret_left = il(l_0, l_1, l_2);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = il_bt_r(r_0, r_1, r_2);
  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  hishapeh_mfe_pfx::incl_bt(const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e)
{
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  l_0 = p_p_e.first;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_0 = p_p_e.second;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret_left = incl(l_0);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = incl_bt_r(r_0);
  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  hishapeh_mfe_pfx::is_bt(const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e)
{
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  l_0 = p_p_e.first;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_0 = p_p_e.second;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret_left = is(l_0);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = is_bt_r(r_0);
  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  hishapeh_mfe_pfx::ml_bt(const TUSubsequence & p_p_llb, const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb, const TUSubsequence & p_p_rrb)
{
  TUSubsequence l_0 = p_p_llb;
  TUSubsequence l_1 = p_p_lb;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  l_2 = p_p_e.first;
  TUSubsequence l_3 = p_p_rb;
  TUSubsequence l_4 = p_p_rrb;
  TUSubsequence r_0 = p_p_llb;
  TUSubsequence r_1 = p_p_lb;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_2 = p_p_e.second;
  TUSubsequence r_3 = p_p_rb;
  TUSubsequence r_4 = p_p_rrb;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret_left = ml(l_0, l_1, l_2, l_3, l_4);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = ml_bt_r(r_0, r_1, r_2, r_3, r_4);
  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  hishapeh_mfe_pfx::mladl_bt(const TUSubsequence & p_p_llb, const TUSubsequence & p_p_lb, const TUSubsequence & p_p_dl, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb, const TUSubsequence & p_p_rrb)
{
  TUSubsequence l_0 = p_p_llb;
  TUSubsequence l_1 = p_p_lb;
  TUSubsequence l_2 = p_p_dl;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  l_3 = p_p_e.first;
  TUSubsequence l_4 = p_p_rb;
  TUSubsequence l_5 = p_p_rrb;
  TUSubsequence r_0 = p_p_llb;
  TUSubsequence r_1 = p_p_lb;
  TUSubsequence r_2 = p_p_dl;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_3 = p_p_e.second;
  TUSubsequence r_4 = p_p_rb;
  TUSubsequence r_5 = p_p_rrb;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret_left = mladl(l_0, l_1, l_2, l_3, l_4, l_5);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = mladl_bt_r(r_0, r_1, r_2, r_3, r_4, r_5);
  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  hishapeh_mfe_pfx::mladldr_bt(const TUSubsequence & p_p_llb, const TUSubsequence & p_p_lb, const TUSubsequence & p_p_dl, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_dr, const TUSubsequence & p_p_rb, const TUSubsequence & p_p_rrb)
{
  TUSubsequence l_0 = p_p_llb;
  TUSubsequence l_1 = p_p_lb;
  TUSubsequence l_2 = p_p_dl;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  l_3 = p_p_e.first;
  TUSubsequence l_4 = p_p_dr;
  TUSubsequence l_5 = p_p_rb;
  TUSubsequence l_6 = p_p_rrb;
  TUSubsequence r_0 = p_p_llb;
  TUSubsequence r_1 = p_p_lb;
  TUSubsequence r_2 = p_p_dl;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_3 = p_p_e.second;
  TUSubsequence r_4 = p_p_dr;
  TUSubsequence r_5 = p_p_rb;
  TUSubsequence r_6 = p_p_rrb;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret_left = mladldr(l_0, l_1, l_2, l_3, l_4, l_5, l_6);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = mladldr_bt_r(r_0, r_1, r_2, r_3, r_4, r_5, r_6);
  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  hishapeh_mfe_pfx::mladlr_bt(const TUSubsequence & p_p_llb, const TUSubsequence & p_p_lb, const TUSubsequence & p_p_dl, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_dr, const TUSubsequence & p_p_rb, const TUSubsequence & p_p_rrb)
{
  TUSubsequence l_0 = p_p_llb;
  TUSubsequence l_1 = p_p_lb;
  TUSubsequence l_2 = p_p_dl;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  l_3 = p_p_e.first;
  TUSubsequence l_4 = p_p_dr;
  TUSubsequence l_5 = p_p_rb;
  TUSubsequence l_6 = p_p_rrb;
  TUSubsequence r_0 = p_p_llb;
  TUSubsequence r_1 = p_p_lb;
  TUSubsequence r_2 = p_p_dl;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_3 = p_p_e.second;
  TUSubsequence r_4 = p_p_dr;
  TUSubsequence r_5 = p_p_rb;
  TUSubsequence r_6 = p_p_rrb;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret_left = mladlr(l_0, l_1, l_2, l_3, l_4, l_5, l_6);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = mladlr_bt_r(r_0, r_1, r_2, r_3, r_4, r_5, r_6);
  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  hishapeh_mfe_pfx::mladr_bt(const TUSubsequence & p_p_llb, const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_dr, const TUSubsequence & p_p_rb, const TUSubsequence & p_p_rrb)
{
  TUSubsequence l_0 = p_p_llb;
  TUSubsequence l_1 = p_p_lb;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  l_2 = p_p_e.first;
  TUSubsequence l_3 = p_p_dr;
  TUSubsequence l_4 = p_p_rb;
  TUSubsequence l_5 = p_p_rrb;
  TUSubsequence r_0 = p_p_llb;
  TUSubsequence r_1 = p_p_lb;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_2 = p_p_e.second;
  TUSubsequence r_3 = p_p_dr;
  TUSubsequence r_4 = p_p_rb;
  TUSubsequence r_5 = p_p_rrb;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret_left = mladr(l_0, l_1, l_2, l_3, l_4, l_5);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = mladr_bt_r(r_0, r_1, r_2, r_3, r_4, r_5);
  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  hishapeh_mfe_pfx::mldl_bt(const TUSubsequence & p_p_llb, const TUSubsequence & p_p_lb, const TUSubsequence & p_p_dl, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb, const TUSubsequence & p_p_rrb)
{
  TUSubsequence l_0 = p_p_llb;
  TUSubsequence l_1 = p_p_lb;
  TUSubsequence l_2 = p_p_dl;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  l_3 = p_p_e.first;
  TUSubsequence l_4 = p_p_rb;
  TUSubsequence l_5 = p_p_rrb;
  TUSubsequence r_0 = p_p_llb;
  TUSubsequence r_1 = p_p_lb;
  TUSubsequence r_2 = p_p_dl;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_3 = p_p_e.second;
  TUSubsequence r_4 = p_p_rb;
  TUSubsequence r_5 = p_p_rrb;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret_left = mldl(l_0, l_1, l_2, l_3, l_4, l_5);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = mldl_bt_r(r_0, r_1, r_2, r_3, r_4, r_5);
  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  hishapeh_mfe_pfx::mldladr_bt(const TUSubsequence & p_p_llb, const TUSubsequence & p_p_lb, const TUSubsequence & p_p_dl, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_dr, const TUSubsequence & p_p_rb, const TUSubsequence & p_p_rrb)
{
  TUSubsequence l_0 = p_p_llb;
  TUSubsequence l_1 = p_p_lb;
  TUSubsequence l_2 = p_p_dl;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  l_3 = p_p_e.first;
  TUSubsequence l_4 = p_p_dr;
  TUSubsequence l_5 = p_p_rb;
  TUSubsequence l_6 = p_p_rrb;
  TUSubsequence r_0 = p_p_llb;
  TUSubsequence r_1 = p_p_lb;
  TUSubsequence r_2 = p_p_dl;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_3 = p_p_e.second;
  TUSubsequence r_4 = p_p_dr;
  TUSubsequence r_5 = p_p_rb;
  TUSubsequence r_6 = p_p_rrb;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret_left = mldladr(l_0, l_1, l_2, l_3, l_4, l_5, l_6);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = mldladr_bt_r(r_0, r_1, r_2, r_3, r_4, r_5, r_6);
  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  hishapeh_mfe_pfx::mldlr_bt(const TUSubsequence & p_p_llb, const TUSubsequence & p_p_lb, const TUSubsequence & p_p_dl, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_dr, const TUSubsequence & p_p_rb, const TUSubsequence & p_p_rrb)
{
  TUSubsequence l_0 = p_p_llb;
  TUSubsequence l_1 = p_p_lb;
  TUSubsequence l_2 = p_p_dl;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  l_3 = p_p_e.first;
  TUSubsequence l_4 = p_p_dr;
  TUSubsequence l_5 = p_p_rb;
  TUSubsequence l_6 = p_p_rrb;
  TUSubsequence r_0 = p_p_llb;
  TUSubsequence r_1 = p_p_lb;
  TUSubsequence r_2 = p_p_dl;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_3 = p_p_e.second;
  TUSubsequence r_4 = p_p_dr;
  TUSubsequence r_5 = p_p_rb;
  TUSubsequence r_6 = p_p_rrb;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret_left = mldlr(l_0, l_1, l_2, l_3, l_4, l_5, l_6);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = mldlr_bt_r(r_0, r_1, r_2, r_3, r_4, r_5, r_6);
  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  hishapeh_mfe_pfx::mldr_bt(const TUSubsequence & p_p_llb, const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_dr, const TUSubsequence & p_p_rb, const TUSubsequence & p_p_rrb)
{
  TUSubsequence l_0 = p_p_llb;
  TUSubsequence l_1 = p_p_lb;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  l_2 = p_p_e.first;
  TUSubsequence l_3 = p_p_dr;
  TUSubsequence l_4 = p_p_rb;
  TUSubsequence l_5 = p_p_rrb;
  TUSubsequence r_0 = p_p_llb;
  TUSubsequence r_1 = p_p_lb;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_2 = p_p_e.second;
  TUSubsequence r_3 = p_p_dr;
  TUSubsequence r_4 = p_p_rb;
  TUSubsequence r_5 = p_p_rrb;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret_left = mldr(l_0, l_1, l_2, l_3, l_4, l_5);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = mldr_bt_r(r_0, r_1, r_2, r_3, r_4, r_5);
  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  hishapeh_mfe_pfx::nil_bt(const TUSubsequence & p_p_loc)
{
  TUSubsequence l_0 = p_p_loc;
  TUSubsequence r_0 = p_p_loc;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret_left = nil(l_0);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = nil_bt_r(r_0);
  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  hishapeh_mfe_pfx::nil_Pr_bt(const TUSubsequence & p_p_loc)
{
  TUSubsequence l_0 = p_p_loc;
  TUSubsequence r_0 = p_p_loc;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret_left = nil_Pr(l_0);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = nil_Pr_bt_r(r_0);
  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  hishapeh_mfe_pfx::sadd_bt(const TUSubsequence & p_p_b, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e)
{
  TUSubsequence l_0 = p_p_b;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  l_1 = p_p_e.first;
  TUSubsequence r_0 = p_p_b;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_1 = p_p_e.second;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret_left = sadd(l_0, l_1);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = sadd_bt_r(r_0, r_1);
  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  hishapeh_mfe_pfx::sp_bt(const TUSubsequence & p_p_llb, const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb, const TUSubsequence & p_p_rrb)
{
  TUSubsequence l_0 = p_p_llb;
  TUSubsequence l_1 = p_p_lb;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  l_2 = p_p_e.first;
  TUSubsequence l_3 = p_p_rb;
  TUSubsequence l_4 = p_p_rrb;
  TUSubsequence r_0 = p_p_llb;
  TUSubsequence r_1 = p_p_lb;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_2 = p_p_e.second;
  TUSubsequence r_3 = p_p_rb;
  TUSubsequence r_4 = p_p_rrb;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret_left = sp(l_0, l_1, l_2, l_3, l_4);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = sp_bt_r(r_0, r_1, r_2, r_3, r_4);
  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  hishapeh_mfe_pfx::sr_bt(const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb)
{
  TUSubsequence l_0 = p_p_lb;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  l_1 = p_p_e.first;
  TUSubsequence l_2 = p_p_rb;
  TUSubsequence r_0 = p_p_lb;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_1 = p_p_e.second;
  TUSubsequence r_2 = p_p_rb;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret_left = sr(l_0, l_1, l_2);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = sr_bt_r(r_0, r_1, r_2);
  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  hishapeh_mfe_pfx::ssadd_bt(const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e)
{
  TUSubsequence l_0 = p_p_lb;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  l_1 = p_p_e.first;
  TUSubsequence r_0 = p_p_lb;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_1 = p_p_e.second;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret_left = ssadd(l_0, l_1);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = ssadd_bt_r(r_0, r_1);
  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  hishapeh_mfe_pfx::trafo_bt(const std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e)
{
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  l_0 = p_p_e.first;
  intrusive_ptr<Backtrace<String, unsigned int> >  r_0 = p_p_e.second;
  std::pair<Rope, std::pair<mfeanswer, pfanswer> >  ret_left = trafo(l_0);
  intrusive_ptr<Backtrace<String, unsigned int> >  ret_right = trafo_bt_r(r_0);
  std::pair<std::pair<Rope, std::pair<mfeanswer, pfanswer> > , intrusive_ptr<Backtrace<String, unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}


