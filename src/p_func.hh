
// A dynamic programming evaluator generated by GAP-C.
// 
//   GAP-C version:
//     bellmansgapc-2012.05.07
// 
//   GAP-C call:
//     /home/jhuang/gapc/bin/gapc hishapes.gap -i p_func -o p_func.cc -t 
// 
// 


#ifndef p_func_hh
#define p_func_hh

#include "rtlib/adp.hh"

typedef Basic_Subsequence<char, unsigned> TUSubsequence;

#include <rtlib/subopt.hh>
#include "rna.hh"
#include "filter_add.hh"
#include "mfe_answer.hh"
#include "pf_answer.hh"

#include <rtlib/generic_opts.hh>

class p_func {

  public:
Basic_Sequence<char> t_0_seq;
unsigned int t_0_left_most;
unsigned int t_0_right_most;

pfanswer pfanswer_zero;

class block_dl_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<pfanswer > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
pfanswer zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

block_dl_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 8))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
pfanswer &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 8))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j, const pfanswer & e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 8))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
block_dl_table_t block_dl_table;


class block_dlr_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<pfanswer > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
pfanswer zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

block_dlr_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 9))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
pfanswer &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 9))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j, const pfanswer & e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 9))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
block_dlr_table_t block_dlr_table;


class closed_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<pfanswer > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
pfanswer zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

closed_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 7))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
pfanswer &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 7))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j, const pfanswer & e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 7))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
closed_table_t closed_table;


class dl_or_ss_left_ss_end_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<pfanswer > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
pfanswer zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

dl_or_ss_left_ss_end_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 9))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
pfanswer &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 9))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j, const pfanswer & e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 9))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
dl_or_ss_left_ss_end_table_t dl_or_ss_left_ss_end_table;


class edangler_ml_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<pfanswer > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
pfanswer zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

edangler_ml_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 8))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
pfanswer &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 8))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j, const pfanswer & e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 8))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
edangler_ml_table_t edangler_ml_table;


class left_dangle_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<pfanswer > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
pfanswer zero;
unsigned int size()
{
  return (1 * ((t_0_n + 1) * 1));
}


public:

left_dangle_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i)
{
  unsigned int t_0_j = t_0_n;
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if ((t_0_j < (t_0_n - 0)))
    {
      return true;
    }

  unsigned int t_0_real_j = (t_0_n - t_0_j);
  return tabulated[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))];
}


void clear() { tabulated.clear(); }
pfanswer &  get(unsigned int t_0_i)
{
  unsigned int t_0_j = t_0_n;
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if ((t_0_j < (t_0_n - 0)))
    {
      return zero;
    }

  unsigned int t_0_real_j = (t_0_n - t_0_j);
  assert( tabulated[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))]);
  assert( ((0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1))))) < size()));
  return array[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))];
}


void set(unsigned int t_0_i, const pfanswer & e)
{
  unsigned int t_0_j = t_0_n;
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if ((t_0_j < (t_0_n - 0)))
    {
      return;
    }

  unsigned int t_0_real_j = (t_0_n - t_0_j);
  assert( !is_tabulated(t_0_i));
  assert( ((0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1))))) < size()));
  array[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))] = e;
  tabulated[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))] = true;
}


};
left_dangle_table_t left_dangle_table;


class left_unpaired_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<pfanswer > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
pfanswer zero;
unsigned int size()
{
  return (1 * ((t_0_n + 1) * 1));
}


public:

left_unpaired_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i)
{
  if (((t_0_right_most - t_0_i) < 1))
    {
      return true;
    }

  unsigned int t_0_j = t_0_n;
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if ((t_0_j < (t_0_n - 0)))
    {
      return true;
    }

  unsigned int t_0_real_j = (t_0_n - t_0_j);
  return tabulated[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))];
}


void clear() { tabulated.clear(); }
pfanswer &  get(unsigned int t_0_i)
{
  unsigned int t_0_j = t_0_n;
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if ((t_0_j < (t_0_n - 0)))
    {
      return zero;
    }

  unsigned int t_0_real_j = (t_0_n - t_0_j);
  if (((t_0_right_most - t_0_i) < 1))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))]);
  assert( ((0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1))))) < size()));
  return array[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))];
}


void set(unsigned int t_0_i, const pfanswer & e)
{
  unsigned int t_0_j = t_0_n;
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if ((t_0_j < (t_0_n - 0)))
    {
      return;
    }

  unsigned int t_0_real_j = (t_0_n - t_0_j);
  if (((t_0_right_most - t_0_i) < 1))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i));
  assert( ((0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1))))) < size()));
  array[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))] = e;
  tabulated[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))] = true;
}


};
left_unpaired_table_t left_unpaired_table;


class ml_comps1_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<pfanswer > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
pfanswer zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

ml_comps1_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 15))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
pfanswer &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 15))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j, const pfanswer & e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 15))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
ml_comps1_table_t ml_comps1_table;


class ml_comps2_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<pfanswer > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
pfanswer zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

ml_comps2_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 14))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
pfanswer &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 14))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j, const pfanswer & e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 14))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
ml_comps2_table_t ml_comps2_table;


class ml_comps3_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<pfanswer > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
pfanswer zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

ml_comps3_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 15))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
pfanswer &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 15))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j, const pfanswer & e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 15))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
ml_comps3_table_t ml_comps3_table;


class ml_comps4_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<pfanswer > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
pfanswer zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

ml_comps4_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 16))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
pfanswer &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 16))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j, const pfanswer & e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 16))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
ml_comps4_table_t ml_comps4_table;


class no_dl_no_ss_end_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<pfanswer > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
pfanswer zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

no_dl_no_ss_end_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 7))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
pfanswer &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 7))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j, const pfanswer & e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 7))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
no_dl_no_ss_end_table_t no_dl_no_ss_end_table;


class no_dl_ss_end_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<pfanswer > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
pfanswer zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

no_dl_ss_end_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 8))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
pfanswer &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 8))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j, const pfanswer & e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 8))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
no_dl_ss_end_table_t no_dl_ss_end_table;


class nodangle_ml_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<pfanswer > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
pfanswer zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

nodangle_ml_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 7))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
pfanswer &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 7))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j, const pfanswer & e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 7))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
nodangle_ml_table_t nodangle_ml_table;


class noleft_dangle_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<pfanswer > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
pfanswer zero;
unsigned int size()
{
  return (1 * ((t_0_n + 1) * 1));
}


public:

noleft_dangle_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i)
{
  if (((t_0_right_most - t_0_i) < 7))
    {
      return true;
    }

  unsigned int t_0_j = t_0_n;
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if ((t_0_j < (t_0_n - 0)))
    {
      return true;
    }

  unsigned int t_0_real_j = (t_0_n - t_0_j);
  return tabulated[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))];
}


void clear() { tabulated.clear(); }
pfanswer &  get(unsigned int t_0_i)
{
  unsigned int t_0_j = t_0_n;
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if ((t_0_j < (t_0_n - 0)))
    {
      return zero;
    }

  unsigned int t_0_real_j = (t_0_n - t_0_j);
  if (((t_0_right_most - t_0_i) < 7))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))]);
  assert( ((0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1))))) < size()));
  return array[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))];
}


void set(unsigned int t_0_i, const pfanswer & e)
{
  unsigned int t_0_j = t_0_n;
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if ((t_0_j < (t_0_n - 0)))
    {
      return;
    }

  unsigned int t_0_real_j = (t_0_n - t_0_j);
  if (((t_0_right_most - t_0_i) < 7))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i));
  assert( ((0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1))))) < size()));
  array[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))] = e;
  tabulated[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))] = true;
}


};
noleft_dangle_table_t noleft_dangle_table;



//void init(const gapc::Opts &opts)
void init(const std::vector<std::pair<const char *, unsigned> > &inp)
{
//const std::vector<std::pair<const char *, unsigned> > &inp = opts.inputs;
if(inp.size() != 1)
  throw gapc::OptException("Number of input sequences does not match.");

  t_0_seq.copy(inp[0].first, inp[0].second);
char_to_rna(t_0_seq);
  block_dl_table.init( t_0_seq.size(), "block_dl_table");
  block_dlr_table.init( t_0_seq.size(), "block_dlr_table");
  closed_table.init( t_0_seq.size(), "closed_table");
  dl_or_ss_left_ss_end_table.init( t_0_seq.size(), "dl_or_ss_left_ss_end_table");
  edangler_ml_table.init( t_0_seq.size(), "edangler_ml_table");
  left_dangle_table.init( t_0_seq.size(), "left_dangle_table");
  left_unpaired_table.init( t_0_seq.size(), "left_unpaired_table");
  ml_comps1_table.init( t_0_seq.size(), "ml_comps1_table");
  ml_comps2_table.init( t_0_seq.size(), "ml_comps2_table");
  ml_comps3_table.init( t_0_seq.size(), "ml_comps3_table");
  ml_comps4_table.init( t_0_seq.size(), "ml_comps4_table");
  no_dl_no_ss_end_table.init( t_0_seq.size(), "no_dl_no_ss_end_table");
  no_dl_ss_end_table.init( t_0_seq.size(), "no_dl_ss_end_table");
  nodangle_ml_table.init( t_0_seq.size(), "nodangle_ml_table");
  noleft_dangle_table.init( t_0_seq.size(), "noleft_dangle_table");
empty(pfanswer_zero);

t_0_left_most = 0;
t_0_right_most = t_0_seq.size();
}

  private:
    pfanswer &  nt_block_dl(unsigned int t_0_i, unsigned int t_0_j);
    pfanswer &  nt_block_dlr(unsigned int t_0_i, unsigned int t_0_j);
    pfanswer &  nt_closed(unsigned int t_0_i, unsigned int t_0_j);
    pfanswer nt_dl_or_ss_left_no_ss_end(unsigned int t_0_i, unsigned int t_0_j);
    pfanswer &  nt_dl_or_ss_left_ss_end(unsigned int t_0_i, unsigned int t_0_j);
    pfanswer nt_edanglel_ml(unsigned int t_0_i, unsigned int t_0_j);
    pfanswer nt_edanglel_struct(unsigned int t_0_i, unsigned int t_0_j);
    pfanswer nt_edanglelr_ml(unsigned int t_0_i, unsigned int t_0_j);
    pfanswer nt_edanglelr_struct(unsigned int t_0_i, unsigned int t_0_j);
    pfanswer &  nt_edangler_ml(unsigned int t_0_i, unsigned int t_0_j);
    pfanswer nt_edangler_struct(unsigned int t_0_i, unsigned int t_0_j);
    pfanswer nt_hairpin(unsigned int t_0_i, unsigned int t_0_j);
    pfanswer nt_iloop(unsigned int t_0_i, unsigned int t_0_j);
    pfanswer nt_initstem(unsigned int t_0_i, unsigned int t_0_j);
    pfanswer nt_leftB(unsigned int t_0_i, unsigned int t_0_j);
    pfanswer &  nt_left_dangle(unsigned int t_0_i);
    pfanswer &  nt_left_unpaired(unsigned int t_0_i);
    pfanswer &  nt_ml_comps1(unsigned int t_0_i, unsigned int t_0_j);
    pfanswer &  nt_ml_comps2(unsigned int t_0_i, unsigned int t_0_j);
    pfanswer &  nt_ml_comps3(unsigned int t_0_i, unsigned int t_0_j);
    pfanswer &  nt_ml_comps4(unsigned int t_0_i, unsigned int t_0_j);
    pfanswer nt_multiloop(unsigned int t_0_i, unsigned int t_0_j);
    pfanswer &  nt_no_dl_no_ss_end(unsigned int t_0_i, unsigned int t_0_j);
    pfanswer &  nt_no_dl_ss_end(unsigned int t_0_i, unsigned int t_0_j);
    pfanswer &  nt_nodangle_ml(unsigned int t_0_i, unsigned int t_0_j);
    pfanswer nt_nodangle_struct(unsigned int t_0_i, unsigned int t_0_j);
    pfanswer &  nt_noleft_dangle(unsigned int t_0_i);
    pfanswer nt_rightB(unsigned int t_0_i, unsigned int t_0_j);
    pfanswer nt_stack(unsigned int t_0_i, unsigned int t_0_j);
    pfanswer nt_struct();

    pfanswer acomb(const pfanswer & le, const TUSubsequence & b, const pfanswer & re);
    pfanswer addss(const pfanswer & e, const TUSubsequence & rregion);
    pfanswer ambd(const pfanswer & le, const TUSubsequence & b, const pfanswer & re);
    pfanswer ambd_Pr(const pfanswer & le, const TUSubsequence & b, const pfanswer & re);
    pfanswer bl(const TUSubsequence & lregion, const pfanswer & e);
    pfanswer br(const pfanswer & e, const TUSubsequence & rregion);
    pfanswer cadd(const pfanswer & le, const pfanswer & re);
    pfanswer cadd_Pr(const pfanswer & le, const pfanswer & re);
    pfanswer cadd_Pr_Pr(const pfanswer & le, const pfanswer & re);
    pfanswer cadd_Pr_Pr_Pr(const pfanswer & le, const pfanswer & re);
    pfanswer combine(const pfanswer & le, const pfanswer & re);
    pfanswer drem(const pfanswer & e);
    pfanswer edl(const TUSubsequence & lb, const pfanswer & e);
    pfanswer edlr(const TUSubsequence & lb, const pfanswer & e, const TUSubsequence & rb);
    pfanswer edr(const pfanswer & e, const TUSubsequence & rb);
    pfanswer h(pfanswer i);
    pfanswer hl(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & region, const TUSubsequence & rb, const TUSubsequence & rrb);
    pfanswer il(const TUSubsequence & lregion, const pfanswer & e, const TUSubsequence & rregion);
    pfanswer incl(const pfanswer & e);
    pfanswer is(const pfanswer & e);
    pfanswer ml(const TUSubsequence & llb, const TUSubsequence & lb, const pfanswer & e, const TUSubsequence & rb, const TUSubsequence & rrb);
    pfanswer mladl(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const pfanswer & e, const TUSubsequence & rb, const TUSubsequence & rrb);
    pfanswer mladldr(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const pfanswer & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb);
    pfanswer mladlr(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const pfanswer & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb);
    pfanswer mladr(const TUSubsequence & llb, const TUSubsequence & lb, const pfanswer & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb);
    pfanswer mldl(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const pfanswer & e, const TUSubsequence & rb, const TUSubsequence & rrb);
    pfanswer mldladr(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const pfanswer & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb);
    pfanswer mldlr(const TUSubsequence & llb, const TUSubsequence & lb, const TUSubsequence & dl, const pfanswer & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb);
    pfanswer mldr(const TUSubsequence & llb, const TUSubsequence & lb, const pfanswer & e, const TUSubsequence & dr, const TUSubsequence & rb, const TUSubsequence & rrb);
    pfanswer nil(const TUSubsequence & loc);
    pfanswer nil_Pr(const TUSubsequence & loc);
    pfanswer sadd(const TUSubsequence & lb, const pfanswer & e);
    pfanswer sp(const TUSubsequence & llb, const TUSubsequence & lb, const pfanswer & e, const TUSubsequence & rb, const TUSubsequence & rrb);
    pfanswer sr(const TUSubsequence & lb, const pfanswer & e, const TUSubsequence & rb);
    pfanswer ssadd(const TUSubsequence & lregion, const pfanswer & e);
    pfanswer trafo(const pfanswer & e);


 public:
   void cyk();

 public:
   pfanswer run()
{
  return nt_struct();
}
void print_stats(std::ostream &o)
{
#ifdef STATS
      o << "\n\nN = " << seq.size() << '\n';
      block_dl_table.print_stats(o, "block_dl_table");
      block_dlr_table.print_stats(o, "block_dlr_table");
      closed_table.print_stats(o, "closed_table");
      dl_or_ss_left_ss_end_table.print_stats(o, "dl_or_ss_left_ss_end_table");
      edangler_ml_table.print_stats(o, "edangler_ml_table");
      left_dangle_table.print_stats(o, "left_dangle_table");
      left_unpaired_table.print_stats(o, "left_unpaired_table");
      ml_comps1_table.print_stats(o, "ml_comps1_table");
      ml_comps2_table.print_stats(o, "ml_comps2_table");
      ml_comps3_table.print_stats(o, "ml_comps3_table");
      ml_comps4_table.print_stats(o, "ml_comps4_table");
      no_dl_no_ss_end_table.print_stats(o, "no_dl_no_ss_end_table");
      no_dl_ss_end_table.print_stats(o, "no_dl_ss_end_table");
      nodangle_ml_table.print_stats(o, "nodangle_ml_table");
      noleft_dangle_table.print_stats(o, "noleft_dangle_table");
#endif
}

template <typename Value>   void  print_result(std::ostream &out, Value& res)

{
if (is_empty(res))
  out << "[]\n";
else
  out << res << '\n';

}
template <typename Value>   void  print_backtrack(std::ostream &out, Value& value)

{
}
   void  print_subopt(std::ostream &out, int  delta = 0) {}

};

#ifndef NO_GAPC_TYPEDEFS
namespace gapc {
  typedef p_func class_name;
  typedef pfanswer return_type;
}
#endif

#endif

